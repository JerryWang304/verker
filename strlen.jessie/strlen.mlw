
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Strlen

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function strlen (s_0 : (pointer voidP)) (charP_charM_s_0_3_at_L : (memory
  voidP Int8.t)) : Uint64.t
  =
     (if
      (Int8.(=) (select charP_charM_s_0_3_at_L (shift s_0 (0)))
      (#"strlen.jc" 34 30 41# "expl:Integer cast" (Int8.of_int (0)))) then
      (#"strlen.jc" 34 48 61# "expl:Integer cast" (Uint64.of_int (0))) else
      (#"strlen.jc" 34 67 255# "expl:Integer cast"
      (Uint64.of_int
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_0 (1)) charP_charM_s_0_3_at_L))))))
  
  
  predicate valid_str (s : (pointer voidP)) (voidP_s_2_alloc_table_at_L :
  (alloc_table voidP)) (charP_charM_s_2_at_L : (memory voidP Int8.t))
  =
     (exists n_1 : Uint64.t.
      ((Int8.(=) (select charP_charM_s_2_at_L (shift s (Uint64.to_int n_1)))
       (#"strlen.jc" 21 42 53# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (if ((<=) (0) (Uint64.to_int n_1)) then
       (((<=) (offset_min voidP_s_2_alloc_table_at_L s) (0)) /\
       (((>=) (offset_max voidP_s_2_alloc_table_at_L s) (Uint64.to_int n_1))
       /\
       (forall __framac_tmp1 : int.
        ((((<=) (0) __framac_tmp1) /\
         ((<=) __framac_tmp1 (Uint64.to_int n_1))) -> ((=) true true)))))
       else ((=) true true))))
  
  
end

theory Axiomatic_LF__Axiomatic__valid_str_len

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  axiom LF__Lemma__valid_str_len
  #"/home/mikhail/repos/verker/strlen.h" 124 9 31#
  "expl:Axiom LF__Lemma__valid_str_len" :
  (forall voidP_s_8_16_alloc_table : (alloc_table voidP).
   (forall charP_charM_s_8_16 : (memory voidP Int8.t).
    (#"/home/mikhail/repos/verker/strlen.h" 124 9 31#
    (forall s_8_0 : (pointer voidP).
     ((valid_str s_8_0 voidP_s_8_16_alloc_table charP_charM_s_8_16) ->
      ((Int8.(=)
       (select charP_charM_s_8_16
       (shift s_8_0 (Uint64.to_int (strlen s_8_0 charP_charM_s_8_16))))
       (#"strlen.jc" 207 19 30# "expl:Integer cast" (Int8.of_int (0))))
      /\
      ((if ((<=) (0) (Uint64.to_int (strlen s_8_0 charP_charM_s_8_16))) then
        (((<=) (offset_min voidP_s_8_16_alloc_table s_8_0) (0)) /\
        (((>=) (offset_max voidP_s_8_16_alloc_table s_8_0)
         (Uint64.to_int (strlen s_8_0 charP_charM_s_8_16)))
        /\
        (forall __framac_tmp5 : int.
         ((((<=) (0) __framac_tmp5) /\
          ((<=) __framac_tmp5
          (Uint64.to_int (strlen s_8_0 charP_charM_s_8_16)))) ->
          ((=) true true))))) else ((=) true true))
      /\
      (forall j_1_0_0 : Uint64.t.
       ((Uint64.(<) j_1_0_0 (strlen s_8_0 charP_charM_s_8_16)) ->
        (Int8.(<>)
        (select charP_charM_s_8_16 (shift s_8_0 (Uint64.to_int j_1_0_0)))
        (#"strlen.jc" 218 58 69# "expl:Integer cast" (Int8.of_int (0)))))))))))))
  
  predicate _LF__Predicate__valid_str_len (x : int) = ((=) true true)
  
  
end

theory Axiomatic_LF__Axiomatic__valid_str_shiftn_integer

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  axiom LF__Lemma__valid_str_shiftn_integer
  #"/home/mikhail/repos/verker/strlen.h" 167 9 42#
  "expl:Axiom LF__Lemma__valid_str_shiftn_integer" :
  (forall voidP_s_10_17_alloc_table : (alloc_table voidP).
   (forall charP_charM_s_10_17 : (memory voidP Int8.t).
    (#"/home/mikhail/repos/verker/strlen.h" 167 9 42#
    (forall s_10_0 : (pointer voidP).
     (((_LF__Predicate__valid_str_len (1)) /\
      (valid_str s_10_0 voidP_s_10_17_alloc_table charP_charM_s_10_17)) ->
      (forall i_0_1 : int.
       ((((<=) (0) i_0_1) /\
        ((<) i_0_1 (Uint64.to_int (strlen s_10_0 charP_charM_s_10_17)))) ->
        (valid_str (shift s_10_0 i_0_1) voidP_s_10_17_alloc_table
        charP_charM_s_10_17))))))))
  
  predicate _LF__Predicate__valid_str_shiftn_integer (x_0 : int)
  = ((=) true true)
  
  
end

theory Axiomatic_LF__Axiomatic__strlen_before_null_integer

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  axiom LF__Lemma__strlen_before_null_integer
  #"/home/mikhail/repos/verker/strlen.h" 208 9 44#
  "expl:Axiom LF__Lemma__strlen_before_null_integer" :
  (forall voidP_s_6_18_alloc_table : (alloc_table voidP).
   (forall charP_charM_s_6_18 : (memory voidP Int8.t).
    (#"/home/mikhail/repos/verker/strlen.h" 208 9 44#
    (forall s_6_0 : (pointer voidP).
     (((_LF__Predicate__valid_str_len (1)) /\
      ((_LF__Predicate__valid_str_shiftn_integer (1)) /\
      (valid_str s_6_0 voidP_s_6_18_alloc_table charP_charM_s_6_18))) ->
      (forall i_1_0_0 : int.
       ((((<=) (0) i_1_0_0) /\
        ((<) i_1_0_0 (Uint64.to_int (strlen s_6_0 charP_charM_s_6_18)))) ->
        (Int8.(<>) (select charP_charM_s_6_18 (shift s_6_0 i_1_0_0))
        (#"strlen.jc" 493 44 55# "expl:Integer cast" (Int8.of_int (0)))))))))))
  
  predicate _LF__Predicate__strlen_before_null_integer (x_1 : int)
  = ((=) true true)
  
  
end

theory Axiomatic_LF__Axiomatic__strlen_at_null

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use why3.Bool.Bool 
  
  axiom LF__Lemma__strlen_at_null
  #"/home/mikhail/repos/verker/strlen.h" 225 9 42#
  "expl:Axiom LF__Lemma__strlen_at_null" :
  (forall voidP_s_4_19_alloc_table : (alloc_table voidP).
   (forall charP_charM_s_4_19 : (memory voidP Int8.t).
    (#"/home/mikhail/repos/verker/strlen.h" 225 9 42#
    (forall s_4_0 : (pointer voidP).
     (forall i_6 : Uint64.t.
      (((_LF__Predicate__valid_str_len (1)) /\
       ((_LF__Predicate__valid_str_shiftn_integer (1)) /\
       ((_LF__Predicate__strlen_before_null_integer (1)) /\
       (valid_str s_4_0 voidP_s_4_19_alloc_table charP_charM_s_4_19)))) ->
       (Int8.(=)
       (select charP_charM_s_4_19
       (shift s_4_0 (Uint64.to_int (strlen s_4_0 charP_charM_s_4_19))))
       (#"strlen.jc" 526 20 31# "expl:Integer cast" (Int8.of_int (0))))))))))
  
  predicate _LF__Predicate__strlen_at_null (x_2 : int) = ((=) true true)
  
  
end

theory Axiomatic_LF__Axiomatic__strlen_main

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  axiom LF__Lemma__strlen_main
  #"/home/mikhail/repos/verker/strlen.h" 237 9 39#
  "expl:Axiom LF__Lemma__strlen_main" :
  (forall voidP_s_7_20_alloc_table : (alloc_table voidP).
   (forall charP_charM_s_7_20 : (memory voidP Int8.t).
    (#"/home/mikhail/repos/verker/strlen.h" 237 9 39#
    (forall s_7_0 : (pointer voidP).
     (forall n_8_0 : Uint64.t.
      (((_LF__Predicate__valid_str_len (1)) /\
       ((_LF__Predicate__valid_str_shiftn_integer (1)) /\
       ((_LF__Predicate__strlen_before_null_integer (1)) /\
       ((_LF__Predicate__strlen_at_null (1)) /\
       ((valid_str s_7_0 voidP_s_7_20_alloc_table charP_charM_s_7_20) /\
       ((Int8.(=)
        (select charP_charM_s_7_20 (shift s_7_0 (Uint64.to_int n_8_0)))
        (#"strlen.jc" 565 55 66# "expl:Integer cast" (Int8.of_int (0))))
       /\
       (forall i_2_0_0 : int.
        ((((<=) (0) i_2_0_0) /\ ((<) i_2_0_0 (Uint64.to_int n_8_0))) ->
         (Int8.(<>) (select charP_charM_s_7_20 (shift s_7_0 i_2_0_0))
         (#"strlen.jc" 568 47 58# "expl:Integer cast" (Int8.of_int (0))))))))))))
       -> (Uint64.(=) (strlen s_7_0 charP_charM_s_7_20) n_8_0)))))))
  
  predicate _LF__Predicate__strlen_main (x_3 : int) = ((=) true true)
  
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_return_label_0_exc unit
  
  exception Goto_while_0_break_exc unit
  
  exception Goto_while_0_break_0_exc unit
  
  exception Goto_while_0_break_1_exc unit
  
  exception Goto_while_0_break_2_exc unit
  
  exception Goto_while_0_break_3_exc unit
  
  exception Goto_while_0_break_4_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_strlen_0_safety
#"/home/mikhail/repos/verker/strlen.c" 3 7 28# "expl:strlen, safety"

  use enum.Uint64 
  
  use Safe_uint64 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_sub_pointer_safe 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_main 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  let strlen_0 #"/home/mikhail/repos/verker/strlen.c" 3 7 28#
  "expl:Function strlen, safety" =
  fun
   (s_3_0 : (pointer voidP)) (voidP_s_3_15_alloc_table : (alloc_table voidP))
   (voidP_s_3_15_tag_table : (tag_table voidP)) (charP_charM_s_3_15 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_3_15_alloc_table s_3_0) ->
     (((=) (typeof voidP_s_3_15_tag_table s_3_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_3_15_alloc_table s_3_0) i) /\
       ((<) i (offset_max voidP_s_3_15_alloc_table s_3_0))) ->
       ((=) (typeof voidP_s_3_15_tag_table (shift s_3_0 i)) charP_tag)))))
   /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339#
    (_LF__Predicate__strlen_before_null_integer (1)))
   /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__strlen_at_null (1))) /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__strlen_main (1))) /\
   (#"/home/mikhail/repos/verker/strlen.h" 242 13 25#
   (valid_str s_3_0 voidP_s_3_15_alloc_table charP_charM_s_3_15)))))))))))))
   } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_uint64.any_  () ) in
   try
    begin
    (let sc = ref (any_pointer  () : (pointer voidP)) in
    (let __retres_1 = ref (Safe_uint64.any_  () ) in
    try
     begin
     (sc :=
      (let _jessie_97 = s_3_0 in
      begin
      (assert {
      (#"/home/mikhail/repos/verker/strlen.c" 11 6 12#
      "expl:Pointer index bounds" true) }); _jessie_97 end));
      'Loop_12:
      loop
      invariant { (#"strlen.jc" 600 6 1279# true) }
        variant { (#"/home/mikhail/repos/verker/strlen.c" 9 18 38#
          (Int.(-) (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15))
          (sub_pointer !sc s_3_0))) }
       begin
       any unit
       requires { true } reads { s_3_0 }
       ensures {
         ((#"/home/mikhail/repos/verker/strlen.c" 8 20 54#
          ((=) (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15))
          (Int.(+) (Uint64.to_int (strlen !sc charP_charM_s_3_15))
          (sub_pointer !sc s_3_0))))
         /\
         ((#"/home/mikhail/repos/verker/strlen.c" 7 20 33#
          (valid_str !sc voidP_s_3_15_alloc_table charP_charM_s_3_15))
         /\
         (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
         (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
         ((#"/home/mikhail/repos/verker/strlen.c" 6 20 27#
          (same_block s_3_0 !sc))
         /\
         (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
         ((#"/home/mikhail/repos/verker/strlen.c" 6 20 27#
          ((<=) (sub_pointer s_3_0 !sc) (0)))
         /\
         (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
         ((#"/home/mikhail/repos/verker/strlen.c" 6 25 44#
          (same_block !sc
          (shift s_3_0 (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15)))))
         /\
         (#"/home/mikhail/repos/verker/strlen.c" 6 25 44#
         ((<=)
         (sub_pointer !sc
         (shift s_3_0 (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15))))
         (0)))))))))))) } ;
        try
         begin
         begin
         (if
         (#"/home/mikhail/repos/verker/strlen.c" 11 14 25#
         (Safe_int32.(<>) 
          (#"/home/mikhail/repos/verker/strlen.c" 11 14 17#
          "expl:Integer cast"
          (Safe_int32_of_Safe_int8.cast 
           (#"/home/mikhail/repos/verker/strlen.c" 11 14 17#
           "expl:Pointer dereference"
           (acc  voidP_s_3_15_alloc_table charP_charM_s_3_15 !sc )) ))
          (#"strlen.jc" 621 28 40# "expl:Integer cast"
          (Safe_int32.of_int (0))) )) then ()
         else (raise (Goto_while_0_break_4_exc ())));
          (sc :=
           (let _jessie_98 =
           (shift_typesafe  !sc
            (Safe_int32.to_int 
             (#"strlen.jc" 623 44 56# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) ) in
           begin
           (assert {
           (#"/home/mikhail/repos/verker/strlen.c" 11 27 31#
           "expl:Pointer index bounds" true) }); _jessie_98 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_20 -> () end end end; (raise (Goto_while_0_break_4_exc ()))
     end with Goto_while_0_break_4_exc _jessie_18 ->
     'While_0_break_4:
     'While_0_break_4:
     begin
     ();
      begin
      (__retres_1 :=
       (let _jessie_99 =
       (#"/home/mikhail/repos/verker/strlen.c" 13 8 14# "expl:Integer cast"
       (Safe_uint64.of_int 
        (#"/home/mikhail/repos/verker/strlen.c" 13 8 14#
        (sub_pointer_  !sc s_3_0 )) )) in
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.c" 13 1 15#
       "expl:Pointer index bounds" true) }); _jessie_99 end));
       begin
       (return :=
        (let _jessie_100 = !__retres_1 in
        begin
        (assert { (#"strlen.jc" 629 7 24# "expl:Pointer index bounds" true)
        }); _jessie_100 end)); (raise Return) end end end end)); absurd  end
    with Return -> !return end)
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Function_strlen_0_behaviors
#"/home/mikhail/repos/verker/strlen.c" 3 7 28# "expl:strlen, behaviors"

  use Unsafe_uint64 
  
  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_sub_pointer_unsafe 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_main 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  let strlen_ensures_default #"/home/mikhail/repos/verker/strlen.c" 3 7 28#
  "expl:Function strlen, default behavior" =
  fun
   (s_3_0 : (pointer voidP)) (voidP_s_3_15_alloc_table : (alloc_table voidP))
   (voidP_s_3_15_tag_table : (tag_table voidP)) (charP_charM_s_3_15 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_3_15_alloc_table s_3_0) ->
     (((=) (typeof voidP_s_3_15_tag_table s_3_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_3_15_alloc_table s_3_0) i) /\
       ((<) i (offset_max voidP_s_3_15_alloc_table s_3_0))) ->
       ((=) (typeof voidP_s_3_15_tag_table (shift s_3_0 i)) charP_tag)))))
   /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339#
    (_LF__Predicate__strlen_before_null_integer (1)))
   /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__strlen_at_null (1))) /\
   (#"strlen.jc" 577 12 339#
   ((#"strlen.jc" 577 12 339# (_LF__Predicate__strlen_main (1))) /\
   (#"/home/mikhail/repos/verker/strlen.h" 242 13 25#
   (valid_str s_3_0 voidP_s_3_15_alloc_table charP_charM_s_3_15)))))))))))))
   }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 244 12 32# "expl:Ensures clause"
     (#"/home/mikhail/repos/verker/strlen.h" 244 12 32# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
      "expl:Ensures clause"
      (Uint64.(=) result (strlen s_3_0 charP_charM_s_3_15)))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 244 12 32# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 245 12 30#
      "expl:Ensures clause"
      (Int8.(=)
      (select charP_charM_s_3_15 (shift s_3_0 (Uint64.to_int result)))
      (#"strlen.jc" 587 35 46# "expl:Integer cast" (Int8.of_int (0)))))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 246 12 64# "expl:Ensures clause"
     (forall i_3_0 : int.
      ((((<=) (0) i_3_0) /\ ((<) i_3_0 (Uint64.to_int result))) ->
       (Int8.(<>) (select charP_charM_s_3_15 (shift s_3_0 i_3_0))
       (#"strlen.jc" 592 40 51# "expl:Integer cast" (Int8.of_int (0)))))))))))))
     } diverges  ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (let sc = ref (any_pointer  () : (pointer voidP)) in
    (let __retres_1 = ref (Unsafe_uint64.any_  () ) in
    try
     begin
     (sc := s_3_0);
      'Loop_11:
      loop
      invariant
        { ((#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
           (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
           ((#"/home/mikhail/repos/verker/strlen.c" 6 20 27#
            (same_block s_3_0 !sc))
           /\
           (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
           ((#"/home/mikhail/repos/verker/strlen.c" 6 20 27#
            ((<=) (sub_pointer s_3_0 !sc) (0)))
           /\
           (#"/home/mikhail/repos/verker/strlen.c" 6 20 44#
           ((#"/home/mikhail/repos/verker/strlen.c" 6 25 44#
            (same_block !sc
            (shift s_3_0 (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15)))))
           /\
           (#"/home/mikhail/repos/verker/strlen.c" 6 25 44#
           ((<=)
           (sub_pointer !sc
           (shift s_3_0 (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15))))
           (0))))))))))
          &&
          ((#"/home/mikhail/repos/verker/strlen.c" 7 20 33#
           (valid_str !sc voidP_s_3_15_alloc_table charP_charM_s_3_15))
          &&
          (#"/home/mikhail/repos/verker/strlen.c" 8 20 54#
          ((=) (Uint64.to_int (strlen s_3_0 charP_charM_s_3_15))
          (Int.(+) (Uint64.to_int (strlen !sc charP_charM_s_3_15))
          (sub_pointer !sc s_3_0)))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/mikhail/repos/verker/strlen.c" 11 14 25#
         (Unsafe_int32.(<>) 
          (#"/home/mikhail/repos/verker/strlen.c" 11 14 17#
          "expl:Integer cast"
          (Unsafe_int32_of_Unsafe_int8.cast  (acc  charP_charM_s_3_15 !sc ) ))
          (#"strlen.jc" 621 28 40# "expl:Integer cast"
          (Unsafe_int32.of_int (0))) )) then ()
         else (raise (Goto_while_0_break_4_exc ())));
          (sc :=
           (shift_  !sc
            (Unsafe_int32.to_int 
             (#"strlen.jc" 623 44 56# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) ) )) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_20 -> () end end end; (raise (Goto_while_0_break_4_exc ()))
     end with Goto_while_0_break_4_exc _jessie_18 ->
     'While_0_break_4:
     'While_0_break_4:
     begin
     ();
      begin
      (__retres_1 :=
       (#"/home/mikhail/repos/verker/strlen.c" 13 8 14# "expl:Integer cast"
       (Unsafe_uint64.of_int 
        (#"/home/mikhail/repos/verker/strlen.c" 13 8 14#
        (sub_pointer_  !sc s_3_0 )) )));
       begin (return := !__retres_1); (raise Return) end end end end));
     absurd  end with Return -> !return end)
  
end

module Function_elim_valid_str_safety
#"/home/mikhail/repos/verker/strlen.h" 86 11 34#
"expl:elim_valid_str, safety"

  use enum.Uint64 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use Safe_bit_uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Exceptions 
  
  use enum.Bit_uint64 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let elim_valid_str #"/home/mikhail/repos/verker/strlen.h" 86 11 34#
  "expl:Function elim_valid_str, safety" =
  fun
   (s_0_0 : (pointer voidP)) (voidP_s_0_4_alloc_table : (alloc_table voidP))
   (voidP_s_0_4_tag_table : (tag_table voidP)) (charP_charM_s_0_4 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_0_4_alloc_table s_0_0) ->
     (((=) (typeof voidP_s_0_4_tag_table s_0_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_0_4_alloc_table s_0_0) i) /\
       ((<) i (offset_max voidP_s_0_4_alloc_table s_0_0))) ->
       ((=) (typeof voidP_s_0_4_tag_table (shift s_0_0 i)) charP_tag)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 81 16 28#
   (valid_str s_0_0 voidP_s_0_4_alloc_table charP_charM_s_0_4))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_bit_uint64.any_  () ) in
   try
    begin
    (let i_2 = ref (Safe_bit_uint64.any_  () ) in
    (let __retres = ref (Safe_bit_uint64.any_  () ) in
    try
     begin
     try
      begin
      (i_2 :=
       (let _jessie_26 =
       (#"strlen.jc" 64 21 34# "expl:Integer cast"
       (Safe_bit_uint64.of_int_const 0)) in
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.h" 91 19 20#
       "expl:Pointer index bounds" true) }); _jessie_26 end));
       'Loop_2:
       loop
       invariant { (#"strlen.jc" 66 6 872# true) }
         variant { (#"/home/mikhail/repos/verker/strlen.h" 89 23 34#
           (Int.(-)
           (Bit_uint64.to_int
           (Bit_uint64.(~_) (#"strlen.jc" 71 27 43# "expl:Integer cast"
           (Bit_uint64.of_int_const 0)))) (Bit_uint64.to_int !i_2))) }
        begin
        any unit
        requires { true } reads { s_0_0 }
        ensures {
          (#"/home/mikhail/repos/verker/strlen.h" 88 25 65#
          (forall j_0 : Uint64.t.
           ((Bit_uint64.(<) j_0 !i_2) ->
            (Int8.(<>)
            (select charP_charM_s_0_4 (shift s_0_0 (Bit_uint64.to_int j_0)))
            (#"strlen.jc" 70 63 74# "expl:Integer cast" (Int8.of_int (0)))))))
          } ;
         try
          begin
          begin
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 91 26 38#
          (Safe_bit_uint64.(<=)  !i_2
           (#"strlen.jc" 75 26 58# "expl:Integer cast"
           (Safe_bit_uint64.of_int_const 18446744073709551615)) )) then ()
          else (raise (Goto_while_0_break_exc ())));
           (if
           (#"/home/mikhail/repos/verker/strlen.h" 92 13 25#
           (Safe_int32.(=) 
            (#"/home/mikhail/repos/verker/strlen.h" 92 13 17#
            "expl:Integer cast"
            (Safe_int32_of_Safe_int8.cast 
             (#"/home/mikhail/repos/verker/strlen.h" 92 13 17#
             "expl:Pointer dereference"
             (acc_offset_typesafe  voidP_s_0_4_alloc_table charP_charM_s_0_4
              s_0_0 (Safe_bit_uint64.to_int  !i_2 ) )) ))
            (#"strlen.jc" 79 30 42# "expl:Integer cast"
            (Safe_int32.of_int (0))) ))
           then
            begin
            (__retres :=
             (let _jessie_27 = !i_2 in
             begin
             (assert {
             (#"/home/mikhail/repos/verker/strlen.h" 92 27 36#
             "expl:Pointer index bounds" true) }); _jessie_27 end));
             (raise (Return_label_exc ())) end else ());
           (i_2 :=
            (let _jessie_28 =
            (Safe_bit_uint64.(+)  !i_2
             (#"strlen.jc" 85 54 67# "expl:Integer cast"
             (Safe_bit_uint64.of_int_const 1)) ) in
            begin
            (assert {
            (#"/home/mikhail/repos/verker/strlen.h" 91 40 43#
            "expl:Pointer index bounds" true) }); _jessie_28 end)) end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_4 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end with Goto_while_0_break_exc _jessie_1 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       any unit
       requires { true }
       ensures {
         (#"/home/mikhail/repos/verker/strlen.h" 94 4 5# ((=) false true)) } ;
        () end;
       (__retres :=
        (let _jessie_29 =
        (#"strlen.jc" 94 27 40# "expl:Integer cast"
        (Safe_bit_uint64.of_int_const 0)) in
        begin
        (assert {
        (#"/home/mikhail/repos/verker/strlen.h" 94 4 5#
        "expl:Pointer index bounds" true) }); _jessie_29 end)) end end;
      (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
     'Return_label:
     'Return_label:
     begin
     (return :=
      (let _jessie_30 = !__retres in
      begin
      (assert { (#"strlen.jc" 96 7 22# "expl:Pointer index bounds" true) });
       _jessie_30 end)); (raise Return) end end)); absurd  end with Return ->
    !return end)
  
end

module Function_elim_valid_str_behaviors
#"/home/mikhail/repos/verker/strlen.h" 86 11 34#
"expl:elim_valid_str, behaviors"

  use Unsafe_uint64 
  
  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let elim_valid_str_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 86 11 34#
  "expl:Function elim_valid_str, default behavior" =
  fun
   (s_0_0 : (pointer voidP)) (voidP_s_0_4_alloc_table : (alloc_table voidP))
   (voidP_s_0_4_tag_table : (tag_table voidP)) (charP_charM_s_0_4 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_0_4_alloc_table s_0_0) ->
     (((=) (typeof voidP_s_0_4_tag_table s_0_0) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_0_4_alloc_table s_0_0) i) /\
       ((<) i (offset_max voidP_s_0_4_alloc_table s_0_0))) ->
       ((=) (typeof voidP_s_0_4_tag_table (shift s_0_0 i)) charP_tag)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 81 16 28#
   (valid_str s_0_0 voidP_s_0_4_alloc_table charP_charM_s_0_4))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 82 15 33# "expl:Ensures clause"
     (#"/home/mikhail/repos/verker/strlen.h" 82 15 33# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 82 15 33# "expl:Ensures clause"
      (Int8.(=)
      (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int result)))
      (#"strlen.jc" 44 31 42# "expl:Integer cast" (Int8.of_int (0)))))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 82 15 33# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 83 15 37# "expl:Ensures clause"
      (if ((<=) (0) (Uint64.to_int result)) then
       (((<=) (offset_min voidP_s_0_4_alloc_table s_0_0) (0)) /\
       (((>=) (offset_max voidP_s_0_4_alloc_table s_0_0)
        (Uint64.to_int result))
       /\
       (forall __framac_tmp2 : int.
        ((((<=) (0) __framac_tmp2) /\
         ((<=) __framac_tmp2 (Uint64.to_int result))) -> ((=) true true)))))
       else ((=) true true)))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 84 15 61# "expl:Ensures clause"
     (forall j : Uint64.t.
      ((Uint64.(<) j result) ->
       (Int8.(<>) (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int j)))
       (#"strlen.jc" 58 38 49# "expl:Integer cast" (Int8.of_int (0)))))))))))))
     } diverges  ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (let i_2 = ref (Unsafe_uint64.any_  () ) in
    (let __retres = ref (Unsafe_uint64.any_  () ) in
    try
     begin
     try
      begin
      (i_2 :=
       (#"strlen.jc" 64 21 34# "expl:Integer cast"
       (Unsafe_uint64.of_int (0))));
       'Loop_1:
       loop
       invariant
         { (#"/home/mikhail/repos/verker/strlen.h" 88 25 65#
           (forall j_0 : Uint64.t.
            ((Uint64.(<) j_0 !i_2) ->
             (Int8.(<>)
             (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int j_0)))
             (#"strlen.jc" 70 63 74# "expl:Integer cast" (Int8.of_int (0))))))) }
         
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 91 26 38#
          (Unsafe_uint64.(<=)  !i_2
           (#"strlen.jc" 75 26 58# "expl:Integer cast"
           (Unsafe_uint64.of_int (18446744073709551615))) )) then ()
          else (raise (Goto_while_0_break_exc ())));
           (if
           (#"/home/mikhail/repos/verker/strlen.h" 92 13 25#
           (Unsafe_int32.(=) 
            (#"/home/mikhail/repos/verker/strlen.h" 92 13 17#
            "expl:Integer cast"
            (Unsafe_int32_of_Unsafe_int8.cast 
             (acc  charP_charM_s_0_4
              (shift_  s_0_0 (Unsafe_uint64.to_int  !i_2 ) ) ) ))
            (#"strlen.jc" 79 30 42# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) ))
           then begin (__retres := !i_2); (raise (Return_label_exc ())) end
           else ());
           (i_2 :=
            (Unsafe_uint64.(+)  !i_2
             (#"strlen.jc" 85 54 67# "expl:Integer cast"
             (Unsafe_uint64.of_int (1))) )) end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_4 -> () end end end; (raise (Goto_while_0_break_exc ()))
      end with Goto_while_0_break_exc _jessie_1 ->
      'While_0_break:
      'While_0_break:
      begin
      ();
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.h" 94 4 5#
       "expl:Assertion in line 94" ((=) false true)) }); () end;
       (__retres :=
        (#"strlen.jc" 94 27 40# "expl:Integer cast"
        (Unsafe_uint64.of_int (0)))) end end; (raise (Return_label_exc ()))
     end with Return_label_exc _jessie_2 ->
     'Return_label:
     'Return_label: begin (return := !__retres); (raise Return) end end));
     absurd  end with Return -> !return end)
  
end

module Function_elim_valid_str_safe

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val elim_valid_str
  (s_0_0 : (pointer voidP)) 
   (voidP_s_0_4_alloc_table : (alloc_table voidP)) 
    (voidP_s_0_4_tag_table : (tag_table voidP)) 
     (charP_charM_s_0_4 : (memory voidP Int8.t)) : Uint64.t
      requires {
        ("expl:Internal"
        (#"/home/mikhail/repos/verker/strlen.h" 81 16 28#
        "expl:Requires clause"
        (valid_str s_0_0 voidP_s_0_4_alloc_table charP_charM_s_0_4))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int result)))
         (#"strlen.jc" 44 31 42# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 83 15 37#
         "expl:Ensures clause"
         (if ((<=) (0) (Uint64.to_int result)) then
          (((<=) (offset_min voidP_s_0_4_alloc_table s_0_0) (0)) /\
          (((>=) (offset_max voidP_s_0_4_alloc_table s_0_0)
           (Uint64.to_int result))
          /\
          (forall __framac_tmp2 : int.
           ((((<=) (0) __framac_tmp2) /\
            ((<=) __framac_tmp2 (Uint64.to_int result))) -> ((=) true true)))))
          else ((=) true true)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 84 15 61#
        "expl:Ensures clause"
        (forall j : Uint64.t.
         ((Uint64.(<) j result) ->
          (Int8.(<>)
          (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int j)))
          (#"strlen.jc" 58 38 49# "expl:Integer cast" (Int8.of_int (0))))))))))))
        }
  
end

module Function_elim_valid_str_len_safety
#"/home/mikhail/repos/verker/strlen.h" 104 11 38#
"expl:elim_valid_str_len, safety"

  use enum.Uint64 
  
  use Safe_uint64 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_offset_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_elim_valid_str_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let elim_valid_str_len #"/home/mikhail/repos/verker/strlen.h" 104 11 38#
  "expl:Function elim_valid_str_len, safety" =
  fun
   (s_1 : (pointer voidP)) (voidP_s_1_5_alloc_table : (alloc_table voidP))
   (voidP_s_1_5_tag_table : (tag_table voidP)) (charP_charM_s_1_5 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_1_5_alloc_table s_1) ->
     (((=) (typeof voidP_s_1_5_tag_table s_1) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_1_5_alloc_table s_1) i) /\
       ((<) i (offset_max voidP_s_1_5_alloc_table s_1))) ->
       ((=) (typeof voidP_s_1_5_tag_table (shift s_1 i)) charP_tag)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 98 16 28#
   (valid_str s_1 voidP_s_1_5_alloc_table charP_charM_s_1_5))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (Safe_uint64.any_  () ) in
   try
    begin
    (let size_1 = ref (Safe_uint64.any_  () ) in
    (let i_3 = ref (Safe_uint64.any_  () ) in
    (let __retres_0 = ref (Safe_uint64.any_  () ) in
    try
     begin
     (size_1 :=
      (let _jessie_39 =
      (let _jessie_40 = s_1 in
      (#"/home/mikhail/repos/verker/strlen.h" 106 21 38#
      "expl:Precondition for elim_valid_str"
      (Function_elim_valid_str_safe.elim_valid_str  _jessie_40
       voidP_s_1_5_alloc_table voidP_s_1_5_tag_table charP_charM_s_1_5 ))) in
      begin
      (assert {
      (#"/home/mikhail/repos/verker/strlen.h" 106 21 38#
      "expl:Pointer index bounds" true) }); _jessie_39 end));
      try
       begin
       (i_3 :=
        (let _jessie_41 =
        (#"strlen.jc" 129 25 38# "expl:Integer cast"
        (Safe_uint64.of_int (0))) in
        begin
        (assert {
        (#"/home/mikhail/repos/verker/strlen.h" 111 19 20#
        "expl:Pointer index bounds" true) }); _jessie_41 end));
        'Loop_4:
        loop
        invariant { (#"strlen.jc" 131 9 1252# true) }
          variant { (#"/home/mikhail/repos/verker/strlen.h" 109 23 31#
            (Int.(-) (Uint64.to_int !size_1) (Uint64.to_int !i_3))) }
         begin
         any unit
         requires { true } reads { s_1 }
         ensures {
           ((#"/home/mikhail/repos/verker/strlen.h" 108 25 39#
            (#"/home/mikhail/repos/verker/strlen.h" 108 25 39#
            ((#"/home/mikhail/repos/verker/strlen.h" 108 25 31#
             (Uint64.(<=) (#"strlen.jc" 140 41 54# "expl:Integer cast"
             (Uint64.of_int (0))) !i_3))
            /\
            (#"/home/mikhail/repos/verker/strlen.h" 108 30 39#
            (Uint64.(<=) !i_3 !size_1)))))
           /\
           (#"/home/mikhail/repos/verker/strlen.h" 107 25 85#
           (((<=)
            (Int.(+)
            (Uint64.to_int
            (strlen (shift s_1 (Uint64.to_int !i_3)) charP_charM_s_1_5))
            (Uint64.to_int !i_3)) (Uint64.to_int !size_1)) ->
            ((=) (Uint64.to_int (strlen s_1 charP_charM_s_1_5))
            (Int.(+)
            (Uint64.to_int
            (strlen (shift s_1 (Uint64.to_int !i_3)) charP_charM_s_1_5))
            (Uint64.to_int !i_3)))))) } ;
          try
           begin
           begin
           (if
           (#"/home/mikhail/repos/verker/strlen.h" 111 26 35#
           (Safe_uint64.(<=)  !i_3 !size_1 )) then ()
           else (raise (Goto_while_0_break_0_exc ())));
            (if
            (#"/home/mikhail/repos/verker/strlen.h" 112 13 25#
            (Safe_int32.(=) 
             (#"/home/mikhail/repos/verker/strlen.h" 112 13 17#
             "expl:Integer cast"
             (Safe_int32_of_Safe_int8.cast 
              (#"/home/mikhail/repos/verker/strlen.h" 112 13 17#
              "expl:Pointer dereference"
              (acc_offset_typesafe  voidP_s_1_5_alloc_table charP_charM_s_1_5
               s_1 (Safe_uint64.to_int  !i_3 ) )) ))
             (#"strlen.jc" 149 33 45# "expl:Integer cast"
             (Safe_int32.of_int (0))) ))
            then
             begin
             (__retres_0 :=
              (let _jessie_42 = !i_3 in
              begin
              (assert {
              (#"/home/mikhail/repos/verker/strlen.h" 112 27 36#
              "expl:Pointer index bounds" true) }); _jessie_42 end));
              (raise (Goto_return_label_0_exc ())) end else ());
            (i_3 :=
             (let _jessie_43 =
             (Safe_uint64.(+)  !i_3
              (#"strlen.jc" 155 57 70# "expl:Integer cast"
              (Safe_uint64.of_int (1))) ) in
             begin
             (assert {
             (#"/home/mikhail/repos/verker/strlen.h" 111 37 40#
             "expl:Pointer index bounds" true) }); _jessie_43 end)) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_8 -> () end end end; (raise (Goto_while_0_break_0_exc ()))
       end with Goto_while_0_break_0_exc _jessie_5 ->
       'While_0_break_0: 'While_0_break_0: () end;
      begin
      any unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 114 4 5# ((=) false true)) } ;
       () end;
      begin
      (__retres_0 :=
       (let _jessie_38 =
       (#"strlen.jc" 165 29 42# "expl:Integer cast" (Safe_uint64.of_int (0)))
       in
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.h" 114 4 5#
       "expl:Pointer index bounds" true) }); _jessie_38 end));
       (raise (Goto_return_label_0_exc ())) end end with
     Goto_return_label_0_exc _jessie_6 ->
     'Return_label_0:
     'Return_label_0:
     begin
     (return :=
      (let _jessie_44 = !__retres_0 in
      begin
      (assert { (#"strlen.jc" 167 7 24# "expl:Pointer index bounds" true) });
       _jessie_44 end)); (raise Return) end end))); absurd  end with Return
    -> !return end)
  
end

module Function_elim_valid_str

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val elim_valid_str
  (s_0_0 : (pointer voidP)) 
   (voidP_s_0_4_alloc_table : (alloc_table voidP)) 
    (voidP_s_0_4_tag_table : (tag_table voidP)) 
     (charP_charM_s_0_4 : (memory voidP Int8.t)) : Uint64.t
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int result)))
         (#"strlen.jc" 44 31 42# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 82 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 83 15 37#
         "expl:Ensures clause"
         (if ((<=) (0) (Uint64.to_int result)) then
          (((<=) (offset_min voidP_s_0_4_alloc_table s_0_0) (0)) /\
          (((>=) (offset_max voidP_s_0_4_alloc_table s_0_0)
           (Uint64.to_int result))
          /\
          (forall __framac_tmp2 : int.
           ((((<=) (0) __framac_tmp2) /\
            ((<=) __framac_tmp2 (Uint64.to_int result))) -> ((=) true true)))))
          else ((=) true true)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 84 15 61#
        "expl:Ensures clause"
        (forall j : Uint64.t.
         ((Uint64.(<) j result) ->
          (Int8.(<>)
          (select charP_charM_s_0_4 (shift s_0_0 (Uint64.to_int j)))
          (#"strlen.jc" 58 38 49# "expl:Integer cast" (Int8.of_int (0))))))))))))
        }
  
end

module Function_elim_valid_str_len_behaviors
#"/home/mikhail/repos/verker/strlen.h" 104 11 38#
"expl:elim_valid_str_len, behaviors"

  use Unsafe_uint64 
  
  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_elim_valid_str 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let elim_valid_str_len_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 104 11 38#
  "expl:Function elim_valid_str_len, default behavior" =
  fun
   (s_1 : (pointer voidP)) (voidP_s_1_5_alloc_table : (alloc_table voidP))
   (voidP_s_1_5_tag_table : (tag_table voidP)) (charP_charM_s_1_5 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_1_5_alloc_table s_1) ->
     (((=) (typeof voidP_s_1_5_tag_table s_1) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_1_5_alloc_table s_1) i) /\
       ((<) i (offset_max voidP_s_1_5_alloc_table s_1))) ->
       ((=) (typeof voidP_s_1_5_tag_table (shift s_1 i)) charP_tag)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 98 16 28#
   (valid_str s_1 voidP_s_1_5_alloc_table charP_charM_s_1_5))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 99 15 33# "expl:Ensures clause"
     (#"/home/mikhail/repos/verker/strlen.h" 99 15 33# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 99 15 33# "expl:Ensures clause"
      (Int8.(=) (select charP_charM_s_1_5 (shift s_1 (Uint64.to_int result)))
      (#"strlen.jc" 104 31 42# "expl:Integer cast" (Int8.of_int (0)))))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 99 15 33# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 100 15 37#
      "expl:Ensures clause"
      (if ((<=) (0) (Uint64.to_int result)) then
       (((<=) (offset_min voidP_s_1_5_alloc_table s_1) (0)) /\
       (((>=) (offset_max voidP_s_1_5_alloc_table s_1)
        (Uint64.to_int result))
       /\
       (forall __framac_tmp3 : int.
        ((((<=) (0) __framac_tmp3) /\
         ((<=) __framac_tmp3 (Uint64.to_int result))) -> ((=) true true)))))
       else ((=) true true)))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 99 15 33# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 101 15 61#
      "expl:Ensures clause"
      (forall j_0_0 : Uint64.t.
       ((Uint64.(<) j_0_0 result) ->
        (Int8.(<>)
        (select charP_charM_s_1_5 (shift s_1 (Uint64.to_int j_0_0)))
        (#"strlen.jc" 118 39 50# "expl:Integer cast" (Int8.of_int (0)))))))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 102 15 35# "expl:Ensures clause"
     (Uint64.(=) (strlen s_1 charP_charM_s_1_5) result)))))))))) } diverges 
   ->
   'Init:
   (let return = ref (Unsafe_uint64.any_  () ) in
   try
    begin
    (let size_1 = ref (Unsafe_uint64.any_  () ) in
    (let i_3 = ref (Unsafe_uint64.any_  () ) in
    (let __retres_0 = ref (Unsafe_uint64.any_  () ) in
    try
     begin
     (size_1 :=
      (let _jessie_33 = s_1 in
      (#"/home/mikhail/repos/verker/strlen.h" 106 21 38#
      "expl:Precondition for elim_valid_str"
      (Function_elim_valid_str.elim_valid_str  _jessie_33
       voidP_s_1_5_alloc_table voidP_s_1_5_tag_table charP_charM_s_1_5 ))));
      try
       begin
       (i_3 :=
        (#"strlen.jc" 129 25 38# "expl:Integer cast"
        (Unsafe_uint64.of_int (0))));
        'Loop_3:
        loop
        invariant
          { ((#"/home/mikhail/repos/verker/strlen.h" 107 25 85#
             (((<=)
              (Int.(+)
              (Uint64.to_int
              (strlen (shift s_1 (Uint64.to_int !i_3)) charP_charM_s_1_5))
              (Uint64.to_int !i_3)) (Uint64.to_int !size_1)) ->
              ((=) (Uint64.to_int (strlen s_1 charP_charM_s_1_5))
              (Int.(+)
              (Uint64.to_int
              (strlen (shift s_1 (Uint64.to_int !i_3)) charP_charM_s_1_5))
              (Uint64.to_int !i_3)))))
            &&
            (#"/home/mikhail/repos/verker/strlen.h" 108 25 39#
            (#"/home/mikhail/repos/verker/strlen.h" 108 25 39#
            ((#"/home/mikhail/repos/verker/strlen.h" 108 25 31#
             (Uint64.(<=) (#"strlen.jc" 140 41 54# "expl:Integer cast"
             (Uint64.of_int (0))) !i_3))
            /\
            (#"/home/mikhail/repos/verker/strlen.h" 108 30 39#
            (Uint64.(<=) !i_3 !size_1)))))) } 
         begin
         any unit requires { true } ensures { true } ;
          try
           begin
           begin
           (if
           (#"/home/mikhail/repos/verker/strlen.h" 111 26 35#
           (Unsafe_uint64.(<=)  !i_3 !size_1 )) then ()
           else (raise (Goto_while_0_break_0_exc ())));
            (if
            (#"/home/mikhail/repos/verker/strlen.h" 112 13 25#
            (Unsafe_int32.(=) 
             (#"/home/mikhail/repos/verker/strlen.h" 112 13 17#
             "expl:Integer cast"
             (Unsafe_int32_of_Unsafe_int8.cast 
              (acc  charP_charM_s_1_5
               (shift_  s_1 (Unsafe_uint64.to_int  !i_3 ) ) ) ))
             (#"strlen.jc" 149 33 45# "expl:Integer cast"
             (Unsafe_int32.of_int (0))) ))
            then
             begin (__retres_0 := !i_3); (raise (Goto_return_label_0_exc ()))
             end else ());
            (i_3 :=
             (Unsafe_uint64.(+)  !i_3
              (#"strlen.jc" 155 57 70# "expl:Integer cast"
              (Unsafe_uint64.of_int (1))) )) end;
            (raise (Loop_continue_exc ())) end with Loop_continue_exc
           _jessie_8 -> () end end end; (raise (Goto_while_0_break_0_exc ()))
       end with Goto_while_0_break_0_exc _jessie_5 ->
       'While_0_break_0: 'While_0_break_0: () end;
      begin
      (assert {
      (#"/home/mikhail/repos/verker/strlen.h" 114 4 5#
      "expl:Assertion in line 114" ((=) false true)) }); () end;
      begin
      (__retres_0 :=
       (#"strlen.jc" 165 29 42# "expl:Integer cast"
       (Unsafe_uint64.of_int (0)))); (raise (Goto_return_label_0_exc ())) end
     end with Goto_return_label_0_exc _jessie_6 ->
     'Return_label_0:
     'Return_label_0: begin (return := !__retres_0); (raise Return) end end)));
     absurd  end with Return -> !return end)
  
end

module Function_elim_valid_str_len_safe

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val elim_valid_str_len
  (s_1 : (pointer voidP)) 
   (voidP_s_1_5_alloc_table : (alloc_table voidP)) 
    (voidP_s_1_5_tag_table : (tag_table voidP)) 
     (charP_charM_s_1_5 : (memory voidP Int8.t)) : Uint64.t
      requires {
        ("expl:Internal"
        (#"/home/mikhail/repos/verker/strlen.h" 98 16 28#
        "expl:Requires clause"
        (valid_str s_1 voidP_s_1_5_alloc_table charP_charM_s_1_5))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_1_5 (shift s_1 (Uint64.to_int result)))
         (#"strlen.jc" 104 31 42# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 100 15 37#
         "expl:Ensures clause"
         (if ((<=) (0) (Uint64.to_int result)) then
          (((<=) (offset_min voidP_s_1_5_alloc_table s_1) (0)) /\
          (((>=) (offset_max voidP_s_1_5_alloc_table s_1)
           (Uint64.to_int result))
          /\
          (forall __framac_tmp3 : int.
           ((((<=) (0) __framac_tmp3) /\
            ((<=) __framac_tmp3 (Uint64.to_int result))) -> ((=) true true)))))
          else ((=) true true)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 101 15 61#
         "expl:Ensures clause"
         (forall j_0_0 : Uint64.t.
          ((Uint64.(<) j_0_0 result) ->
           (Int8.(<>)
           (select charP_charM_s_1_5 (shift s_1 (Uint64.to_int j_0_0)))
           (#"strlen.jc" 118 39 50# "expl:Integer cast" (Int8.of_int (0)))))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 102 15 35#
        "expl:Ensures clause"
        (Uint64.(=) (strlen s_1 charP_charM_s_1_5) result))))))))) }
  
end

module Function_valid_str_len_safety
#"/home/mikhail/repos/verker/strlen.h" 124 9 31# "expl:valid_str_len, safety"

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_elim_valid_str_len_safe 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let valid_str_len #"/home/mikhail/repos/verker/strlen.h" 124 9 31#
  "expl:Function valid_str_len, safety" =
  fun
   (s_8 : (pointer voidP)) (voidP_s_8_6_alloc_table : (alloc_table voidP))
   (voidP_s_8_6_tag_table : (tag_table voidP)) (charP_charM_s_8_6 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_8_6_alloc_table s_8) ->
     (((=) (typeof voidP_s_8_6_tag_table s_8) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_8_6_alloc_table s_8) i) /\
       ((<) i (offset_max voidP_s_8_6_alloc_table s_8))) ->
       ((=) (typeof voidP_s_8_6_tag_table (shift s_8 i)) charP_tag)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 119 16 28#
   (valid_str s_8 voidP_s_8_6_alloc_table charP_charM_s_8_6))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let _jessie_48 =
    (let _jessie_47 = s_8 in
    (#"/home/mikhail/repos/verker/strlen.h" 126 6 27#
    "expl:Precondition for elim_valid_str_len"
    (Function_elim_valid_str_len_safe.elim_valid_str_len  _jessie_47
     voidP_s_8_6_alloc_table voidP_s_8_6_tag_table charP_charM_s_8_6 ))) in
    ()); (raise Return); (raise Return) end with Return -> () end
  
end

module Function_elim_valid_str_len

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val elim_valid_str_len
  (s_1 : (pointer voidP)) 
   (voidP_s_1_5_alloc_table : (alloc_table voidP)) 
    (voidP_s_1_5_tag_table : (tag_table voidP)) 
     (charP_charM_s_1_5 : (memory voidP Int8.t)) : Uint64.t
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_1_5 (shift s_1 (Uint64.to_int result)))
         (#"strlen.jc" 104 31 42# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 100 15 37#
         "expl:Ensures clause"
         (if ((<=) (0) (Uint64.to_int result)) then
          (((<=) (offset_min voidP_s_1_5_alloc_table s_1) (0)) /\
          (((>=) (offset_max voidP_s_1_5_alloc_table s_1)
           (Uint64.to_int result))
          /\
          (forall __framac_tmp3 : int.
           ((((<=) (0) __framac_tmp3) /\
            ((<=) __framac_tmp3 (Uint64.to_int result))) -> ((=) true true)))))
          else ((=) true true)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 99 15 33#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 101 15 61#
         "expl:Ensures clause"
         (forall j_0_0 : Uint64.t.
          ((Uint64.(<) j_0_0 result) ->
           (Int8.(<>)
           (select charP_charM_s_1_5 (shift s_1 (Uint64.to_int j_0_0)))
           (#"strlen.jc" 118 39 50# "expl:Integer cast" (Int8.of_int (0)))))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 102 15 35#
        "expl:Ensures clause"
        (Uint64.(=) (strlen s_1 charP_charM_s_1_5) result))))))))) }
  
end

module Function_valid_str_len_behaviors
#"/home/mikhail/repos/verker/strlen.h" 124 9 31#
"expl:valid_str_len, behaviors"

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_elim_valid_str_len 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let valid_str_len_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 124 9 31#
  "expl:Function valid_str_len, default behavior" =
  fun
   (s_8 : (pointer voidP)) (voidP_s_8_6_alloc_table : (alloc_table voidP))
   (voidP_s_8_6_tag_table : (tag_table voidP)) (charP_charM_s_8_6 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_8_6_alloc_table s_8) ->
     (((=) (typeof voidP_s_8_6_tag_table s_8) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_8_6_alloc_table s_8) i) /\
       ((<) i (offset_max voidP_s_8_6_alloc_table s_8))) ->
       ((=) (typeof voidP_s_8_6_tag_table (shift s_8 i)) charP_tag)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 119 16 28#
   (valid_str s_8 voidP_s_8_6_alloc_table charP_charM_s_8_6))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 120 15 35# "expl:Ensures clause"
     (#"/home/mikhail/repos/verker/strlen.h" 120 15 35# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
      "expl:Ensures clause"
      (Int8.(=)
      (select charP_charM_s_8_6
      (shift s_8 (Uint64.to_int (strlen s_8 charP_charM_s_8_6))))
      (#"strlen.jc" 178 31 42# "expl:Integer cast" (Int8.of_int (0)))))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 120 15 35# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 121 15 39#
      "expl:Ensures clause"
      (if ((<=) (0) (Uint64.to_int (strlen s_8 charP_charM_s_8_6))) then
       (((<=) (offset_min voidP_s_8_6_alloc_table s_8) (0)) /\
       (((>=) (offset_max voidP_s_8_6_alloc_table s_8)
        (Uint64.to_int (strlen s_8 charP_charM_s_8_6)))
       /\
       (forall __framac_tmp4 : int.
        ((((<=) (0) __framac_tmp4) /\
         ((<=) __framac_tmp4 (Uint64.to_int (strlen s_8 charP_charM_s_8_6))))
         -> ((=) true true))))) else ((=) true true)))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 122 15 63# "expl:Ensures clause"
     (forall j_1_0 : Uint64.t.
      ((Uint64.(<) j_1_0 (strlen s_8 charP_charM_s_8_6)) ->
       (Int8.(<>)
       (select charP_charM_s_8_6 (shift s_8 (Uint64.to_int j_1_0)))
       (#"strlen.jc" 193 38 49# "expl:Integer cast" (Int8.of_int (0)))))))))))))
     }  ->
   'Init:
   try
    begin
    (let _jessie_46 =
    (let _jessie_45 = s_8 in
    (#"/home/mikhail/repos/verker/strlen.h" 126 6 27#
    "expl:Precondition for elim_valid_str_len"
    (Function_elim_valid_str_len.elim_valid_str_len  _jessie_45
     voidP_s_8_6_alloc_table voidP_s_8_6_tag_table charP_charM_s_8_6 ))) in
    ()); (raise Return); (raise Return) end with Return -> () end
  
end

module Function_intro_valid_str_len_safety
#"/home/mikhail/repos/verker/strlen.h" 137 10 48#
"expl:intro_valid_str_len, safety"

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let intro_valid_str_len #"/home/mikhail/repos/verker/strlen.h" 137 10 48#
  "expl:Function intro_valid_str_len, safety" =
  fun
   (s_2 : (pointer voidP)) (n : Uint64.t) (voidP_s_2_7_alloc_table :
   (alloc_table voidP)) (charP_charM_s_2_7 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 226 12 1339#
   ((#"strlen.jc" 226 12 1339# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 226 12 1339#
   ((#"/home/mikhail/repos/verker/strlen.h" 131 16 32#
    (if ((<=) (0) (Uint64.to_int n)) then
     (((<=) (offset_min voidP_s_2_7_alloc_table s_2) (0)) /\
     (((>=) (offset_max voidP_s_2_7_alloc_table s_2) (Uint64.to_int n)) /\
     (forall __framac_tmp6 : int.
      ((((<=) (0) __framac_tmp6) /\ ((<=) __framac_tmp6 (Uint64.to_int n)))
       -> ((=) true true))))) else ((=) true true)))
   /\
   (#"strlen.jc" 226 12 1339#
   ((#"/home/mikhail/repos/verker/strlen.h" 132 16 28#
    (Int8.(=) (select charP_charM_s_2_7 (shift s_2 (Uint64.to_int n)))
    (#"strlen.jc" 239 58 69# "expl:Integer cast" (Int8.of_int (0)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 133 16 56#
   (forall j_2 : Uint64.t.
    ((Uint64.(<) j_2 n) ->
     (Int8.(<>) (select charP_charM_s_2_7 (shift s_2 (Uint64.to_int j_2)))
     (#"strlen.jc" 242 65 76# "expl:Integer cast" (Int8.of_int (0)))))))))))))
   } ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    begin
    any unit
    requires { true } reads { s_2 }
    ensures {
      (#"/home/mikhail/repos/verker/strlen.h" 139 18 30#
      (valid_str s_2 voidP_s_2_7_alloc_table charP_charM_s_2_7)) } ; () end;
     (raise Return); (raise Return) end with Return -> () end
  
end

module Function_intro_valid_str_len_behaviors
#"/home/mikhail/repos/verker/strlen.h" 137 10 48#
"expl:intro_valid_str_len, behaviors"

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let intro_valid_str_len_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 137 10 48#
  "expl:Function intro_valid_str_len, default behavior" =
  fun
   (s_2 : (pointer voidP)) (n : Uint64.t) (voidP_s_2_7_alloc_table :
   (alloc_table voidP)) (charP_charM_s_2_7 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 226 12 1339#
   ((#"strlen.jc" 226 12 1339# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 226 12 1339#
   ((#"/home/mikhail/repos/verker/strlen.h" 131 16 32#
    (if ((<=) (0) (Uint64.to_int n)) then
     (((<=) (offset_min voidP_s_2_7_alloc_table s_2) (0)) /\
     (((>=) (offset_max voidP_s_2_7_alloc_table s_2) (Uint64.to_int n)) /\
     (forall __framac_tmp6 : int.
      ((((<=) (0) __framac_tmp6) /\ ((<=) __framac_tmp6 (Uint64.to_int n)))
       -> ((=) true true))))) else ((=) true true)))
   /\
   (#"strlen.jc" 226 12 1339#
   ((#"/home/mikhail/repos/verker/strlen.h" 132 16 28#
    (Int8.(=) (select charP_charM_s_2_7 (shift s_2 (Uint64.to_int n)))
    (#"strlen.jc" 239 58 69# "expl:Integer cast" (Int8.of_int (0)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 133 16 56#
   (forall j_2 : Uint64.t.
    ((Uint64.(<) j_2 n) ->
     (Int8.(<>) (select charP_charM_s_2_7 (shift s_2 (Uint64.to_int j_2)))
     (#"strlen.jc" 242 65 76# "expl:Integer cast" (Int8.of_int (0)))))))))))))
   }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 134 15 27# "expl:Ensures clause"
     (#"/home/mikhail/repos/verker/strlen.h" 134 15 27# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
      "expl:Ensures clause"
      (valid_str s_2 voidP_s_2_7_alloc_table charP_charM_s_2_7))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 135 15 29# "expl:Ensures clause"
     (Uint64.(=) (strlen s_2 charP_charM_s_2_7) n)))))) }  ->
   'Init:
   try
    begin
    begin
    (assert {
    (#"/home/mikhail/repos/verker/strlen.h" 139 18 30#
    "expl:Assertion in line 139"
    (valid_str s_2 voidP_s_2_7_alloc_table charP_charM_s_2_7)) }); () end;
     (raise Return); (raise Return) end with Return -> () end
  
end

module Function_intro_valid_str_len_safe

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  val intro_valid_str_len
  (s_2 : (pointer voidP)) 
   (n : Uint64.t) 
    (voidP_s_2_7_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_2_7 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 226 12 1339# "expl:Requires clause"
        ((#"strlen.jc" 226 12 1339# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 226 12 1339# "expl:Requires clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 131 16 32#
         "expl:Requires clause"
         (if ((<=) (0) (Uint64.to_int n)) then
          (((<=) (offset_min voidP_s_2_7_alloc_table s_2) (0)) /\
          (((>=) (offset_max voidP_s_2_7_alloc_table s_2) (Uint64.to_int n))
          /\
          (forall __framac_tmp6 : int.
           ((((<=) (0) __framac_tmp6) /\
            ((<=) __framac_tmp6 (Uint64.to_int n))) -> ((=) true true)))))
          else ((=) true true)))
        /\
        (#"strlen.jc" 226 12 1339# "expl:Requires clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 132 16 28#
         "expl:Requires clause"
         (Int8.(=) (select charP_charM_s_2_7 (shift s_2 (Uint64.to_int n)))
         (#"strlen.jc" 239 58 69# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 133 16 56#
        "expl:Requires clause"
        (forall j_2 : Uint64.t.
         ((Uint64.(<) j_2 n) ->
          (Int8.(<>)
          (select charP_charM_s_2_7 (shift s_2 (Uint64.to_int j_2)))
          (#"strlen.jc" 242 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))))
        }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
         "expl:Ensures clause"
         (valid_str s_2 voidP_s_2_7_alloc_table charP_charM_s_2_7))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 135 15 29#
        "expl:Ensures clause" (Uint64.(=) (strlen s_2 charP_charM_s_2_7) n)))))
        }
  
end

module Function_valid_str_shiftn_safety
#"/home/mikhail/repos/verker/strlen.h" 147 9 44#
"expl:valid_str_shiftn, safety"

  use enum.Uint64 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use Safe_bit_uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_intro_valid_str_len_safe 
  
  use Function_elim_valid_str_len_safe 
  
  use import Exceptions 
  
  use enum.Bit_uint64 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let valid_str_shiftn #"/home/mikhail/repos/verker/strlen.h" 147 9 44#
  "expl:Function valid_str_shiftn, safety" =
  fun
   (s_9 : (pointer voidP)) (i_1 : Uint64.t) (voidP_s_9_8_alloc_table :
   (alloc_table voidP)) (voidP_s_9_8_tag_table : (tag_table voidP))
   (charP_charM_s_9_8 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_s_9_8_alloc_table s_9) ->
     (((=) (typeof voidP_s_9_8_tag_table s_9) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_9_8_alloc_table s_9) i) /\
       ((<) i (offset_max voidP_s_9_8_alloc_table s_9))) ->
       ((=) (typeof voidP_s_9_8_tag_table (shift s_9 i)) charP_tag)))))
   /\
   (#"strlen.jc" 258 12 229#
   ((#"strlen.jc" 258 12 229# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 258 12 229#
   ((#"/home/mikhail/repos/verker/strlen.h" 144 16 28#
    (valid_str s_9 voidP_s_9_8_alloc_table charP_charM_s_9_8))
   /\
   (#"strlen.jc" 258 12 229#
   ((#"/home/mikhail/repos/verker/strlen.h" 144 32 38#
    (Bit_uint64.(<=) (#"strlen.jc" 260 35 48# "expl:Integer cast"
    (Bit_uint64.of_int_const 0)) i_1))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 144 37 50#
   (Bit_uint64.(<) i_1 (strlen s_9 charP_charM_s_9_8)))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let j_1 = ref (Safe_bit_uint64.any_  () ) in
    (let tmp = ref (Safe_bit_uint64.any_  () ) in
    try
     begin
     (j_1 :=
      (let _jessie_55 =
      (#"strlen.jc" 269 20 33# "expl:Integer cast"
      (Safe_bit_uint64.of_int_const 0)) in
      begin
      (assert {
      (#"/home/mikhail/repos/verker/strlen.h" 153 19 20#
      "expl:Pointer index bounds" true) }); _jessie_55 end));
      'Loop_6:
      loop
      invariant { (#"strlen.jc" 271 6 2649# true) }
        variant { (#"/home/mikhail/repos/verker/strlen.h" 151 23 28#
          (Int.(-) (Bit_uint64.to_int i_1) (Bit_uint64.to_int !j_1))) }
       begin
       any unit
       requires { true } reads { i_1, s_9 }
       ensures {
         ((#"/home/mikhail/repos/verker/strlen.h" 150 25 36#
          (#"/home/mikhail/repos/verker/strlen.h" 150 25 36#
          ((#"/home/mikhail/repos/verker/strlen.h" 150 25 31#
           (Bit_uint64.(<=) (#"strlen.jc" 275 38 51# "expl:Integer cast"
           (Bit_uint64.of_int_const 0)) !j_1))
          /\
          (#"/home/mikhail/repos/verker/strlen.h" 150 30 36#
          (Bit_uint64.(<=) !j_1 i_1)))))
         /\
         (#"/home/mikhail/repos/verker/strlen.h" 149 25 41#
         (valid_str (shift s_9 (Bit_uint64.to_int !j_1))
         voidP_s_9_8_alloc_table charP_charM_s_9_8))) } ;
        try
         begin
         begin
         (if
         (#"/home/mikhail/repos/verker/strlen.h" 153 26 31#
         (Safe_bit_uint64.(<)  !j_1 i_1 )) then ()
         else (raise (Goto_while_0_break_1_exc ())));
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 154 13 31#
          (Safe_int32.(<>) 
           (#"/home/mikhail/repos/verker/strlen.h" 154 13 23#
           "expl:Integer cast"
           (Safe_int32_of_Safe_int8.cast 
            (#"/home/mikhail/repos/verker/strlen.h" 154 13 23#
            "expl:Pointer dereference"
            (acc  voidP_s_9_8_alloc_table charP_charM_s_9_8
             (shift_typesafe  s_9 (Safe_bit_uint64.to_int  !j_1 ) ) )) ))
           (#"strlen.jc" 285 30 42# "expl:Integer cast"
           (Safe_int32.of_int (0))) ))
          then
           begin
           begin
           any unit
           requires { true } reads { s_9 }
           ensures {
             (#"/home/mikhail/repos/verker/strlen.h" 155 22 100#
             (forall k : Uint64.t.
              ((Bit_uint64.(<) k
               (Bit_uint64.(-%)
               (strlen (shift s_9 (Bit_uint64.to_int !j_1))
               charP_charM_s_9_8) (#"strlen.jc" 293 68 81#
               "expl:Integer cast" (Bit_uint64.of_int_const 1)))) ->
               (Int8.(=)
               (select charP_charM_s_9_8
               (shift (shift (shift s_9 (Bit_uint64.to_int !j_1)) (1))
               (Bit_uint64.to_int k)))
               (select charP_charM_s_9_8
               (shift (shift s_9 (Bit_uint64.to_int !j_1))
               (Bit_uint64.to_int
               (Bit_uint64.(+%) k (#"strlen.jc" 301 68 81#
               "expl:Integer cast" (Bit_uint64.of_int_const 1)))))))))) } ;
            () end;
            begin
            (tmp :=
             (let _jessie_56 =
             (let _jessie_57 =
             (shift_typesafe  s_9 (Safe_bit_uint64.to_int  !j_1 ) ) in
             (#"/home/mikhail/repos/verker/strlen.h" 156 42 67#
             "expl:Precondition for elim_valid_str_len"
             (Function_elim_valid_str_len_safe.elim_valid_str_len  _jessie_57
              voidP_s_9_8_alloc_table voidP_s_9_8_tag_table charP_charM_s_9_8
              ))) in
             begin
             (assert {
             (#"/home/mikhail/repos/verker/strlen.h" 156 42 67#
             "expl:Pointer index bounds" true) }); _jessie_56 end)); () end;
            (let _jessie_59 =
            (shift_typesafe 
             (shift_typesafe  s_9 (Safe_bit_uint64.to_int  !j_1 ) )
             (Safe_int32.to_int 
              (#"strlen.jc" 311 58 70# "expl:Integer cast"
              (Safe_int32.of_int (1))) ) ) in
            (let _jessie_58 =
            (Safe_bit_uint64.(-)  !tmp
             (#"strlen.jc" 313 68 81# "expl:Integer cast"
             (Safe_bit_uint64.of_int_const 1)) ) in
            (#"/home/mikhail/repos/verker/strlen.h" 156 11 72#
            "expl:Precondition for intro_valid_str_len"
            (Function_intro_valid_str_len_safe.intro_valid_str_len 
             _jessie_59 _jessie_58 voidP_s_9_8_alloc_table charP_charM_s_9_8
             )))) end else ());
          (j_1 :=
           (let _jessie_60 =
           (Safe_bit_uint64.(+)  !j_1
            (#"strlen.jc" 316 50 63# "expl:Integer cast"
            (Safe_bit_uint64.of_int_const 1)) ) in
           begin
           (assert {
           (#"/home/mikhail/repos/verker/strlen.h" 153 33 36#
           "expl:Pointer index bounds" true) }); _jessie_60 end)) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_11 -> () end end end; (raise (Goto_while_0_break_1_exc ()))
     end with Goto_while_0_break_1_exc _jessie_9 ->
     'While_0_break_1: 'While_0_break_1: begin (); (raise Return) end end));
     (raise Return) end with Return -> () end
  
end

module Function_intro_valid_str_len

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val intro_valid_str_len
  (s_2 : (pointer voidP)) 
   (n : Uint64.t) 
    (voidP_s_2_7_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_2_7 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 134 15 27#
         "expl:Ensures clause"
         (valid_str s_2 voidP_s_2_7_alloc_table charP_charM_s_2_7))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 135 15 29#
        "expl:Ensures clause" (Uint64.(=) (strlen s_2 charP_charM_s_2_7) n)))))
        }
  
end

module Function_valid_str_shiftn_behaviors
#"/home/mikhail/repos/verker/strlen.h" 147 9 44#
"expl:valid_str_shiftn, behaviors"

  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use Unsafe_bit_uint64 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_intro_valid_str_len 
  
  use Function_elim_valid_str_len 
  
  use import Exceptions 
  
  use enum.Bit_uint64 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let valid_str_shiftn_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 147 9 44#
  "expl:Function valid_str_shiftn, default behavior" =
  fun
   (s_9 : (pointer voidP)) (i_1 : Uint64.t) (voidP_s_9_8_alloc_table :
   (alloc_table voidP)) (voidP_s_9_8_tag_table : (tag_table voidP))
   (charP_charM_s_9_8 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_s_9_8_alloc_table s_9) ->
     (((=) (typeof voidP_s_9_8_tag_table s_9) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_9_8_alloc_table s_9) i) /\
       ((<) i (offset_max voidP_s_9_8_alloc_table s_9))) ->
       ((=) (typeof voidP_s_9_8_tag_table (shift s_9 i)) charP_tag)))))
   /\
   (#"strlen.jc" 258 12 229#
   ((#"strlen.jc" 258 12 229# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 258 12 229#
   ((#"/home/mikhail/repos/verker/strlen.h" 144 16 28#
    (valid_str s_9 voidP_s_9_8_alloc_table charP_charM_s_9_8))
   /\
   (#"strlen.jc" 258 12 229#
   ((#"/home/mikhail/repos/verker/strlen.h" 144 32 38#
    (Bit_uint64.(<=) (#"strlen.jc" 260 35 48# "expl:Integer cast"
    (Bit_uint64.of_int_const 0)) i_1))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 144 37 50#
   (Bit_uint64.(<) i_1 (strlen s_9 charP_charM_s_9_8)))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 145 15 31# "expl:Ensures clause"
     (valid_str (shift s_9 (Bit_uint64.to_int i_1)) voidP_s_9_8_alloc_table
     charP_charM_s_9_8))) } diverges  ->
   'Init:
   try
    begin
    (let j_1 = ref (Unsafe_bit_uint64.any_  () ) in
    (let tmp = ref (Unsafe_bit_uint64.any_  () ) in
    try
     begin
     (j_1 :=
      (#"strlen.jc" 269 20 33# "expl:Integer cast"
      (Unsafe_bit_uint64.of_int_const 0)));
      'Loop_5:
      loop
      invariant
        { ((#"/home/mikhail/repos/verker/strlen.h" 149 25 41#
           (valid_str (shift s_9 (Bit_uint64.to_int !j_1))
           voidP_s_9_8_alloc_table charP_charM_s_9_8))
          &&
          (#"/home/mikhail/repos/verker/strlen.h" 150 25 36#
          (#"/home/mikhail/repos/verker/strlen.h" 150 25 36#
          ((#"/home/mikhail/repos/verker/strlen.h" 150 25 31#
           (Bit_uint64.(<=) (#"strlen.jc" 275 38 51# "expl:Integer cast"
           (Bit_uint64.of_int_const 0)) !j_1))
          /\
          (#"/home/mikhail/repos/verker/strlen.h" 150 30 36#
          (Bit_uint64.(<=) !j_1 i_1)))))) } 
       begin
       any unit requires { true } ensures { true } ;
        try
         begin
         begin
         (if
         (#"/home/mikhail/repos/verker/strlen.h" 153 26 31#
         (Unsafe_bit_uint64.(<)  !j_1 i_1 )) then ()
         else (raise (Goto_while_0_break_1_exc ())));
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 154 13 31#
          (Unsafe_int32.(<>) 
           (#"/home/mikhail/repos/verker/strlen.h" 154 13 23#
           "expl:Integer cast"
           (Unsafe_int32_of_Unsafe_int8.cast 
            (acc  charP_charM_s_9_8
             (shift_  (shift_  s_9 (Unsafe_bit_uint64.to_int  !j_1 ) )
              (Unsafe_int32.to_int 
               (#"strlen.jc" 284 59 71# "expl:Integer cast"
               (Unsafe_int32.of_int (0))) ) ) ) ))
           (#"strlen.jc" 285 30 42# "expl:Integer cast"
           (Unsafe_int32.of_int (0))) ))
          then
           begin
           begin
           (assert {
           (#"/home/mikhail/repos/verker/strlen.h" 155 22 100#
           "expl:Assertion in line 155"
           (forall k : Uint64.t.
            ((Bit_uint64.(<) k
             (Bit_uint64.(-%)
             (strlen (shift s_9 (Bit_uint64.to_int !j_1)) charP_charM_s_9_8)
             (#"strlen.jc" 293 68 81# "expl:Integer cast"
             (Bit_uint64.of_int_const 1)))) ->
             (Int8.(=)
             (select charP_charM_s_9_8
             (shift (shift (shift s_9 (Bit_uint64.to_int !j_1)) (1))
             (Bit_uint64.to_int k)))
             (select charP_charM_s_9_8
             (shift (shift s_9 (Bit_uint64.to_int !j_1))
             (Bit_uint64.to_int
             (Bit_uint64.(+%) k (#"strlen.jc" 301 68 81# "expl:Integer cast"
             (Bit_uint64.of_int_const 1)))))))))) }); () end;
            begin
            (tmp :=
             (let _jessie_51 =
             (shift_  s_9 (Unsafe_bit_uint64.to_int  !j_1 ) ) in
             (#"/home/mikhail/repos/verker/strlen.h" 156 42 67#
             "expl:Precondition for elim_valid_str_len"
             (Function_elim_valid_str_len.elim_valid_str_len  _jessie_51
              voidP_s_9_8_alloc_table voidP_s_9_8_tag_table charP_charM_s_9_8
              )))); () end;
            (let _jessie_53 =
            (shift_  (shift_  s_9 (Unsafe_bit_uint64.to_int  !j_1 ) )
             (Unsafe_int32.to_int 
              (#"strlen.jc" 311 58 70# "expl:Integer cast"
              (Unsafe_int32.of_int (1))) ) ) in
            (let _jessie_52 =
            (Unsafe_bit_uint64.(-)  !tmp
             (#"strlen.jc" 313 68 81# "expl:Integer cast"
             (Unsafe_bit_uint64.of_int_const 1)) ) in
            (#"/home/mikhail/repos/verker/strlen.h" 156 11 72#
            "expl:Precondition for intro_valid_str_len"
            (Function_intro_valid_str_len.intro_valid_str_len  _jessie_53
             _jessie_52 voidP_s_9_8_alloc_table charP_charM_s_9_8 )))) end
          else ());
          (j_1 :=
           (Unsafe_bit_uint64.(+)  !j_1
            (#"strlen.jc" 316 50 63# "expl:Integer cast"
            (Unsafe_bit_uint64.of_int_const 1)) )) end;
          (raise (Loop_continue_exc ())) end with Loop_continue_exc
         _jessie_11 -> () end end end; (raise (Goto_while_0_break_1_exc ()))
     end with Goto_while_0_break_1_exc _jessie_9 ->
     'While_0_break_1: 'While_0_break_1: begin (); (raise Return) end end));
     (raise Return) end with Return -> () end
  
end

module Function_valid_str_shiftn_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  val valid_str_shiftn
  (s_9 : (pointer voidP)) 
   (i_1 : Uint64.t) 
    (voidP_s_9_8_alloc_table : (alloc_table voidP)) 
     (voidP_s_9_8_tag_table : (tag_table voidP)) 
      (charP_charM_s_9_8 : (memory voidP Int8.t)) : unit
       requires {
         ("expl:Internal"
         (#"strlen.jc" 258 12 229# "expl:Requires clause"
         ((#"strlen.jc" 258 12 229# "expl:Requires clause"
          (_LF__Predicate__valid_str_len (1)))
         /\
         (#"strlen.jc" 258 12 229# "expl:Requires clause"
         ((#"/home/mikhail/repos/verker/strlen.h" 144 16 28#
          "expl:Requires clause"
          (valid_str s_9 voidP_s_9_8_alloc_table charP_charM_s_9_8))
         /\
         (#"strlen.jc" 258 12 229# "expl:Requires clause"
         ((#"/home/mikhail/repos/verker/strlen.h" 144 32 38#
          "expl:Requires clause"
          (Uint64.(<=) (#"strlen.jc" 260 35 48# "expl:Integer cast"
          (Uint64.of_int (0))) i_1))
         /\
         (#"/home/mikhail/repos/verker/strlen.h" 144 37 50#
         "expl:Requires clause"
         (Uint64.(<) i_1 (strlen s_9 charP_charM_s_9_8)))))))))) }
       ensures {
         (#"/home/mikhail/repos/verker/strlen.h" 145 15 31#
         "expl:Ensures clause"
         (valid_str (shift s_9 (Uint64.to_int i_1)) voidP_s_9_8_alloc_table
         charP_charM_s_9_8)) }
  
end

module Function_valid_str_shiftn_integer_safety
#"/home/mikhail/repos/verker/strlen.h" 167 9 42#
"expl:valid_str_shiftn_integer, safety"

  use enum.Uint64 
  
  use Safe_uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_valid_str_shiftn_safe 
  
  use Function_elim_valid_str_len_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let valid_str_shiftn_integer
  #"/home/mikhail/repos/verker/strlen.h" 167 9 42#
  "expl:Function valid_str_shiftn_integer, safety" =
  fun
   (s_10 : (pointer voidP)) (voidP_s_10_9_alloc_table : (alloc_table voidP))
   (voidP_s_10_9_tag_table : (tag_table voidP)) (charP_charM_s_10_9 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_10_9_alloc_table s_10) ->
     (((=) (typeof voidP_s_10_9_tag_table s_10) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_10_9_alloc_table s_10) i) /\
       ((<) i (offset_max voidP_s_10_9_alloc_table s_10))) ->
       ((=) (typeof voidP_s_10_9_tag_table (shift s_10 i)) charP_tag)))))
   /\
   (#"strlen.jc" 326 12 93#
   ((#"strlen.jc" 326 12 93# (_LF__Predicate__valid_str_len (1))) /\
   (#"/home/mikhail/repos/verker/strlen.h" 164 16 28#
   (valid_str s_10 voidP_s_10_9_alloc_table charP_charM_s_10_9))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let size_2 = ref (Safe_uint64.any_  () ) in
    (let i_4 = ref (Safe_uint64.any_  () ) in
    begin
    (size_2 :=
     (let _jessie_67 =
     (let _jessie_68 = s_10 in
     (#"/home/mikhail/repos/verker/strlen.h" 169 21 42#
     "expl:Precondition for elim_valid_str_len"
     (Function_elim_valid_str_len_safe.elim_valid_str_len  _jessie_68
      voidP_s_10_9_alloc_table voidP_s_10_9_tag_table charP_charM_s_10_9 )))
     in
     begin
     (assert {
     (#"/home/mikhail/repos/verker/strlen.h" 169 21 42#
     "expl:Pointer index bounds" true) }); _jessie_67 end));
     try
      begin
      (i_4 :=
       (let _jessie_69 =
       (#"strlen.jc" 342 25 38# "expl:Integer cast" (Safe_uint64.of_int (0)))
       in
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.h" 174 19 20#
       "expl:Pointer index bounds" true) }); _jessie_69 end));
       'Loop_8:
       loop
       invariant { (#"strlen.jc" 344 9 761# true) }
         variant { (#"/home/mikhail/repos/verker/strlen.h" 172 23 31#
           (Int.(-) (Uint64.to_int !size_2) (Uint64.to_int !i_4))) }
        begin
        any unit
        requires { true } reads { s_10 }
        ensures {
          ((#"/home/mikhail/repos/verker/strlen.h" 171 25 75#
           (forall j_3 : int.
            ((((<=) (0) j_3) /\ ((<) j_3 (Uint64.to_int !i_4))) ->
             (valid_str (shift s_10 j_3) voidP_s_10_9_alloc_table
             charP_charM_s_10_9))))
          /\
          (#"/home/mikhail/repos/verker/strlen.h" 170 25 39#
          (#"/home/mikhail/repos/verker/strlen.h" 170 25 39#
          ((#"/home/mikhail/repos/verker/strlen.h" 170 25 31#
           (Uint64.(<=) (#"strlen.jc" 346 42 55# "expl:Integer cast"
           (Uint64.of_int (0))) !i_4))
          /\
          (#"/home/mikhail/repos/verker/strlen.h" 170 30 39#
          (Uint64.(<=) !i_4 !size_2)))))) } ;
         try
          begin
          begin
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 174 26 34#
          (Safe_uint64.(<)  !i_4 !size_2 )) then ()
          else (raise (Goto_while_0_break_2_exc ())));
           begin
           (let _jessie_71 = s_10 in
           (let _jessie_70 = !i_4 in
           (#"/home/mikhail/repos/verker/strlen.h" 175 9 31#
           "expl:Precondition for valid_str_shiftn"
           (Function_valid_str_shiftn_safe.valid_str_shiftn  _jessie_71
            _jessie_70 voidP_s_10_9_alloc_table voidP_s_10_9_tag_table
            charP_charM_s_10_9 ))));
            (i_4 :=
             (let _jessie_72 =
             (Safe_uint64.(+)  !i_4
              (#"strlen.jc" 358 60 73# "expl:Integer cast"
              (Safe_uint64.of_int (1))) ) in
             begin
             (assert {
             (#"/home/mikhail/repos/verker/strlen.h" 174 36 39#
             "expl:Pointer index bounds" true) }); _jessie_72 end)) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_14 -> () end end end; (raise (Goto_while_0_break_2_exc ()))
      end with Goto_while_0_break_2_exc _jessie_12 ->
      'While_0_break_2: 'While_0_break_2: () end; (raise Return) end));
     (raise Return) end with Return -> () end
  
end

module Function_valid_str_shiftn

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val valid_str_shiftn
  (s_9 : (pointer voidP)) 
   (i_1 : Uint64.t) 
    (voidP_s_9_8_alloc_table : (alloc_table voidP)) 
     (voidP_s_9_8_tag_table : (tag_table voidP)) 
      (charP_charM_s_9_8 : (memory voidP Int8.t)) : unit
       requires { true }
       ensures {
         (#"/home/mikhail/repos/verker/strlen.h" 145 15 31#
         "expl:Ensures clause"
         (valid_str (shift s_9 (Uint64.to_int i_1)) voidP_s_9_8_alloc_table
         charP_charM_s_9_8)) }
  
end

module Function_valid_str_shiftn_integer_behaviors
#"/home/mikhail/repos/verker/strlen.h" 167 9 42#
"expl:valid_str_shiftn_integer, behaviors"

  use Unsafe_uint64 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_valid_str_shiftn 
  
  use Function_elim_valid_str_len 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let valid_str_shiftn_integer_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 167 9 42#
  "expl:Function valid_str_shiftn_integer, default behavior" =
  fun
   (s_10 : (pointer voidP)) (voidP_s_10_9_alloc_table : (alloc_table voidP))
   (voidP_s_10_9_tag_table : (tag_table voidP)) (charP_charM_s_10_9 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_10_9_alloc_table s_10) ->
     (((=) (typeof voidP_s_10_9_tag_table s_10) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_10_9_alloc_table s_10) i) /\
       ((<) i (offset_max voidP_s_10_9_alloc_table s_10))) ->
       ((=) (typeof voidP_s_10_9_tag_table (shift s_10 i)) charP_tag)))))
   /\
   (#"strlen.jc" 326 12 93#
   ((#"strlen.jc" 326 12 93# (_LF__Predicate__valid_str_len (1))) /\
   (#"/home/mikhail/repos/verker/strlen.h" 164 16 28#
   (valid_str s_10 voidP_s_10_9_alloc_table charP_charM_s_10_9))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 165 15 73# "expl:Ensures clause"
     (forall i_0_0 : int.
      ((((<=) (0) i_0_0) /\
       ((<) i_0_0 (Uint64.to_int (strlen s_10 charP_charM_s_10_9)))) ->
       (valid_str (shift s_10 i_0_0) voidP_s_10_9_alloc_table
       charP_charM_s_10_9))))) } diverges  ->
   'Init:
   try
    begin
    (let size_2 = ref (Unsafe_uint64.any_  () ) in
    (let i_4 = ref (Unsafe_uint64.any_  () ) in
    begin
    (size_2 :=
     (let _jessie_62 = s_10 in
     (#"/home/mikhail/repos/verker/strlen.h" 169 21 42#
     "expl:Precondition for elim_valid_str_len"
     (Function_elim_valid_str_len.elim_valid_str_len  _jessie_62
      voidP_s_10_9_alloc_table voidP_s_10_9_tag_table charP_charM_s_10_9 ))));
     try
      begin
      (i_4 :=
       (#"strlen.jc" 342 25 38# "expl:Integer cast"
       (Unsafe_uint64.of_int (0))));
       'Loop_7:
       loop
       invariant
         { ((#"/home/mikhail/repos/verker/strlen.h" 170 25 39#
            (#"/home/mikhail/repos/verker/strlen.h" 170 25 39#
            ((#"/home/mikhail/repos/verker/strlen.h" 170 25 31#
             (Uint64.(<=) (#"strlen.jc" 346 42 55# "expl:Integer cast"
             (Uint64.of_int (0))) !i_4))
            /\
            (#"/home/mikhail/repos/verker/strlen.h" 170 30 39#
            (Uint64.(<=) !i_4 !size_2)))))
           &&
           (#"/home/mikhail/repos/verker/strlen.h" 171 25 75#
           (forall j_3 : int.
            ((((<=) (0) j_3) /\ ((<) j_3 (Uint64.to_int !i_4))) ->
             (valid_str (shift s_10 j_3) voidP_s_10_9_alloc_table
             charP_charM_s_10_9))))) } 
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 174 26 34#
          (Unsafe_uint64.(<)  !i_4 !size_2 )) then ()
          else (raise (Goto_while_0_break_2_exc ())));
           begin
           (let _jessie_65 = s_10 in
           (let _jessie_64 = !i_4 in
           (#"/home/mikhail/repos/verker/strlen.h" 175 9 31#
           "expl:Precondition for valid_str_shiftn"
           (Function_valid_str_shiftn.valid_str_shiftn  _jessie_65 _jessie_64
            voidP_s_10_9_alloc_table voidP_s_10_9_tag_table
            charP_charM_s_10_9 ))));
            (i_4 :=
             (Unsafe_uint64.(+)  !i_4
              (#"strlen.jc" 358 60 73# "expl:Integer cast"
              (Unsafe_uint64.of_int (1))) )) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_14 -> () end end end; (raise (Goto_while_0_break_2_exc ()))
      end with Goto_while_0_break_2_exc _jessie_12 ->
      'While_0_break_2: 'While_0_break_2: () end; (raise Return) end));
     (raise Return) end with Return -> () end
  
end

module Function_elim_strlen_safety
#"/home/mikhail/repos/verker/strlen.h" 184 9 29# "expl:elim_strlen, safety"

  use enum.Uint64 
  
  use Safe_int32_of_Safe_int8 
  
  use Safe_int32 
  
  use Safe_bit_uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_intro_valid_str_len_safe 
  
  use Function_elim_valid_str_len_safe 
  
  use enum.Bit_uint64 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let elim_strlen #"/home/mikhail/repos/verker/strlen.h" 184 9 29#
  "expl:Function elim_strlen, safety" =
  fun
   (s_3 : (pointer voidP)) (voidP_s_10_alloc_table : (alloc_table voidP))
   (voidP_s_10_tag_table : (tag_table voidP)) (charP_charM_s_10 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_10_alloc_table s_3) ->
     (((=) (typeof voidP_s_10_tag_table s_3) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_10_alloc_table s_3) i) /\
       ((<) i (offset_max voidP_s_10_alloc_table s_3))) ->
       ((=) (typeof voidP_s_10_tag_table (shift s_3 i)) charP_tag)))))
   /\
   (#"strlen.jc" 383 12 154#
   ((#"strlen.jc" 383 12 154# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 383 12 154#
   ((#"strlen.jc" 383 12 154# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 180 16 28#
   (valid_str s_3 voidP_s_10_alloc_table charP_charM_s_10))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let tmp_0 = ref (Safe_bit_uint64.any_  () ) in
    begin
    (if
    (#"/home/mikhail/repos/verker/strlen.h" 186 11 23#
    (Safe_int32.(<>) 
     (#"/home/mikhail/repos/verker/strlen.h" 186 11 15# "expl:Integer cast"
     (Safe_int32_of_Safe_int8.cast 
      (#"/home/mikhail/repos/verker/strlen.h" 186 11 15#
      "expl:Pointer dereference"
      (acc  voidP_s_10_alloc_table charP_charM_s_10 s_3 )) ))
     (#"strlen.jc" 397 22 34# "expl:Integer cast" (Safe_int32.of_int (0))) ))
    then
     begin
     begin
     any unit
     requires { true } reads { s_3 }
     ensures {
       (#"/home/mikhail/repos/verker/strlen.h" 187 20 84#
       (forall k_0 : Uint64.t.
        ((Bit_uint64.(<) k_0
         (Bit_uint64.(-%) (strlen s_3 charP_charM_s_10)
         (#"strlen.jc" 404 60 73# "expl:Integer cast"
         (Bit_uint64.of_int_const 1)))) ->
         (Int8.(=)
         (select charP_charM_s_10
         (shift (shift s_3 (1)) (Bit_uint64.to_int k_0)))
         (select charP_charM_s_10
         (shift s_3
         (Bit_uint64.to_int
         (Bit_uint64.(+%) k_0 (#"strlen.jc" 409 64 77# "expl:Integer cast"
         (Bit_uint64.of_int_const 1)))))))))) } ; () end;
      begin
      (tmp_0 :=
       (let _jessie_77 =
       (let _jessie_78 = s_3 in
       (#"/home/mikhail/repos/verker/strlen.h" 188 36 57#
       "expl:Precondition for elim_valid_str_len"
       (Function_elim_valid_str_len_safe.elim_valid_str_len  _jessie_78
        voidP_s_10_alloc_table voidP_s_10_tag_table charP_charM_s_10 ))) in
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.h" 188 36 57#
       "expl:Pointer index bounds" true) }); _jessie_77 end)); () end;
      (let _jessie_80 =
      (shift_typesafe  s_3
       (Safe_int32.to_int 
        (#"strlen.jc" 416 54 66# "expl:Integer cast" (Safe_int32.of_int (1)))
        ) ) in
      (let _jessie_79 =
      (Safe_bit_uint64.(-)  !tmp_0
       (#"strlen.jc" 418 62 75# "expl:Integer cast"
       (Safe_bit_uint64.of_int_const 1)) ) in
      (#"/home/mikhail/repos/verker/strlen.h" 188 9 62#
      "expl:Precondition for intro_valid_str_len"
      (Function_intro_valid_str_len_safe.intro_valid_str_len  _jessie_80
       _jessie_79 voidP_s_10_alloc_table charP_charM_s_10 )))) end else ());
     (raise Return) end); (raise Return) end with Return -> () end
  
end

module Function_elim_strlen_behaviors
#"/home/mikhail/repos/verker/strlen.h" 184 9 29#
"expl:elim_strlen, behaviors"

  use Unsafe_int32_of_Unsafe_int8 
  
  use Unsafe_int32 
  
  use Unsafe_bit_uint64 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_intro_valid_str_len 
  
  use Function_elim_valid_str_len 
  
  use enum.Bit_uint64 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let elim_strlen_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 184 9 29#
  "expl:Function elim_strlen, default behavior" =
  fun
   (s_3 : (pointer voidP)) (voidP_s_10_alloc_table : (alloc_table voidP))
   (voidP_s_10_tag_table : (tag_table voidP)) (charP_charM_s_10 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_10_alloc_table s_3) ->
     (((=) (typeof voidP_s_10_tag_table s_3) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_10_alloc_table s_3) i) /\
       ((<) i (offset_max voidP_s_10_alloc_table s_3))) ->
       ((=) (typeof voidP_s_10_tag_table (shift s_3 i)) charP_tag)))))
   /\
   (#"strlen.jc" 383 12 154#
   ((#"strlen.jc" 383 12 154# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 383 12 154#
   ((#"strlen.jc" 383 12 154# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 180 16 28#
   (valid_str s_3 voidP_s_10_alloc_table charP_charM_s_10))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 181 15 46# "expl:Ensures clause"
     (#"/home/mikhail/repos/verker/strlen.h" 181 15 46# "expl:Ensures clause"
     ((#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
      "expl:Ensures clause"
      ((Int8.(=) (select charP_charM_s_10 (shift s_3 (0)))
       (#"strlen.jc" 387 59 70# "expl:Integer cast" (Int8.of_int (0)))) ->
       (Bit_uint64.(=) (strlen s_3 charP_charM_s_10) (#"strlen.jc" 388 62 75#
       "expl:Integer cast" (Bit_uint64.of_int_const 0)))))
     /\
     (#"/home/mikhail/repos/verker/strlen.h" 182 15 62# "expl:Ensures clause"
     ((Int8.(<>) (select charP_charM_s_10 (shift s_3 (0)))
      (#"strlen.jc" 389 60 71# "expl:Integer cast" (Int8.of_int (0)))) ->
      ((=) (Bit_uint64.to_int (strlen s_3 charP_charM_s_10))
      (Int.(+) (1)
      (Bit_uint64.to_int (strlen (shift s_3 (1)) charP_charM_s_10)))))))))) }
    ->
   'Init:
   try
    begin
    (let tmp_0 = ref (Unsafe_bit_uint64.any_  () ) in
    begin
    (if
    (#"/home/mikhail/repos/verker/strlen.h" 186 11 23#
    (Unsafe_int32.(<>) 
     (#"/home/mikhail/repos/verker/strlen.h" 186 11 15# "expl:Integer cast"
     (Unsafe_int32_of_Unsafe_int8.cast 
      (acc  charP_charM_s_10
       (shift_  s_3
        (Unsafe_int32.to_int 
         (#"strlen.jc" 396 57 69# "expl:Integer cast"
         (Unsafe_int32.of_int (0))) ) ) ) ))
     (#"strlen.jc" 397 22 34# "expl:Integer cast" (Unsafe_int32.of_int (0)))
     ))
    then
     begin
     begin
     (assert {
     (#"/home/mikhail/repos/verker/strlen.h" 187 20 84#
     "expl:Assertion in line 187"
     (forall k_0 : Uint64.t.
      ((Bit_uint64.(<) k_0
       (Bit_uint64.(-%) (strlen s_3 charP_charM_s_10)
       (#"strlen.jc" 404 60 73# "expl:Integer cast" (Bit_uint64.of_int_const
       1)))) ->
       (Int8.(=)
       (select charP_charM_s_10
       (shift (shift s_3 (1)) (Bit_uint64.to_int k_0)))
       (select charP_charM_s_10
       (shift s_3
       (Bit_uint64.to_int
       (Bit_uint64.(+%) k_0 (#"strlen.jc" 409 64 77# "expl:Integer cast"
       (Bit_uint64.of_int_const 1)))))))))) }); () end;
      begin
      (tmp_0 :=
       (let _jessie_74 = s_3 in
       (#"/home/mikhail/repos/verker/strlen.h" 188 36 57#
       "expl:Precondition for elim_valid_str_len"
       (Function_elim_valid_str_len.elim_valid_str_len  _jessie_74
        voidP_s_10_alloc_table voidP_s_10_tag_table charP_charM_s_10 )))); ()
      end;
      (let _jessie_76 =
      (shift_  s_3
       (Unsafe_int32.to_int 
        (#"strlen.jc" 416 54 66# "expl:Integer cast"
        (Unsafe_int32.of_int (1))) ) ) in
      (let _jessie_75 =
      (Unsafe_bit_uint64.(-)  !tmp_0
       (#"strlen.jc" 418 62 75# "expl:Integer cast"
       (Unsafe_bit_uint64.of_int_const 1)) ) in
      (#"/home/mikhail/repos/verker/strlen.h" 188 9 62#
      "expl:Precondition for intro_valid_str_len"
      (Function_intro_valid_str_len.intro_valid_str_len  _jessie_76
       _jessie_75 voidP_s_10_alloc_table charP_charM_s_10 )))) end else ());
     (raise Return) end); (raise Return) end with Return -> () end
  
end

module Function_strlen_before_null_safety
#"/home/mikhail/repos/verker/strlen.h" 198 9 46#
"expl:strlen_before_null, safety"

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let strlen_before_null #"/home/mikhail/repos/verker/strlen.h" 198 9 46#
  "expl:Function strlen_before_null, safety" =
  fun
   (s_5 : (pointer voidP)) (i_0 : Uint64.t) (voidP_s_5_11_alloc_table :
   (alloc_table voidP)) (charP_charM_s_5_11 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 426 12 294#
   ((#"strlen.jc" 426 12 294# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 426 12 294#
   ((#"strlen.jc" 426 12 294# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 426 12 294#
   ((#"/home/mikhail/repos/verker/strlen.h" 194 16 28#
    (valid_str s_5 voidP_s_5_11_alloc_table charP_charM_s_5_11))
   /\
   (#"strlen.jc" 426 12 294#
   ((#"/home/mikhail/repos/verker/strlen.h" 195 16 22#
    (Uint64.(<=) (#"strlen.jc" 429 39 52# "expl:Integer cast" (Uint64.of_int
    (0))) i_0))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 195 21 34#
   (Uint64.(<) i_0 (strlen s_5 charP_charM_s_5_11))))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init: try begin (raise Return); (raise Return) end with Return -> () end
  
end

module Function_strlen_before_null_behaviors
#"/home/mikhail/repos/verker/strlen.h" 198 9 46#
"expl:strlen_before_null, behaviors"

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let strlen_before_null_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 198 9 46#
  "expl:Function strlen_before_null, default behavior" =
  fun
   (s_5 : (pointer voidP)) (i_0 : Uint64.t) (voidP_s_5_11_alloc_table :
   (alloc_table voidP)) (charP_charM_s_5_11 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 426 12 294#
   ((#"strlen.jc" 426 12 294# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 426 12 294#
   ((#"strlen.jc" 426 12 294# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 426 12 294#
   ((#"/home/mikhail/repos/verker/strlen.h" 194 16 28#
    (valid_str s_5 voidP_s_5_11_alloc_table charP_charM_s_5_11))
   /\
   (#"strlen.jc" 426 12 294#
   ((#"/home/mikhail/repos/verker/strlen.h" 195 16 22#
    (Uint64.(<=) (#"strlen.jc" 429 39 52# "expl:Integer cast" (Uint64.of_int
    (0))) i_0))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 195 21 34#
   (Uint64.(<) i_0 (strlen s_5 charP_charM_s_5_11))))))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 196 15 27# "expl:Ensures clause"
     (Int8.(<>) (select charP_charM_s_5_11 (shift s_5 (Uint64.to_int i_0)))
     (#"strlen.jc" 433 22 33# "expl:Integer cast" (Int8.of_int (0)))))) }  ->
   'Init: try begin (raise Return); (raise Return) end with Return -> () end
  
end

module Function_strlen_before_null_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  val strlen_before_null
  (s_5 : (pointer voidP)) 
   (i_0 : Uint64.t) 
    (voidP_s_5_11_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_5_11 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 426 12 294# "expl:Requires clause"
        ((#"strlen.jc" 426 12 294# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 426 12 294# "expl:Requires clause"
        ((#"strlen.jc" 426 12 294# "expl:Requires clause"
         (_LF__Predicate__valid_str_shiftn_integer (1)))
        /\
        (#"strlen.jc" 426 12 294# "expl:Requires clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 194 16 28#
         "expl:Requires clause"
         (valid_str s_5 voidP_s_5_11_alloc_table charP_charM_s_5_11))
        /\
        (#"strlen.jc" 426 12 294# "expl:Requires clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 195 16 22#
         "expl:Requires clause"
         (Uint64.(<=) (#"strlen.jc" 429 39 52# "expl:Integer cast"
         (Uint64.of_int (0))) i_0))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 195 21 34#
        "expl:Requires clause"
        (Uint64.(<) i_0 (strlen s_5 charP_charM_s_5_11)))))))))))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 196 15 27#
        "expl:Ensures clause"
        (Int8.(<>)
        (select charP_charM_s_5_11 (shift s_5 (Uint64.to_int i_0)))
        (#"strlen.jc" 433 22 33# "expl:Integer cast" (Int8.of_int (0))))) }
  
end

module Function_strlen_before_null_integer_safety
#"/home/mikhail/repos/verker/strlen.h" 208 9 44#
"expl:strlen_before_null_integer, safety"

  use enum.Uint64 
  
  use Safe_uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_strlen_before_null_safe 
  
  use Function_elim_valid_str_len_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let strlen_before_null_integer
  #"/home/mikhail/repos/verker/strlen.h" 208 9 44#
  "expl:Function strlen_before_null_integer, safety" =
  fun
   (s_6 : (pointer voidP)) (voidP_s_6_12_alloc_table : (alloc_table voidP))
   (voidP_s_6_12_tag_table : (tag_table voidP)) (charP_charM_s_6_12 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_6_12_alloc_table s_6) ->
     (((=) (typeof voidP_s_6_12_tag_table s_6) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_6_12_alloc_table s_6) i) /\
       ((<) i (offset_max voidP_s_6_12_alloc_table s_6))) ->
       ((=) (typeof voidP_s_6_12_tag_table (shift s_6 i)) charP_tag)))))
   /\
   (#"strlen.jc" 441 12 156#
   ((#"strlen.jc" 441 12 156# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 441 12 156#
   ((#"strlen.jc" 441 12 156# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 205 16 28#
   (valid_str s_6 voidP_s_6_12_alloc_table charP_charM_s_6_12))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   try
    begin
    (let size_3 = ref (Safe_uint64.any_  () ) in
    (let i_5 = ref (Safe_uint64.any_  () ) in
    begin
    (size_3 :=
     (let _jessie_87 =
     (let _jessie_88 = s_6 in
     (#"/home/mikhail/repos/verker/strlen.h" 210 20 41#
     "expl:Precondition for elim_valid_str_len"
     (Function_elim_valid_str_len_safe.elim_valid_str_len  _jessie_88
      voidP_s_6_12_alloc_table voidP_s_6_12_tag_table charP_charM_s_6_12 )))
     in
     begin
     (assert {
     (#"/home/mikhail/repos/verker/strlen.h" 210 20 41#
     "expl:Pointer index bounds" true) }); _jessie_87 end));
     try
      begin
      (i_5 :=
       (let _jessie_89 =
       (#"strlen.jc" 458 26 39# "expl:Integer cast" (Safe_uint64.of_int (0)))
       in
       begin
       (assert {
       (#"/home/mikhail/repos/verker/strlen.h" 215 19 20#
       "expl:Pointer index bounds" true) }); _jessie_89 end));
       'Loop_10:
       loop
       invariant { (#"strlen.jc" 460 9 773# true) }
         variant { (#"/home/mikhail/repos/verker/strlen.h" 213 23 31#
           (Int.(-) (Uint64.to_int !size_3) (Uint64.to_int !i_5))) }
        begin
        any unit
        requires { true } reads { s_6 }
        ensures {
          ((#"/home/mikhail/repos/verker/strlen.h" 212 25 71#
           (forall j_4 : int.
            ((((<=) (0) j_4) /\ ((<) j_4 (Uint64.to_int !i_5))) ->
             (Int8.(<>) (select charP_charM_s_6_12 (shift s_6 j_4))
             (#"strlen.jc" 467 55 66# "expl:Integer cast" (Int8.of_int (0)))))))
          /\
          (#"/home/mikhail/repos/verker/strlen.h" 211 25 39#
          (#"/home/mikhail/repos/verker/strlen.h" 211 25 39#
          ((#"/home/mikhail/repos/verker/strlen.h" 211 25 31#
           (Uint64.(<=) (#"strlen.jc" 462 43 56# "expl:Integer cast"
           (Uint64.of_int (0))) !i_5))
          /\
          (#"/home/mikhail/repos/verker/strlen.h" 211 30 39#
          (Uint64.(<=) !i_5 !size_3)))))) } ;
         try
          begin
          begin
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 215 26 34#
          (Safe_uint64.(<)  !i_5 !size_3 )) then ()
          else (raise (Goto_while_0_break_3_exc ())));
           begin
           (let _jessie_91 = s_6 in
           (let _jessie_90 = !i_5 in
           (#"/home/mikhail/repos/verker/strlen.h" 216 9 33#
           "expl:Precondition for strlen_before_null"
           (Function_strlen_before_null_safe.strlen_before_null  _jessie_91
            _jessie_90 voidP_s_6_12_alloc_table charP_charM_s_6_12 ))));
            (i_5 :=
             (let _jessie_92 =
             (Safe_uint64.(+)  !i_5
              (#"strlen.jc" 474 60 73# "expl:Integer cast"
              (Safe_uint64.of_int (1))) ) in
             begin
             (assert {
             (#"/home/mikhail/repos/verker/strlen.h" 215 36 39#
             "expl:Pointer index bounds" true) }); _jessie_92 end)) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_17 -> () end end end; (raise (Goto_while_0_break_3_exc ()))
      end with Goto_while_0_break_3_exc _jessie_15 ->
      'While_0_break_3: 'While_0_break_3: () end; (raise Return) end));
     (raise Return) end with Return -> () end
  
end

module Function_strlen_before_null

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val strlen_before_null
  (s_5 : (pointer voidP)) 
   (i_0 : Uint64.t) 
    (voidP_s_5_11_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_5_11 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 196 15 27#
        "expl:Ensures clause"
        (Int8.(<>)
        (select charP_charM_s_5_11 (shift s_5 (Uint64.to_int i_0)))
        (#"strlen.jc" 433 22 33# "expl:Integer cast" (Int8.of_int (0))))) }
  
end

module Function_strlen_before_null_integer_behaviors
#"/home/mikhail/repos/verker/strlen.h" 208 9 44#
"expl:strlen_before_null_integer, behaviors"

  use Unsafe_uint64 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_strlen_before_null 
  
  use Function_elim_valid_str_len 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  let strlen_before_null_integer_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 208 9 44#
  "expl:Function strlen_before_null_integer, default behavior" =
  fun
   (s_6 : (pointer voidP)) (voidP_s_6_12_alloc_table : (alloc_table voidP))
   (voidP_s_6_12_tag_table : (tag_table voidP)) (charP_charM_s_6_12 : (memory
   voidP Int8.t)) 
   requires {
   (((allocated voidP_s_6_12_alloc_table s_6) ->
     (((=) (typeof voidP_s_6_12_tag_table s_6) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_s_6_12_alloc_table s_6) i) /\
       ((<) i (offset_max voidP_s_6_12_alloc_table s_6))) ->
       ((=) (typeof voidP_s_6_12_tag_table (shift s_6 i)) charP_tag)))))
   /\
   (#"strlen.jc" 441 12 156#
   ((#"strlen.jc" 441 12 156# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 441 12 156#
   ((#"strlen.jc" 441 12 156# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 205 16 28#
   (valid_str s_6 voidP_s_6_12_alloc_table charP_charM_s_6_12))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 206 15 69# "expl:Ensures clause"
     (forall i_1_0 : int.
      ((((<=) (0) i_1_0) /\
       ((<) i_1_0 (Uint64.to_int (strlen s_6 charP_charM_s_6_12)))) ->
       (Int8.(<>) (select charP_charM_s_6_12 (shift s_6 i_1_0))
       (#"strlen.jc" 450 57 68# "expl:Integer cast" (Int8.of_int (0)))))))) }
   diverges  ->
   'Init:
   try
    begin
    (let size_3 = ref (Unsafe_uint64.any_  () ) in
    (let i_5 = ref (Unsafe_uint64.any_  () ) in
    begin
    (size_3 :=
     (let _jessie_82 = s_6 in
     (#"/home/mikhail/repos/verker/strlen.h" 210 20 41#
     "expl:Precondition for elim_valid_str_len"
     (Function_elim_valid_str_len.elim_valid_str_len  _jessie_82
      voidP_s_6_12_alloc_table voidP_s_6_12_tag_table charP_charM_s_6_12 ))));
     try
      begin
      (i_5 :=
       (#"strlen.jc" 458 26 39# "expl:Integer cast"
       (Unsafe_uint64.of_int (0))));
       'Loop_9:
       loop
       invariant
         { ((#"/home/mikhail/repos/verker/strlen.h" 211 25 39#
            (#"/home/mikhail/repos/verker/strlen.h" 211 25 39#
            ((#"/home/mikhail/repos/verker/strlen.h" 211 25 31#
             (Uint64.(<=) (#"strlen.jc" 462 43 56# "expl:Integer cast"
             (Uint64.of_int (0))) !i_5))
            /\
            (#"/home/mikhail/repos/verker/strlen.h" 211 30 39#
            (Uint64.(<=) !i_5 !size_3)))))
           &&
           (#"/home/mikhail/repos/verker/strlen.h" 212 25 71#
           (forall j_4 : int.
            ((((<=) (0) j_4) /\ ((<) j_4 (Uint64.to_int !i_5))) ->
             (Int8.(<>) (select charP_charM_s_6_12 (shift s_6 j_4))
             (#"strlen.jc" 467 55 66# "expl:Integer cast" (Int8.of_int (0)))))))) }
         
        begin
        any unit requires { true } ensures { true } ;
         try
          begin
          begin
          (if
          (#"/home/mikhail/repos/verker/strlen.h" 215 26 34#
          (Unsafe_uint64.(<)  !i_5 !size_3 )) then ()
          else (raise (Goto_while_0_break_3_exc ())));
           begin
           (let _jessie_85 = s_6 in
           (let _jessie_84 = !i_5 in
           (#"/home/mikhail/repos/verker/strlen.h" 216 9 33#
           "expl:Precondition for strlen_before_null"
           (Function_strlen_before_null.strlen_before_null  _jessie_85
            _jessie_84 voidP_s_6_12_alloc_table charP_charM_s_6_12 ))));
            (i_5 :=
             (Unsafe_uint64.(+)  !i_5
              (#"strlen.jc" 474 60 73# "expl:Integer cast"
              (Unsafe_uint64.of_int (1))) )) end end;
           (raise (Loop_continue_exc ())) end with Loop_continue_exc
          _jessie_17 -> () end end end; (raise (Goto_while_0_break_3_exc ()))
      end with Goto_while_0_break_3_exc _jessie_15 ->
      'While_0_break_3: 'While_0_break_3: () end; (raise Return) end));
     (raise Return) end with Return -> () end
  
end

module Function_strlen_at_null_safety
#"/home/mikhail/repos/verker/strlen.h" 225 9 42#
"expl:strlen_at_null, safety"

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use why3.Bool.Bool 
  
  let strlen_at_null #"/home/mikhail/repos/verker/strlen.h" 225 9 42#
  "expl:Function strlen_at_null, safety" =
  fun
   (s_4 : (pointer voidP)) (i : Uint64.t) (voidP_s_4_13_alloc_table :
   (alloc_table voidP)) (charP_charM_s_4_13 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 501 12 224#
   ((#"strlen.jc" 501 12 224# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 501 12 224#
   ((#"strlen.jc" 501 12 224# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 501 12 224#
   ((#"strlen.jc" 501 12 224#
    (_LF__Predicate__strlen_before_null_integer (1)))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 222 16 28#
   (valid_str s_4 voidP_s_4_13_alloc_table charP_charM_s_4_13)))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init: try begin (raise Return); (raise Return) end with Return -> () end
  
end

module Function_strlen_at_null_behaviors
#"/home/mikhail/repos/verker/strlen.h" 225 9 42#
"expl:strlen_at_null, behaviors"

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use why3.Bool.Bool 
  
  let strlen_at_null_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 225 9 42#
  "expl:Function strlen_at_null, default behavior" =
  fun
   (s_4 : (pointer voidP)) (i : Uint64.t) (voidP_s_4_13_alloc_table :
   (alloc_table voidP)) (charP_charM_s_4_13 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 501 12 224#
   ((#"strlen.jc" 501 12 224# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 501 12 224#
   ((#"strlen.jc" 501 12 224# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 501 12 224#
   ((#"strlen.jc" 501 12 224#
    (_LF__Predicate__strlen_before_null_integer (1)))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 222 16 28#
   (valid_str s_4 voidP_s_4_13_alloc_table charP_charM_s_4_13)))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 223 15 35# "expl:Ensures clause"
     (Int8.(=)
     (select charP_charM_s_4_13
     (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_13))))
     (#"strlen.jc" 509 22 33# "expl:Integer cast" (Int8.of_int (0)))))) }  ->
   'Init: try begin (raise Return); (raise Return) end with Return -> () end
  
end

module Function_strlen_main_safety
#"/home/mikhail/repos/verker/strlen.h" 237 9 39# "expl:strlen_main, safety"

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  let strlen_main #"/home/mikhail/repos/verker/strlen.h" 237 9 39#
  "expl:Function strlen_main, safety" =
  fun
   (s_7 : (pointer voidP)) (n_8 : Uint64.t) (voidP_s_7_14_alloc_table :
   (alloc_table voidP)) (charP_charM_s_7_14 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663#
    (_LF__Predicate__strlen_before_null_integer (1)))
   /\
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663# (_LF__Predicate__strlen_at_null (1))) /\
   (#"strlen.jc" 534 12 663#
   ((#"/home/mikhail/repos/verker/strlen.h" 232 16 28#
    (valid_str s_7 voidP_s_7_14_alloc_table charP_charM_s_7_14))
   /\
   (#"strlen.jc" 534 12 663#
   ((#"/home/mikhail/repos/verker/strlen.h" 233 16 28#
    (Int8.(=) (select charP_charM_s_7_14 (shift s_7 (Uint64.to_int n_8)))
    (#"strlen.jc" 540 34 45# "expl:Integer cast" (Int8.of_int (0)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 234 16 62#
   (forall i_2_0 : int.
    ((((<=) (0) i_2_0) /\ ((<) i_2_0 (Uint64.to_int n_8))) ->
     (Int8.(<>) (select charP_charM_s_7_14 (shift s_7 i_2_0))
     (#"strlen.jc" 544 61 72# "expl:Integer cast" (Int8.of_int (0)))))))))))))))))))
   } ensures { ("expl:Postcondition" true) }  ->
   'Init: try begin (raise Return); (raise Return) end with Return -> () end
  
end

module Function_strlen_main_behaviors
#"/home/mikhail/repos/verker/strlen.h" 237 9 39#
"expl:strlen_main, behaviors"

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  let strlen_main_ensures_default
  #"/home/mikhail/repos/verker/strlen.h" 237 9 39#
  "expl:Function strlen_main, default behavior" =
  fun
   (s_7 : (pointer voidP)) (n_8 : Uint64.t) (voidP_s_7_14_alloc_table :
   (alloc_table voidP)) (charP_charM_s_7_14 : (memory voidP Int8.t)) 
   requires {
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663# (_LF__Predicate__valid_str_len (1))) /\
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663# (_LF__Predicate__valid_str_shiftn_integer (1)))
   /\
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663#
    (_LF__Predicate__strlen_before_null_integer (1)))
   /\
   (#"strlen.jc" 534 12 663#
   ((#"strlen.jc" 534 12 663# (_LF__Predicate__strlen_at_null (1))) /\
   (#"strlen.jc" 534 12 663#
   ((#"/home/mikhail/repos/verker/strlen.h" 232 16 28#
    (valid_str s_7 voidP_s_7_14_alloc_table charP_charM_s_7_14))
   /\
   (#"strlen.jc" 534 12 663#
   ((#"/home/mikhail/repos/verker/strlen.h" 233 16 28#
    (Int8.(=) (select charP_charM_s_7_14 (shift s_7 (Uint64.to_int n_8)))
    (#"strlen.jc" 540 34 45# "expl:Integer cast" (Int8.of_int (0)))))
   /\
   (#"/home/mikhail/repos/verker/strlen.h" 234 16 62#
   (forall i_2_0 : int.
    ((((<=) (0) i_2_0) /\ ((<) i_2_0 (Uint64.to_int n_8))) ->
     (Int8.(<>) (select charP_charM_s_7_14 (shift s_7 i_2_0))
     (#"strlen.jc" 544 61 72# "expl:Integer cast" (Int8.of_int (0)))))))))))))))))))
   }
   ensures {
     ("expl:Postcondition"
     (#"/home/mikhail/repos/verker/strlen.h" 235 16 30# "expl:Ensures clause"
     (Uint64.(=) (strlen s_7 charP_charM_s_7_14) n_8))) }  ->
   'Init: try begin (raise Return); (raise Return) end with Return -> () end
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_valid_str_len

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val valid_str_len
  (s_8 : (pointer voidP)) 
   (voidP_s_8_6_alloc_table : (alloc_table voidP)) 
    (voidP_s_8_6_tag_table : (tag_table voidP)) 
     (charP_charM_s_8_6 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_8_6
         (shift s_8 (Uint64.to_int (strlen s_8 charP_charM_s_8_6))))
         (#"strlen.jc" 178 31 42# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 121 15 39#
         "expl:Ensures clause"
         (if ((<=) (0) (Uint64.to_int (strlen s_8 charP_charM_s_8_6))) then
          (((<=) (offset_min voidP_s_8_6_alloc_table s_8) (0)) /\
          (((>=) (offset_max voidP_s_8_6_alloc_table s_8)
           (Uint64.to_int (strlen s_8 charP_charM_s_8_6)))
          /\
          (forall __framac_tmp4 : int.
           ((((<=) (0) __framac_tmp4) /\
            ((<=) __framac_tmp4
            (Uint64.to_int (strlen s_8 charP_charM_s_8_6)))) ->
            ((=) true true))))) else ((=) true true)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 122 15 63#
        "expl:Ensures clause"
        (forall j_1_0 : Uint64.t.
         ((Uint64.(<) j_1_0 (strlen s_8 charP_charM_s_8_6)) ->
          (Int8.(<>)
          (select charP_charM_s_8_6 (shift s_8 (Uint64.to_int j_1_0)))
          (#"strlen.jc" 193 38 49# "expl:Integer cast" (Int8.of_int (0))))))))))))
        }
  
end

module Function_valid_str_len_safe

  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val valid_str_len
  (s_8 : (pointer voidP)) 
   (voidP_s_8_6_alloc_table : (alloc_table voidP)) 
    (voidP_s_8_6_tag_table : (tag_table voidP)) 
     (charP_charM_s_8_6 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"/home/mikhail/repos/verker/strlen.h" 119 16 28#
        "expl:Requires clause"
        (valid_str s_8 voidP_s_8_6_alloc_table charP_charM_s_8_6))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_8_6
         (shift s_8 (Uint64.to_int (strlen s_8 charP_charM_s_8_6))))
         (#"strlen.jc" 178 31 42# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 120 15 35#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 121 15 39#
         "expl:Ensures clause"
         (if ((<=) (0) (Uint64.to_int (strlen s_8 charP_charM_s_8_6))) then
          (((<=) (offset_min voidP_s_8_6_alloc_table s_8) (0)) /\
          (((>=) (offset_max voidP_s_8_6_alloc_table s_8)
           (Uint64.to_int (strlen s_8 charP_charM_s_8_6)))
          /\
          (forall __framac_tmp4 : int.
           ((((<=) (0) __framac_tmp4) /\
            ((<=) __framac_tmp4
            (Uint64.to_int (strlen s_8 charP_charM_s_8_6)))) ->
            ((=) true true))))) else ((=) true true)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 122 15 63#
        "expl:Ensures clause"
        (forall j_1_0 : Uint64.t.
         ((Uint64.(<) j_1_0 (strlen s_8 charP_charM_s_8_6)) ->
          (Int8.(<>)
          (select charP_charM_s_8_6 (shift s_8 (Uint64.to_int j_1_0)))
          (#"strlen.jc" 193 38 49# "expl:Integer cast" (Int8.of_int (0))))))))))))
        }
  
end

module Function_valid_str_shiftn_integer

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val valid_str_shiftn_integer
  (s_10 : (pointer voidP)) 
   (voidP_s_10_9_alloc_table : (alloc_table voidP)) 
    (voidP_s_10_9_tag_table : (tag_table voidP)) 
     (charP_charM_s_10_9 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 165 15 73#
        "expl:Ensures clause"
        (forall i_0_0 : int.
         ((((<=) (0) i_0_0) /\
          ((<) i_0_0 (Uint64.to_int (strlen s_10 charP_charM_s_10_9)))) ->
          (valid_str (shift s_10 i_0_0) voidP_s_10_9_alloc_table
          charP_charM_s_10_9)))) }
  
end

module Function_valid_str_shiftn_integer_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  val valid_str_shiftn_integer
  (s_10 : (pointer voidP)) 
   (voidP_s_10_9_alloc_table : (alloc_table voidP)) 
    (voidP_s_10_9_tag_table : (tag_table voidP)) 
     (charP_charM_s_10_9 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 326 12 93# "expl:Requires clause"
        ((#"strlen.jc" 326 12 93# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 164 16 28#
        "expl:Requires clause"
        (valid_str s_10 voidP_s_10_9_alloc_table charP_charM_s_10_9))))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 165 15 73#
        "expl:Ensures clause"
        (forall i_0_0 : int.
         ((((<=) (0) i_0_0) /\
          ((<) i_0_0 (Uint64.to_int (strlen s_10 charP_charM_s_10_9)))) ->
          (valid_str (shift s_10 i_0_0) voidP_s_10_9_alloc_table
          charP_charM_s_10_9)))) }
  
end

module Function_elim_strlen

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val elim_strlen
  (s_3 : (pointer voidP)) 
   (voidP_s_10_alloc_table : (alloc_table voidP)) 
    (voidP_s_10_tag_table : (tag_table voidP)) 
     (charP_charM_s_10 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
         "expl:Ensures clause"
         ((Int8.(=) (select charP_charM_s_10 (shift s_3 (0)))
          (#"strlen.jc" 387 59 70# "expl:Integer cast" (Int8.of_int (0)))) ->
          (Uint64.(=) (strlen s_3 charP_charM_s_10) (#"strlen.jc" 388 62 75#
          "expl:Integer cast" (Uint64.of_int (0))))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 182 15 62#
        "expl:Ensures clause"
        ((Int8.(<>) (select charP_charM_s_10 (shift s_3 (0)))
         (#"strlen.jc" 389 60 71# "expl:Integer cast" (Int8.of_int (0)))) ->
         ((=) (Uint64.to_int (strlen s_3 charP_charM_s_10))
         (Int.(+) (1)
         (Uint64.to_int (strlen (shift s_3 (1)) charP_charM_s_10))))))))) }
  
end

module Function_elim_strlen_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  val elim_strlen
  (s_3 : (pointer voidP)) 
   (voidP_s_10_alloc_table : (alloc_table voidP)) 
    (voidP_s_10_tag_table : (tag_table voidP)) 
     (charP_charM_s_10 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 383 12 154# "expl:Requires clause"
        ((#"strlen.jc" 383 12 154# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 383 12 154# "expl:Requires clause"
        ((#"strlen.jc" 383 12 154# "expl:Requires clause"
         (_LF__Predicate__valid_str_shiftn_integer (1)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 180 16 28#
        "expl:Requires clause"
        (valid_str s_3 voidP_s_10_alloc_table charP_charM_s_10))))))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 181 15 46#
         "expl:Ensures clause"
         ((Int8.(=) (select charP_charM_s_10 (shift s_3 (0)))
          (#"strlen.jc" 387 59 70# "expl:Integer cast" (Int8.of_int (0)))) ->
          (Uint64.(=) (strlen s_3 charP_charM_s_10) (#"strlen.jc" 388 62 75#
          "expl:Integer cast" (Uint64.of_int (0))))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 182 15 62#
        "expl:Ensures clause"
        ((Int8.(<>) (select charP_charM_s_10 (shift s_3 (0)))
         (#"strlen.jc" 389 60 71# "expl:Integer cast" (Int8.of_int (0)))) ->
         ((=) (Uint64.to_int (strlen s_3 charP_charM_s_10))
         (Int.(+) (1)
         (Uint64.to_int (strlen (shift s_3 (1)) charP_charM_s_10))))))))) }
  
end

module Function_strlen_before_null_integer

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_before_null_integer
  (s_6 : (pointer voidP)) 
   (voidP_s_6_12_alloc_table : (alloc_table voidP)) 
    (voidP_s_6_12_tag_table : (tag_table voidP)) 
     (charP_charM_s_6_12 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 206 15 69#
        "expl:Ensures clause"
        (forall i_1_0 : int.
         ((((<=) (0) i_1_0) /\
          ((<) i_1_0 (Uint64.to_int (strlen s_6 charP_charM_s_6_12)))) ->
          (Int8.(<>) (select charP_charM_s_6_12 (shift s_6 i_1_0))
          (#"strlen.jc" 450 57 68# "expl:Integer cast" (Int8.of_int (0)))))))
        }
  
end

module Function_strlen_before_null_integer_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use why3.Bool.Bool 
  
  val strlen_before_null_integer
  (s_6 : (pointer voidP)) 
   (voidP_s_6_12_alloc_table : (alloc_table voidP)) 
    (voidP_s_6_12_tag_table : (tag_table voidP)) 
     (charP_charM_s_6_12 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 441 12 156# "expl:Requires clause"
        ((#"strlen.jc" 441 12 156# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 441 12 156# "expl:Requires clause"
        ((#"strlen.jc" 441 12 156# "expl:Requires clause"
         (_LF__Predicate__valid_str_shiftn_integer (1)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 205 16 28#
        "expl:Requires clause"
        (valid_str s_6 voidP_s_6_12_alloc_table charP_charM_s_6_12))))))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 206 15 69#
        "expl:Ensures clause"
        (forall i_1_0 : int.
         ((((<=) (0) i_1_0) /\
          ((<) i_1_0 (Uint64.to_int (strlen s_6 charP_charM_s_6_12)))) ->
          (Int8.(<>) (select charP_charM_s_6_12 (shift s_6 i_1_0))
          (#"strlen.jc" 450 57 68# "expl:Integer cast" (Int8.of_int (0)))))))
        }
  
end

module Function_strlen_at_null

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_at_null
  (s_4 : (pointer voidP)) 
   (i : Uint64.t) 
    (voidP_s_4_13_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_4_13 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 223 15 35#
        "expl:Ensures clause"
        (Int8.(=)
        (select charP_charM_s_4_13
        (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_13))))
        (#"strlen.jc" 509 22 33# "expl:Integer cast" (Int8.of_int (0))))) }
  
end

module Function_strlen_at_null_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use why3.Bool.Bool 
  
  val strlen_at_null
  (s_4 : (pointer voidP)) 
   (i : Uint64.t) 
    (voidP_s_4_13_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_4_13 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 501 12 224# "expl:Requires clause"
        ((#"strlen.jc" 501 12 224# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 501 12 224# "expl:Requires clause"
        ((#"strlen.jc" 501 12 224# "expl:Requires clause"
         (_LF__Predicate__valid_str_shiftn_integer (1)))
        /\
        (#"strlen.jc" 501 12 224# "expl:Requires clause"
        ((#"strlen.jc" 501 12 224# "expl:Requires clause"
         (_LF__Predicate__strlen_before_null_integer (1)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 222 16 28#
        "expl:Requires clause"
        (valid_str s_4 voidP_s_4_13_alloc_table charP_charM_s_4_13))))))))) }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 223 15 35#
        "expl:Ensures clause"
        (Int8.(=)
        (select charP_charM_s_4_13
        (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_13))))
        (#"strlen.jc" 509 22 33# "expl:Integer cast" (Int8.of_int (0))))) }
  
end

module Function_strlen_main

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_main
  (s_7 : (pointer voidP)) 
   (n_8 : Uint64.t) 
    (voidP_s_7_14_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_7_14 : (memory voidP Int8.t)) : unit
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 235 16 30#
        "expl:Ensures clause"
        (Uint64.(=) (strlen s_7 charP_charM_s_7_14) n_8)) }
  
end

module Function_strlen_main_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  val strlen_main
  (s_7 : (pointer voidP)) 
   (n_8 : Uint64.t) 
    (voidP_s_7_14_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_7_14 : (memory voidP Int8.t)) : unit
      requires {
        ("expl:Internal"
        (#"strlen.jc" 534 12 663# "expl:Requires clause"
        ((#"strlen.jc" 534 12 663# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 534 12 663# "expl:Requires clause"
        ((#"strlen.jc" 534 12 663# "expl:Requires clause"
         (_LF__Predicate__valid_str_shiftn_integer (1)))
        /\
        (#"strlen.jc" 534 12 663# "expl:Requires clause"
        ((#"strlen.jc" 534 12 663# "expl:Requires clause"
         (_LF__Predicate__strlen_before_null_integer (1)))
        /\
        (#"strlen.jc" 534 12 663# "expl:Requires clause"
        ((#"strlen.jc" 534 12 663# "expl:Requires clause"
         (_LF__Predicate__strlen_at_null (1)))
        /\
        (#"strlen.jc" 534 12 663# "expl:Requires clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 232 16 28#
         "expl:Requires clause"
         (valid_str s_7 voidP_s_7_14_alloc_table charP_charM_s_7_14))
        /\
        (#"strlen.jc" 534 12 663# "expl:Requires clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 233 16 28#
         "expl:Requires clause"
         (Int8.(=)
         (select charP_charM_s_7_14 (shift s_7 (Uint64.to_int n_8)))
         (#"strlen.jc" 540 34 45# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 234 16 62#
        "expl:Requires clause"
        (forall i_2_0 : int.
         ((((<=) (0) i_2_0) /\ ((<) i_2_0 (Uint64.to_int n_8))) ->
          (Int8.(<>) (select charP_charM_s_7_14 (shift s_7 i_2_0))
          (#"strlen.jc" 544 61 72# "expl:Integer cast" (Int8.of_int (0))))))))))))))))))))
        }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 235 16 30#
        "expl:Ensures clause"
        (Uint64.(=) (strlen s_7 charP_charM_s_7_14) n_8)) }
  
end

module Function_strlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_3_0 : (pointer voidP)) 
   (voidP_s_3_15_alloc_table : (alloc_table voidP)) 
    (voidP_s_3_15_tag_table : (tag_table voidP)) 
     (charP_charM_s_3_15 : (memory voidP Int8.t)) : Uint64.t
      requires { true }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
         "expl:Ensures clause"
         (Uint64.(=) result (strlen s_3_0 charP_charM_s_3_15)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 245 12 30#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_3_15 (shift s_3_0 (Uint64.to_int result)))
         (#"strlen.jc" 587 35 46# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 246 12 64#
        "expl:Ensures clause"
        (forall i_3_0 : int.
         ((((<=) (0) i_3_0) /\ ((<) i_3_0 (Uint64.to_int result))) ->
          (Int8.(<>) (select charP_charM_s_3_15 (shift s_3_0 i_3_0))
          (#"strlen.jc" 592 40 51# "expl:Integer cast" (Int8.of_int (0))))))))))))
        }
  
end

module Function_strlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_LF__Axiomatic__valid_str_shiftn_integer 
  
  use import Axiomatic_LF__Axiomatic__valid_str_len 
  
  use import Axiomatic_LF__Axiomatic__strlen_main 
  
  use import Axiomatic_LF__Axiomatic__strlen_before_null_integer 
  
  use import Axiomatic_LF__Axiomatic__strlen_at_null 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_3_0 : (pointer voidP)) 
   (voidP_s_3_15_alloc_table : (alloc_table voidP)) 
    (voidP_s_3_15_tag_table : (tag_table voidP)) 
     (charP_charM_s_3_15 : (memory voidP Int8.t)) : Uint64.t
      requires {
        ("expl:Internal"
        (#"strlen.jc" 577 12 339# "expl:Requires clause"
        ((#"strlen.jc" 577 12 339# "expl:Requires clause"
         (_LF__Predicate__valid_str_len (1)))
        /\
        (#"strlen.jc" 577 12 339# "expl:Requires clause"
        ((#"strlen.jc" 577 12 339# "expl:Requires clause"
         (_LF__Predicate__valid_str_shiftn_integer (1)))
        /\
        (#"strlen.jc" 577 12 339# "expl:Requires clause"
        ((#"strlen.jc" 577 12 339# "expl:Requires clause"
         (_LF__Predicate__strlen_before_null_integer (1)))
        /\
        (#"strlen.jc" 577 12 339# "expl:Requires clause"
        ((#"strlen.jc" 577 12 339# "expl:Requires clause"
         (_LF__Predicate__strlen_at_null (1)))
        /\
        (#"strlen.jc" 577 12 339# "expl:Requires clause"
        ((#"strlen.jc" 577 12 339# "expl:Requires clause"
         (_LF__Predicate__strlen_main (1)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 242 13 25#
        "expl:Requires clause"
        (valid_str s_3_0 voidP_s_3_15_alloc_table charP_charM_s_3_15)))))))))))))
        }
      ensures {
        (#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
        "expl:Ensures clause"
        (#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
         "expl:Ensures clause"
         (Uint64.(=) result (strlen s_3_0 charP_charM_s_3_15)))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 244 12 32#
        "expl:Ensures clause"
        ((#"/home/mikhail/repos/verker/strlen.h" 245 12 30#
         "expl:Ensures clause"
         (Int8.(=)
         (select charP_charM_s_3_15 (shift s_3_0 (Uint64.to_int result)))
         (#"strlen.jc" 587 35 46# "expl:Integer cast" (Int8.of_int (0)))))
        /\
        (#"/home/mikhail/repos/verker/strlen.h" 246 12 64#
        "expl:Ensures clause"
        (forall i_3_0 : int.
         ((((<=) (0) i_3_0) /\ ((<) i_3_0 (Uint64.to_int result))) ->
          (Int8.(<>) (select charP_charM_s_3_15 (shift s_3_0 i_3_0))
          (#"strlen.jc" 592 40 51# "expl:Integer cast" (Int8.of_int (0))))))))))))
        }
  
end
