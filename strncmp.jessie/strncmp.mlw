
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Strlen

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate valid_str (s : (pointer voidP)) (voidP_s_2_alloc_table_at_L :
  (alloc_table voidP)) (charP_charM_s_2_at_L : (memory voidP Int8.t))
  =
     (exists n_1 : Uint64.t.
      ((Int8.(=) (select charP_charM_s_2_at_L (shift s (Uint64.to_int n_1)))
       (#"strncmp.jc" 21 42 53# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (if ((<=) (0) (Uint64.to_int n_1)) then
       (((<=) (offset_min voidP_s_2_alloc_table_at_L s) (0)) /\
       (((>=) (offset_max voidP_s_2_alloc_table_at_L s) (Uint64.to_int n_1))
       /\
       (forall __framac_tmp1 : int.
        ((((<=) (0) __framac_tmp1) /\
         ((<=) __framac_tmp1 (Uint64.to_int n_1))) -> ((=) true true)))))
       else ((=) true true))))
  
  
  lemma Valid_str_shift1 #"/home/work/workdir/verker/strlen.h" 12 7 102#
  "expl:Lemma valid_str_shift1" :
  (forall voidP_s_0_10_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_0_10_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 12 7 102#
    (forall s_0_1 : (pointer voidP).
     (((Int8.(<>) (select charP_charM_s_0_10_at_L s_0_1)
       (#"strncmp.jc" 35 28 39# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (valid_str s_0_1 voidP_s_0_10_alloc_table_at_L charP_charM_s_0_10_at_L))
      ->
      (valid_str (shift s_0_1 (1)) voidP_s_0_10_alloc_table_at_L
      charP_charM_s_0_10_at_L))))))
  
  lemma Valid_str_strend #"/home/work/workdir/verker/strlen.h" 18 7 87#
  "expl:Lemma valid_str_strend" :
  (forall voidP_s_1_11_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_1_11_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 18 7 87#
    (forall s_1 : (pointer voidP).
     (((((<=) (offset_min voidP_s_1_11_alloc_table_at_L s_1) (0)) /\
       (((>=) (offset_max voidP_s_1_11_alloc_table_at_L s_1) (0)) /\
       ((=) true true)))
      /\
      (Int8.(=) (select charP_charM_s_1_11_at_L s_1) (#"strncmp.jc" 43 29 40#
      "expl:Integer cast" (Int8.of_int (0))))) ->
      (valid_str s_1 voidP_s_1_11_alloc_table_at_L charP_charM_s_1_11_at_L))))))
  
  function strlen (s_2 : (pointer voidP)) (charP_charM_s_2_3_at_L : (memory
  voidP Int8.t)) : Uint64.t
  =
     (if
      (Int8.(=) (select charP_charM_s_2_3_at_L (shift s_2 (0)))
      (#"strncmp.jc" 47 30 41# "expl:Integer cast" (Int8.of_int (0)))) then
      (#"strncmp.jc" 47 48 61# "expl:Integer cast" (Uint64.of_int (0))) else
      (#"strncmp.jc" 47 67 255# "expl:Integer cast"
      (Uint64.of_int
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_2 (1)) charP_charM_s_2_3_at_L))))))
  
  
  lemma Strlen_before_null #"/home/work/workdir/verker/strlen.h" 26 7 106#
  "expl:Lemma strlen_before_null" :
  (forall voidP_s_3_12_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_3_12_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 26 7 106#
    (forall s_3 : (pointer voidP).
     (forall i : int.
      (((valid_str s_3 voidP_s_3_12_alloc_table_at_L charP_charM_s_3_12_at_L)
       /\
       (((<=) (0) i) /\
       ((<) i (Uint64.to_int (strlen s_3 charP_charM_s_3_12_at_L))))) ->
       (Int8.(<>) (select charP_charM_s_3_12_at_L (shift s_3 i))
       (#"strncmp.jc" 56 36 47# "expl:Integer cast" (Int8.of_int (0))))))))))
  
  lemma Strlen_at_null #"/home/work/workdir/verker/strlen.h" 31 7 71#
  "expl:Lemma strlen_at_null" :
  (forall voidP_s_4_13_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_4_13_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 31 7 71#
    (forall s_4 : (pointer voidP).
     ((valid_str s_4 voidP_s_4_13_alloc_table_at_L charP_charM_s_4_13_at_L)
      ->
      (Int8.(=)
      (select charP_charM_s_4_13_at_L
      (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_13_at_L))))
      (#"strncmp.jc" 61 60 71# "expl:Integer cast" (Int8.of_int (0)))))))))
  
  lemma Strlen_shift #"/home/work/workdir/verker/strlen.h" 35 7 125#
  "expl:Lemma strlen_shift" :
  (forall voidP_s_5_14_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_5_14_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 35 7 125#
    (forall s_5 : (pointer voidP).
     (forall i_0 : Uint64.t.
      (((valid_str s_5 voidP_s_5_14_alloc_table_at_L charP_charM_s_5_14_at_L)
       /\ (Uint64.(<=) i_0 (strlen s_5 charP_charM_s_5_14_at_L))) ->
       ((=)
       (Uint64.to_int
       (strlen (shift s_5 (Uint64.to_int i_0)) charP_charM_s_5_14_at_L))
       (Int.(-) (Uint64.to_int (strlen s_5 charP_charM_s_5_14_at_L))
       (Uint64.to_int i_0)))))))))
  
  lemma Strlen_shift_ex #"/home/work/workdir/verker/strlen.h" 41 7 126#
  "expl:Lemma strlen_shift_ex" :
  (forall voidP_s_6_15_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_6_15_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 41 7 126#
    (forall s_6 : (pointer voidP).
     (forall i_1 : Uint64.t.
      (((valid_str s_6 voidP_s_6_15_alloc_table_at_L charP_charM_s_6_15_at_L)
       /\
       ((Uint64.(<) (#"strncmp.jc" 73 39 52# "expl:Integer cast"
        (Uint64.of_int (0))) i_1)
       /\ (Uint64.(<=) i_1 (strlen s_6 charP_charM_s_6_15_at_L)))) ->
       (Uint64.(<)
       (strlen (shift s_6 (Uint64.to_int i_1)) charP_charM_s_6_15_at_L)
       (strlen s_6 charP_charM_s_6_15_at_L))))))))
  
  lemma Strlen_shift1 #"/home/work/workdir/verker/strlen.h" 47 7 103#
  "expl:Lemma strlen_shift1" :
  (forall voidP_s_7_16_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_7_16_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 47 7 103#
    (forall s_7 : (pointer voidP).
     (((valid_str s_7 voidP_s_7_16_alloc_table_at_L charP_charM_s_7_16_at_L)
      /\
      (Int8.(<>) (select charP_charM_s_7_16_at_L s_7)
      (#"strncmp.jc" 79 49 60# "expl:Integer cast" (Int8.of_int (0))))) ->
      ((=) (Uint64.to_int (strlen s_7 charP_charM_s_7_16_at_L))
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_7 (1)) charP_charM_s_7_16_at_L)))))))))
  
  lemma Strlen_pointers #"/home/work/workdir/verker/strlen.h" 52 7 254#
  "expl:Lemma strlen_pointers" :
  (forall voidP_s_8_17_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_8_17_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 52 7 254#
    (forall s_8 : (pointer voidP).
     (forall sc : (pointer voidP).
      (((valid_str s_8 voidP_s_8_17_alloc_table_at_L charP_charM_s_8_17_at_L)
       /\
       ((valid_str sc voidP_s_8_17_alloc_table_at_L charP_charM_s_8_17_at_L)
       /\
       ((same_block s_8 sc) /\
       ((same_block s_8 sc) /\
       (((<=) (sub_pointer s_8 sc) (0)) /\
       (forall i_2 : int.
        ((((<=) (0) i_2) /\ ((<=) i_2 (sub_pointer sc s_8))) ->
         (Int8.(<>) (select charP_charM_s_8_17_at_L (shift s_8 i_2))
         (#"strncmp.jc" 92 43 54# "expl:Integer cast" (Int8.of_int (0)))))))))))
       ->
       (Uint64.(<=) (strlen sc charP_charM_s_8_17_at_L)
       (strlen s_8 charP_charM_s_8_17_at_L))))))))
  
  lemma Strlen_main #"/home/work/workdir/verker/strlen.h" 61 7 165#
  "expl:Lemma strlen_main" :
  (forall voidP_s_9_19_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_9_19_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 61 7 165#
    (forall s_9 : (pointer voidP).
     (forall n_2 : Uint64.t.
      (((valid_str s_9 voidP_s_9_19_alloc_table_at_L charP_charM_s_9_19_at_L)
       /\
       ((Int8.(=)
        (select charP_charM_s_9_19_at_L (shift s_9 (Uint64.to_int n_2)))
        (#"strncmp.jc" 99 53 64# "expl:Integer cast" (Int8.of_int (0))))
       /\
       (forall i_3 : int.
        ((((<=) (0) i_3) /\ ((<) i_3 (Uint64.to_int n_2))) ->
         (Int8.(<>) (select charP_charM_s_9_19_at_L (shift s_9 i_3))
         (#"strncmp.jc" 102 43 54# "expl:Integer cast" (Int8.of_int (0))))))))
       -> (Uint64.(=) (strlen s_9 charP_charM_s_9_19_at_L) n_2)))))))
  
  lemma Valid_str_shiftn #"/home/work/workdir/verker/strlen.h" 68 7 123#
  "expl:Lemma valid_str_shiftn" :
  (forall voidP_s_10_20_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_10_20_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strlen.h" 68 7 123#
    (forall s_10 : (pointer voidP).
     (forall i_4 : int.
      (((valid_str s_10 voidP_s_10_20_alloc_table_at_L
        charP_charM_s_10_20_at_L)
       /\
       (((<=) (0) i_4) /\
       ((<) i_4 (Uint64.to_int (strlen s_10 charP_charM_s_10_20_at_L))))) ->
       (valid_str (shift s_10 i_4) voidP_s_10_20_alloc_table_at_L
       charP_charM_s_10_20_at_L)))))))
  
end

theory Axiomatic_Strnlen

  use enum.Uint64 
  
  use int.MinMax 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use bool.Bool 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  predicate valid_strn (s_11 : (pointer voidP)) (cnt : Uint64.t)
  (voidP_s_11_5_alloc_table_at_L : (alloc_table voidP))
  (charP_charM_s_11_5_at_L : (memory voidP Int8.t))
  =
     ((exists n_3 : Uint64.t.
       ((Uint64.(<) n_3 cnt) /\
       ((Int8.(=)
        (select charP_charM_s_11_5_at_L (shift s_11 (Uint64.to_int n_3)))
        (#"strncmp.jc" 131 62 73# "expl:Integer cast" (Int8.of_int (0))))
       /\
       (if ((<=) (0) (Uint64.to_int n_3)) then
        (((<=) (offset_min voidP_s_11_5_alloc_table_at_L s_11) (0)) /\
        (((>=) (offset_max voidP_s_11_5_alloc_table_at_L s_11)
         (Uint64.to_int n_3))
        /\
        (forall __framac_tmp4 : int.
         ((((<=) (0) __framac_tmp4) /\
          ((<=) __framac_tmp4 (Uint64.to_int n_3))) -> ((=) true true)))))
        else ((=) true true)))))
     \/
     (if ((<=) (0) (Uint64.to_int cnt)) then
      (((<=) (offset_min voidP_s_11_5_alloc_table_at_L s_11) (0)) /\
      (((>=) (offset_max voidP_s_11_5_alloc_table_at_L s_11)
       (Uint64.to_int cnt))
      /\
      (forall __framac_tmp3 : int.
       ((((<=) (0) __framac_tmp3) /\
        ((<=) __framac_tmp3 (Uint64.to_int cnt))) -> ((=) true true))))) else
      ((=) true true)))
  
  
  lemma Valid_strn_shift1 #"/home/work/workdir/verker/strnlen.h" 13 7 133#
  "expl:Lemma valid_strn_shift1" :
  (forall voidP_s_12_21_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_12_21_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 13 7 133#
    (forall s_12 : (pointer voidP).
     (forall cnt_0 : Uint64.t.
      (((valid_strn s_12 cnt_0 voidP_s_12_21_alloc_table_at_L
        charP_charM_s_12_21_at_L)
       /\
       ((Uint64.(>) cnt_0 (#"strncmp.jc" 156 57 70# "expl:Integer cast"
        (Uint64.of_int (0))))
       /\
       (Int8.(<>) (select charP_charM_s_12_21_at_L s_12)
       (#"strncmp.jc" 157 33 44# "expl:Integer cast" (Int8.of_int (0)))))) ->
       (valid_strn (shift s_12 (1)) (#"strncmp.jc" 159 31 67#
       "expl:Integer cast"
       (Uint64.of_int (Int.(-) (Uint64.to_int cnt_0) (1))))
       voidP_s_12_21_alloc_table_at_L charP_charM_s_12_21_at_L)))))))
  
  lemma Valid_str_to_valid_strn
  #"/home/work/workdir/verker/strnlen.h" 17 7 80#
  "expl:Lemma valid_str_to_valid_strn" :
  (forall voidP_s_13_22_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_13_22_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 17 7 80#
    (forall s_13 : (pointer voidP).
     (forall cnt_1 : Uint64.t.
      ((valid_str s_13 voidP_s_13_22_alloc_table_at_L
       charP_charM_s_13_22_at_L) ->
       (valid_strn s_13 cnt_1 voidP_s_13_22_alloc_table_at_L
       charP_charM_s_13_22_at_L)))))))
  
  function strnlen (s_14 : (pointer voidP)) (cnt_2 : Uint64.t)
  (charP_charM_s_14_6_at_L : (memory voidP Int8.t)) : Uint64.t
  =
     (if
      (Bool.orb
      (Int8.(=) (select charP_charM_s_14_6_at_L (shift s_14 (0)))
      (#"strncmp.jc" 167 32 43# "expl:Integer cast" (Int8.of_int (0))))
      (Uint64.(=) cnt_2 (#"strncmp.jc" 167 58 71# "expl:Integer cast"
      (Uint64.of_int (0))))) then (#"strncmp.jc" 167 79 92#
      "expl:Integer cast" (Uint64.of_int (0))) else
      (#"strncmp.jc" 167 98 204# "expl:Integer cast"
      (Uint64.of_int
      (Int.(+) (1)
      (Uint64.to_int
      (strnlen (shift s_14 (1)) (#"strncmp.jc" 169 32 68# "expl:Integer cast"
      (Uint64.of_int (Int.(-) (Uint64.to_int cnt_2) (1))))
      charP_charM_s_14_6_at_L))))))
  
  
  lemma Strnlen_range #"/home/work/workdir/verker/strnlen.h" 26 7 109#
  "expl:Lemma strnlen_range" :
  (forall voidP_s_15_23_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_15_23_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 26 7 109#
    (forall s_15 : (pointer voidP).
     (forall cnt_3 : Uint64.t.
      ((valid_strn s_15 cnt_3 voidP_s_15_23_alloc_table_at_L
       charP_charM_s_15_23_at_L) ->
       ((Uint64.(<=) (#"strncmp.jc" 175 19 32# "expl:Integer cast"
        (Uint64.of_int (0))) (strnlen s_15 cnt_3 charP_charM_s_15_23_at_L))
       /\ (Uint64.(<=) (strnlen s_15 cnt_3 charP_charM_s_15_23_at_L) cnt_3))))))))
  
  lemma Strnlen_null #"/home/work/workdir/verker/strnlen.h" 31 7 111#
  "expl:Lemma strnlen_null" :
  (forall voidP_s_16_24_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_16_24_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 31 7 111#
    (forall s_16 : (pointer voidP).
     (forall cnt_4 : Uint64.t.
      ((((<=) (offset_min voidP_s_16_24_alloc_table_at_L s_16) (0)) /\
       (((>=) (offset_max voidP_s_16_24_alloc_table_at_L s_16) (0)) /\
       ((=) true true))) ->
       ((Uint64.(=) (strnlen s_16 cnt_4 charP_charM_s_16_24_at_L)
        (#"strncmp.jc" 184 46 59# "expl:Integer cast" (Uint64.of_int (0))))
       <->
       ((Int8.(=) (select charP_charM_s_16_24_at_L s_16)
        (#"strncmp.jc" 185 35 46# "expl:Integer cast" (Int8.of_int (0))))
       \/
       (Uint64.(=) cnt_4 (#"strncmp.jc" 185 61 74# "expl:Integer cast"
       (Uint64.of_int (0))))))))))))
  
  lemma Strnlen_zero_count #"/home/work/workdir/verker/strnlen.h" 35 7 60#
  "expl:Lemma strnlen_zero_count" :
  (forall charP_charM_s_17_25_at_L : (memory voidP Int8.t).
   (#"/home/work/workdir/verker/strnlen.h" 35 7 60#
   (forall s_17 : (pointer voidP).
    (Uint64.(=)
    (strnlen s_17 (#"strncmp.jc" 189 31 44# "expl:Integer cast"
    (Uint64.of_int (0))) charP_charM_s_17_25_at_L) (#"strncmp.jc" 189 49 62#
    "expl:Integer cast" (Uint64.of_int (0)))))))
  
  lemma Strnlen_min_len #"/home/work/workdir/verker/strnlen.h" 39 6 160#
  "expl:Lemma strnlen_min_len" :
  (forall voidP_s_18_26_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_18_26_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 39 6 160#
    (forall s_18 : (pointer voidP).
     (forall cnt_5 : Uint64.t.
      ((exists n_4 : Uint64.t.
        ((Uint64.(<) n_4 cnt_5) /\
        ((Int8.(=)
         (select charP_charM_s_18_26_at_L (shift s_18 (Uint64.to_int n_4)))
         (#"strncmp.jc" 196 57 68# "expl:Integer cast" (Int8.of_int (0))))
        /\
        (if ((<=) (0) (Uint64.to_int n_4)) then
         (((<=) (offset_min voidP_s_18_26_alloc_table_at_L s_18) (0)) /\
         (((>=) (offset_max voidP_s_18_26_alloc_table_at_L s_18)
          (Uint64.to_int n_4))
         /\
         (forall __framac_tmp6 : int.
          ((((<=) (0) __framac_tmp6) /\
           ((<=) __framac_tmp6 (Uint64.to_int n_4))) -> ((=) true true)))))
         else ((=) true true))))) ->
       ((=) (Uint64.to_int (strnlen s_18 cnt_5 charP_charM_s_18_26_at_L))
       (MinMax.min (Uint64.to_int (strlen s_18 charP_charM_s_18_26_at_L))
       (Uint64.to_int cnt_5)))))))))
  
  lemma Strnlen_before_zero #"/home/work/workdir/verker/strnlen.h" 44 7 122#
  "expl:Lemma strnlen_before_zero" :
  (forall voidP_s_19_27_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_19_27_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 44 7 122#
    (forall s_19 : (pointer voidP).
     (forall i_6 : Uint64.t.
      (forall cnt_6 : Uint64.t.
       (((valid_strn s_19 cnt_6 voidP_s_19_27_alloc_table_at_L
         charP_charM_s_19_27_at_L)
        /\
        ((Uint64.(<=) (#"strncmp.jc" 217 51 64# "expl:Integer cast"
         (Uint64.of_int (0))) i_6)
        /\ (Uint64.(<) i_6 (strnlen s_19 cnt_6 charP_charM_s_19_27_at_L))))
        ->
        (Int8.(<>)
        (select charP_charM_s_19_27_at_L (shift s_19 (Uint64.to_int i_6)))
        (#"strncmp.jc" 219 55 66# "expl:Integer cast" (Int8.of_int (0)))))))))))
  
  lemma Strnlen_at_zero #"/home/work/workdir/verker/strnlen.h" 49 7 133#
  "expl:Lemma strnlen_at_zero" :
  (forall voidP_s_20_28_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_20_28_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 49 7 133#
    (forall s_20 : (pointer voidP).
     (forall cnt_7 : Uint64.t.
      (((valid_strn s_20 cnt_7 voidP_s_20_28_alloc_table_at_L
        charP_charM_s_20_28_at_L)
       /\ (Uint64.(<) (strnlen s_20 cnt_7 charP_charM_s_20_28_at_L) cnt_7))
       ->
       (Int8.(=)
       (select charP_charM_s_20_28_at_L
       (shift s_20
       (Uint64.to_int (strnlen s_20 cnt_7 charP_charM_s_20_28_at_L))))
       (#"strncmp.jc" 227 19 30# "expl:Integer cast" (Int8.of_int (0))))))))))
  
  lemma Strnlen_at_cnt #"/home/work/workdir/verker/strnlen.h" 54 7 133#
  "expl:Lemma strnlen_at_cnt" :
  (forall voidP_s_21_29_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_21_29_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 54 7 133#
    (forall s_21 : (pointer voidP).
     (forall i_7 : Uint64.t.
      (forall cnt_8 : Uint64.t.
       (((valid_strn s_21 cnt_8 voidP_s_21_29_alloc_table_at_L
         charP_charM_s_21_29_at_L)
        /\ (Uint64.(=) i_7 (strnlen s_21 cnt_8 charP_charM_s_21_29_at_L))) ->
        ((Int8.(=)
         (select charP_charM_s_21_29_at_L (shift s_21 (Uint64.to_int i_7)))
         (#"strncmp.jc" 235 56 67# "expl:Integer cast" (Int8.of_int (0))))
        \/ (Uint64.(=) i_7 cnt_8)))))))))
  
  lemma Strnlen_zero #"/home/work/workdir/verker/strnlen.h" 59 7 209#
  "expl:Lemma strnlen_zero" :
  (forall voidP_s_22_30_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_22_30_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 59 7 209#
    (forall s_22 : (pointer voidP).
     (forall cnt_9 : Uint64.t.
      (forall n_5 : Uint64.t.
       (((valid_strn s_22 cnt_9 voidP_s_22_30_alloc_table_at_L
         charP_charM_s_22_30_at_L)
        /\
        ((Uint64.(<) n_5 cnt_9) /\
        ((Int8.(=)
         (select charP_charM_s_22_30_at_L (shift s_22 (Uint64.to_int n_5)))
         (#"strncmp.jc" 243 57 68# "expl:Integer cast" (Int8.of_int (0))))
        /\
        (forall i_8 : Uint64.t.
         ((Uint64.(<) i_8 n_5) ->
          (Int8.(<>)
          (select charP_charM_s_22_30_at_L (shift s_22 (Uint64.to_int i_8)))
          (#"strncmp.jc" 246 60 71# "expl:Integer cast" (Int8.of_int (0)))))))))
        -> (Uint64.(=) (strnlen s_22 cnt_9 charP_charM_s_22_30_at_L) n_5))))))))
  
  lemma Strnlen_cnt #"/home/work/workdir/verker/strnlen.h" 67 7 162#
  "expl:Lemma strnlen_cnt" :
  (forall voidP_s_23_31_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_23_31_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 67 7 162#
    (forall s_23 : (pointer voidP).
     (forall cnt_10 : Uint64.t.
      (((valid_strn s_23 cnt_10 voidP_s_23_31_alloc_table_at_L
        charP_charM_s_23_31_at_L)
       /\
       (forall n_6 : Uint64.t.
        ((Uint64.(<) n_6 cnt_10) ->
         (Int8.(<>)
         (select charP_charM_s_23_31_at_L (shift s_23 (Uint64.to_int n_6)))
         (#"strncmp.jc" 255 58 69# "expl:Integer cast" (Int8.of_int (0)))))))
       -> (Uint64.(=) (strnlen s_23 cnt_10 charP_charM_s_23_31_at_L) cnt_10)))))))
  
  lemma Strnlen_shift #"/home/work/workdir/verker/strnlen.h" 73 7 161#
  "expl:Lemma strnlen_shift" :
  (forall voidP_s_24_32_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_24_32_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 73 7 161#
    (forall s_24 : (pointer voidP).
     (forall i_9 : Uint64.t.
      (forall cnt_11 : Uint64.t.
       (((valid_strn s_24 cnt_11 voidP_s_24_32_alloc_table_at_L
         charP_charM_s_24_32_at_L)
        /\ (Uint64.(<=) i_9 (strnlen s_24 cnt_11 charP_charM_s_24_32_at_L)))
        ->
        ((=)
        (Uint64.to_int
        (strnlen (shift s_24 (Uint64.to_int i_9)) cnt_11
        charP_charM_s_24_32_at_L))
        (Int.(-)
        (Uint64.to_int (strnlen s_24 cnt_11 charP_charM_s_24_32_at_L))
        (Uint64.to_int i_9))))))))))
  
  lemma Strnlen_shift_ex #"/home/work/workdir/verker/strnlen.h" 79 7 160#
  "expl:Lemma strnlen_shift_ex" :
  (forall voidP_s_25_33_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_25_33_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 79 7 160#
    (forall s_25 : (pointer voidP).
     (forall i_10 : Uint64.t.
      (forall cnt_12 : Uint64.t.
       (((valid_strn s_25 cnt_12 voidP_s_25_33_alloc_table_at_L
         charP_charM_s_25_33_at_L)
        /\
        ((Uint64.(<) (#"strncmp.jc" 272 52 65# "expl:Integer cast"
         (Uint64.of_int (0))) i_10)
        /\ (Uint64.(<=) i_10 (strnlen s_25 cnt_12 charP_charM_s_25_33_at_L))))
        ->
        (Uint64.(<)
        (strnlen (shift s_25 (Uint64.to_int i_10)) cnt_12
        charP_charM_s_25_33_at_L)
        (strnlen s_25 cnt_12 charP_charM_s_25_33_at_L)))))))))
  
  lemma Strnlen_shift1 #"/home/work/workdir/verker/strnlen.h" 85 7 159#
  "expl:Lemma strnlen_shift1" :
  (forall voidP_s_26_34_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_26_34_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 85 7 159#
    (forall s_26 : (pointer voidP).
     (forall cnt_13 : Uint64.t.
      (((valid_strn s_26 cnt_13 voidP_s_26_34_alloc_table_at_L
        charP_charM_s_26_34_at_L)
       /\
       ((Uint64.(>) cnt_13 (#"strncmp.jc" 280 59 72# "expl:Integer cast"
        (Uint64.of_int (0))))
       /\
       (Int8.(<>) (select charP_charM_s_26_34_at_L s_26)
       (#"strncmp.jc" 281 33 44# "expl:Integer cast" (Int8.of_int (0)))))) ->
       ((=) (Uint64.to_int (strnlen s_26 cnt_13 charP_charM_s_26_34_at_L))
       (Int.(+)
       (Uint64.to_int
       (strnlen (shift s_26 (1)) (#"strncmp.jc" 284 32 69#
       "expl:Integer cast"
       (Uint64.of_int (Int.(-) (Uint64.to_int cnt_13) (1))))
       charP_charM_s_26_34_at_L)) (1)))))))))
  
  lemma Strnlen_cmp #"/home/work/workdir/verker/strnlen.h" 90 7 167#
  "expl:Lemma strnlen_cmp" :
  (forall voidP_s2_36_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_s1_35_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_s2_36_at_L : (memory voidP Int8.t).
     (forall charP_charM_s1_35_at_L : (memory voidP Int8.t).
      (#"/home/work/workdir/verker/strnlen.h" 90 7 167#
      (forall s1 : (pointer voidP).
       (forall s2 : (pointer voidP).
        (forall cnt_14 : Uint64.t.
         (((valid_str s1 voidP_s1_35_alloc_table_at_L charP_charM_s1_35_at_L)
          /\
          ((valid_strn s2 cnt_14 voidP_s2_36_alloc_table_at_L
           charP_charM_s2_36_at_L)
          /\
          (Uint64.(<) (strlen s1 charP_charM_s1_35_at_L)
          (strnlen s2 cnt_14 charP_charM_s2_36_at_L)))) ->
          (Uint64.(<) (strnlen s1 cnt_14 charP_charM_s1_35_at_L)
          (strnlen s2 cnt_14 charP_charM_s2_36_at_L)))))))))))
  
  lemma Strnlen_less #"/home/work/workdir/verker/strnlen.h" 95 7 139#
  "expl:Lemma strnlen_less" :
  (forall voidP_s_27_37_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_27_37_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 95 7 139#
    (forall s_27 : (pointer voidP).
     (forall i_11 : Uint64.t.
      (forall cnt_15 : Uint64.t.
       (((valid_strn s_27 cnt_15 voidP_s_27_37_alloc_table_at_L
         charP_charM_s_27_37_at_L)
        /\ (Uint64.(<=) i_11 cnt_15)) ->
        (Uint64.(<=) (strnlen s_27 i_11 charP_charM_s_27_37_at_L)
        (strnlen s_27 cnt_15 charP_charM_s_27_37_at_L)))))))))
  
  lemma Valid_str_strn #"/home/work/workdir/verker/strnlen.h" 101 7 114#
  "expl:Lemma valid_str_strn" :
  (forall voidP_s_28_38_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_28_38_at_L : (memory voidP Int8.t).
    (#"/home/work/workdir/verker/strnlen.h" 101 7 114#
    (forall s_28 : (pointer voidP).
     (forall cnt_16 : Uint64.t.
      (((valid_str s_28 voidP_s_28_38_alloc_table_at_L
        charP_charM_s_28_38_at_L)
       /\ (Uint64.(<=) cnt_16 (strlen s_28 charP_charM_s_28_38_at_L))) ->
       (valid_strn s_28 cnt_16 voidP_s_28_38_alloc_table_at_L
       charP_charM_s_28_38_at_L)))))))
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Goto_while_0_break_exc unit
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Function_strncmp_safety
#"/home/work/workdir/verker/strncmp.c" 29 4 57# "expl:strncmp, safety"

  use enum.Uint64 
  
  use Safe_uint64 
  
  use Safe_bit_uint8_of_Safe_bit_int8 
  
  use Safe_bit_uint8 
  
  use Safe_bit_int32_of_Safe_bit_uint8 
  
  use Safe_bit_int32 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use bool.Bool 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use import Axiomatic_Strnlen 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let strncmp #"/home/work/workdir/verker/strncmp.c" 29 4 57#
  "expl:Function strncmp, safety" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (count : Uint64.t)
   (voidP_cs_8_alloc_table : (alloc_table voidP)) (voidP_ct_9_alloc_table :
   (alloc_table voidP)) (voidP_ct_9_tag_table : (tag_table voidP))
   (voidP_cs_8_tag_table : (tag_table voidP)) (charP_charM_cs_8 : (memory
   voidP Int8.t)) (charP_charM_ct_9 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_ct_9_alloc_table ct) ->
     (((=) (typeof voidP_ct_9_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_9_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_9_alloc_table ct))) ->
       ((=) (typeof voidP_ct_9_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_8_alloc_table cs) ->
     (((=) (typeof voidP_cs_8_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_8_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_8_alloc_table cs))) ->
       ((=) (typeof voidP_cs_8_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strncmp.jc" 334 12 105#
   ((#"/home/work/workdir/verker/strncmp.c" 3 13 34#
    (valid_strn cs count voidP_cs_8_alloc_table charP_charM_cs_8))
   /\
   (#"/home/work/workdir/verker/strncmp.c" 4 13 34#
   (valid_strn ct count voidP_ct_9_alloc_table charP_charM_ct_9)))))) }
   ensures { ("expl:Postcondition" true) }  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   (let mutable_count = ref count in
   'Init:
   (let return = ref (Safe_bit_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let c1 = ref (Safe_bit_uint8.any_  () ) in
     (let c2 = ref (Safe_bit_uint8.any_  () ) in
     (let ocs = ref (any_pointer  () : (pointer voidP)) in
     (let oct = ref (any_pointer  () : (pointer voidP)) in
     (let ocount = ref (Safe_uint64.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Safe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Safe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Safe_bit_int32.any_  () ) in
     (let __retres = ref (Safe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       (ocs :=
        (let _jessie_92 = !mutable_cs in
        begin
        (assert {
        (#"/home/work/workdir/verker/strncmp.c" 32 17 20#
        "expl:Pointer index bounds" true) }); _jessie_92 end));
        begin
        (oct :=
         (let _jessie_91 = !mutable_ct in
         begin
         (assert {
         (#"/home/work/workdir/verker/strncmp.c" 33 17 20#
         "expl:Pointer index bounds" true) }); _jessie_91 end));
         begin
         (ocount :=
          (let _jessie_77 = !mutable_count in
          begin
          (assert {
          (#"/home/work/workdir/verker/strncmp.c" 34 18 24#
          "expl:Pointer index bounds" true) }); _jessie_77 end));
          begin
          any unit
          requires { true } reads { mutable_cs, mutable_ct }
          ensures {
            (#"/home/work/workdir/verker/strncmp.c" 36 12 123#
            (forall i_19 : int.
             ((((<=) (0) i_19) /\
              ((<) i_19
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) ->
              ((Bit_int8.(=)
               (select charP_charM_cs_8 (shift !mutable_cs i_19))
               (select charP_charM_ct_9 (shift !mutable_ct i_19)))
              <->
              (Bit_uint8.(=) (#"strncmp.jc" 500 56 82# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_cs_8 (shift !mutable_cs i_19))))
              (#"strncmp.jc" 501 57 83# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_ct_9 (shift !mutable_ct i_19))))))))) } ;
           () end;
          'Loop_5:
          loop
          invariant { (#"strncmp.jc" 505 6 9429# true) }
            variant { (#"/home/work/workdir/verker/strncmp.c" 48 18 23#
              (Uint64.to_int
              (#"/home/work/workdir/verker/strncmp.c" 48 18 23#
              !mutable_count))) }
           begin
           any unit
           requires { true } reads { mutable_count, mutable_cs, mutable_ct }
           ensures {
             ((#"/home/work/workdir/verker/strncmp.c" 47 20 83#
              (forall i_20 : int.
               ((((<=) (0) i_20) /\
                ((<) i_20
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count)))) ->
                (Bit_int8.(=) (select charP_charM_cs_8 (shift !ocs i_20))
                (select charP_charM_ct_9 (shift !oct i_20))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 46 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_ct !mutable_count charP_charM_ct_9))
              (Int.(-)
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
              (sub_pointer !mutable_ct !oct))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 45 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_cs !mutable_count charP_charM_cs_8))
              (Int.(-)
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
              (sub_pointer !mutable_cs !ocs))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              (#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              ((#"/home/work/workdir/verker/strncmp.c" 44 20 41#
               (valid_strn !mutable_cs !mutable_count voidP_cs_8_alloc_table
               charP_charM_cs_8))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 44 45 66#
              (valid_strn !mutable_ct !mutable_count voidP_ct_9_alloc_table
              charP_charM_ct_9)))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              (#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              ((#"/home/work/workdir/verker/strncmp.c" 43 20 40#
               ((=) (sub_pointer !mutable_cs !ocs)
               (sub_pointer !mutable_ct !oct)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 43 32 58#
              ((=) (sub_pointer !mutable_ct !oct)
              (Int.(-) (Uint64.to_int !ocount)
              (Uint64.to_int !mutable_count)))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               (same_block !oct !mutable_ct))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               ((<=) (sub_pointer !oct !mutable_ct) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 27 59#
               (same_block !mutable_ct
               (shift !oct
               (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 27 59#
              ((<=)
              (sub_pointer !mutable_ct
              (shift !oct
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))) (0))))))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               (same_block !ocs !mutable_cs))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               ((<=) (sub_pointer !ocs !mutable_cs) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 27 59#
               (same_block !mutable_cs
               (shift !ocs
               (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 27 59#
              ((<=)
              (sub_pointer !mutable_cs
              (shift !ocs
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) (0))))))))))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             ((#"/home/work/workdir/verker/strncmp.c" 40 20 30#
              (Uint64.(<=) (#"strncmp.jc" 507 38 51# "expl:Integer cast"
              (Uint64.of_int (0))) !mutable_count))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 25 40#
             (Uint64.(<=) !mutable_count !ocount)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workdir/verker/strncmp.c" 50 8 13#
             (Safe_uint64.(<>)  !mutable_count
              (#"strncmp.jc" 556 47 60# "expl:Integer cast"
              (Safe_uint64.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())));
              begin
              begin
              (tmp :=
               (let _jessie_78 = !mutable_cs in
               begin
               (assert {
               (#"/home/work/workdir/verker/strncmp.c" 51 47 51#
               "expl:Pointer index bounds" true) }); _jessie_78 end));
               begin
               (mutable_cs :=
                (let _jessie_79 =
                (shift_typesafe  !mutable_cs
                 (Safe_bit_int32.to_int 
                  (#"strncmp.jc" 561 48 60# "expl:Integer cast"
                  (Safe_bit_int32.of_int_const 1)) ) ) in
                begin
                (assert {
                (#"/home/work/workdir/verker/strncmp.c" 51 47 51#
                "expl:Pointer index bounds" true) }); _jessie_79 end));
                (c1 :=
                 (let _jessie_80 =
                 (#"/home/work/workdir/verker/strncmp.c" 51 23 51#
                 "expl:Integer cast"
                 (Safe_bit_uint8_of_Safe_bit_int8.cast_modulo 
                  (#"/home/work/workdir/verker/strncmp.c" 51 46 51#
                  "expl:Pointer dereference"
                  (acc  voidP_cs_8_alloc_table charP_charM_cs_8 !tmp )) )) in
                 begin
                 (assert {
                 (#"/home/work/workdir/verker/strncmp.c" 51 2 51#
                 "expl:Pointer index bounds" true) }); _jessie_80 end)) end
              end;
               begin
               (tmp_0 :=
                (let _jessie_81 = !mutable_ct in
                begin
                (assert {
                (#"/home/work/workdir/verker/strncmp.c" 52 47 51#
                "expl:Pointer index bounds" true) }); _jessie_81 end));
                begin
                (mutable_ct :=
                 (let _jessie_82 =
                 (shift_typesafe  !mutable_ct
                  (Safe_bit_int32.to_int 
                   (#"strncmp.jc" 566 48 60# "expl:Integer cast"
                   (Safe_bit_int32.of_int_const 1)) ) ) in
                 begin
                 (assert {
                 (#"/home/work/workdir/verker/strncmp.c" 52 47 51#
                 "expl:Pointer index bounds" true) }); _jessie_82 end));
                 (c2 :=
                  (let _jessie_83 =
                  (#"/home/work/workdir/verker/strncmp.c" 52 23 51#
                  "expl:Integer cast"
                  (Safe_bit_uint8_of_Safe_bit_int8.cast_modulo 
                   (#"/home/work/workdir/verker/strncmp.c" 52 46 51#
                   "expl:Pointer dereference"
                   (acc  voidP_ct_9_alloc_table charP_charM_ct_9 !tmp_0 )) ))
                  in
                  begin
                  (assert {
                  (#"/home/work/workdir/verker/strncmp.c" 52 2 51#
                  "expl:Pointer index bounds" true) }); _jessie_83 end)) end
               end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 53 13 96#
                 ((Bit_uint8.(=) !c1 (#"strncmp.jc" 572 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !ocs voidP_cs_8_alloc_table charP_charM_cs_8)
                  /\
                  ((Uint64.(=) (strlen !ocs charP_charM_cs_8)
                   (strnlen !ocs !ocount charP_charM_cs_8))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 54 13 96#
                 ((Bit_uint8.(=) !c2 (#"strncmp.jc" 588 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !oct voidP_ct_9_alloc_table charP_charM_ct_9)
                  /\
                  ((Uint64.(=) (strlen !oct charP_charM_ct_9)
                   (strnlen !oct !ocount charP_charM_ct_9))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               (if
               (#"/home/work/workdir/verker/strncmp.c" 55 6 14#
               (Safe_bit_int32.(<>) 
                (#"/home/work/workdir/verker/strncmp.c" 55 6 8#
                "expl:Integer cast"
                (Safe_bit_int32_of_Safe_bit_uint8.cast  !c1 ))
                (#"/home/work/workdir/verker/strncmp.c" 55 12 14#
                "expl:Integer cast"
                (Safe_bit_int32_of_Safe_bit_uint8.cast  !c2 )) ))
               then
                begin
                (if
                (#"/home/work/workdir/verker/strncmp.c" 56 23 30#
                (Safe_bit_int32.(<) 
                 (#"/home/work/workdir/verker/strncmp.c" 56 23 25#
                 "expl:Integer cast"
                 (Safe_bit_int32_of_Safe_bit_uint8.cast  !c1 ))
                 (#"/home/work/workdir/verker/strncmp.c" 56 28 30#
                 "expl:Integer cast"
                 (Safe_bit_int32_of_Safe_bit_uint8.cast  !c2 )) ))
                then
                 (tmp_1 :=
                  (let _jessie_85 =
                  (#"strncmp.jc" 604 82 95# "expl:Integer cast"
                  (Safe_bit_int32.of_int  (Int.(-_)  (1) ) )) in
                  begin
                  (assert {
                  (#"/home/work/workdir/verker/strncmp.c" 56 23 39#
                  "expl:Pointer index bounds" true) }); _jessie_85 end))
                else
                 (tmp_1 :=
                  (let _jessie_84 =
                  (#"strncmp.jc" 605 36 48# "expl:Integer cast"
                  (Safe_bit_int32.of_int_const 1)) in
                  begin
                  (assert {
                  (#"/home/work/workdir/verker/strncmp.c" 56 23 39#
                  "expl:Pointer index bounds" true) }); _jessie_84 end)));
                 begin
                 (res :=
                  (let _jessie_87 = !tmp_1 in
                  begin
                  (assert {
                  (#"/home/work/workdir/verker/strncmp.c" 56 17 20#
                  "expl:Pointer index bounds" true) }); _jessie_87 end));
                  begin (); () end;
                  (if
                  (#"/home/work/workdir/verker/strncmp.c" 64 10 17#
                  (Safe_bit_int32.(<) 
                   (#"/home/work/workdir/verker/strncmp.c" 64 10 12#
                   "expl:Integer cast"
                   (Safe_bit_int32_of_Safe_bit_uint8.cast  !c1 ))
                   (#"/home/work/workdir/verker/strncmp.c" 64 15 17#
                   "expl:Integer cast"
                   (Safe_bit_int32_of_Safe_bit_uint8.cast  !c2 )) ))
                  then
                   (tmp_2 :=
                    (let _jessie_89 =
                    (#"strncmp.jc" 641 82 95# "expl:Integer cast"
                    (Safe_bit_int32.of_int  (Int.(-_)  (1) ) )) in
                    begin
                    (assert {
                    (#"/home/work/workdir/verker/strncmp.c" 64 10 26#
                    "expl:Pointer index bounds" true) }); _jessie_89 end))
                  else
                   (tmp_2 :=
                    (let _jessie_88 =
                    (#"strncmp.jc" 642 36 48# "expl:Integer cast"
                    (Safe_bit_int32.of_int_const 1)) in
                    begin
                    (assert {
                    (#"/home/work/workdir/verker/strncmp.c" 64 10 26#
                    "expl:Pointer index bounds" true) }); _jessie_88 end)));
                  begin
                  (__retres :=
                   (let _jessie_86 = !tmp_2 in
                   begin
                   (assert {
                   (#"/home/work/workdir/verker/strncmp.c" 64 3 27#
                   "expl:Pointer index bounds" true) }); _jessie_86 end));
                   (raise (Return_label_exc ())) end end end else ());
               (if
               (#"/home/work/workdir/verker/strncmp.c" 65 6 9#
               (Bool.notb 
                (Safe_bit_uint8.(<>)  !c1
                 (#"strncmp.jc" 649 50 62# "expl:Integer cast"
                 (Safe_bit_uint8.of_int_const 0)) ) ))
               then (raise (Goto_while_0_break_exc ())) else ());
               begin
               (mutable_count :=
                (let _jessie_90 =
                (Safe_uint64.(-)  !mutable_count
                 (#"strncmp.jc" 652 57 70# "expl:Integer cast"
                 (Safe_uint64.of_int (1))) ) in
                begin
                (assert {
                (#"/home/work/workdir/verker/strncmp.c" 67 2 9#
                "expl:Pointer index bounds" true) }); _jessie_90 end));
                begin
                any unit
                requires { true } reads { mutable_cs }
                ensures {
                  (#"/home/work/workdir/verker/strncmp.c" 68 13 51#
                  (Bit_int8.(=)
                  (select charP_charM_cs_8
                  (shift !ocs (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))
                  (select charP_charM_ct_9
                  (shift !oct (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))))
                  } ; () end end end end; (raise (Loop_continue_exc ())) end
             with Loop_continue_exc _jessie_4 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (let _jessie_93 =
         (#"strncmp.jc" 667 28 40# "expl:Integer cast"
         (Safe_bit_int32.of_int_const 0)) in
         begin
         (assert {
         (#"/home/work/workdir/verker/strncmp.c" 71 1 10#
         "expl:Pointer index bounds" true) }); _jessie_93 end)) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label:
      begin
      (return :=
       (let _jessie_94 = !__retres in
       begin
       (assert { (#"strncmp.jc" 669 7 22# "expl:Pointer index bounds" true)
       }); _jessie_94 end)); (raise Return) end end))))))))))); absurd  end
    with Return -> !return end))))
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Function_strncmp_behaviors
#"/home/work/workdir/verker/strncmp.c" 29 4 57# "expl:strncmp, behaviors"

  use Unsafe_uint64 
  
  use Unsafe_bit_uint8_of_Unsafe_bit_int8 
  
  use Unsafe_bit_uint8 
  
  use Unsafe_bit_int32_of_Unsafe_bit_uint8 
  
  use Unsafe_bit_int32 
  
  use enum.Uint64 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use import Exceptions 
  
  use bool.Bool 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use enum.Bit_int32 
  
  use import Axiomatic_Strnlen 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  let strncmp_ensures_default #"/home/work/workdir/verker/strncmp.c" 29 4 57#
  "expl:Function strncmp, default behavior" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (count : Uint64.t)
   (voidP_cs_8_alloc_table : (alloc_table voidP)) (voidP_ct_9_alloc_table :
   (alloc_table voidP)) (voidP_ct_9_tag_table : (tag_table voidP))
   (voidP_cs_8_tag_table : (tag_table voidP)) (charP_charM_cs_8 : (memory
   voidP Int8.t)) (charP_charM_ct_9 : (memory voidP Int8.t)) 
   requires {
   (((allocated voidP_ct_9_alloc_table ct) ->
     (((=) (typeof voidP_ct_9_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_9_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_9_alloc_table ct))) ->
       ((=) (typeof voidP_ct_9_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_8_alloc_table cs) ->
     (((=) (typeof voidP_cs_8_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_8_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_8_alloc_table cs))) ->
       ((=) (typeof voidP_cs_8_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strncmp.jc" 334 12 105#
   ((#"/home/work/workdir/verker/strncmp.c" 3 13 34#
    (valid_strn cs count voidP_cs_8_alloc_table charP_charM_cs_8))
   /\
   (#"/home/work/workdir/verker/strncmp.c" 4 13 34#
   (valid_strn ct count voidP_ct_9_alloc_table charP_charM_ct_9)))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workdir/verker/strncmp.c" 6 12 57# "expl:Ensures clause"
     ((Bit_int32.(=) result (#"strncmp.jc" 338 34 50# "expl:Integer cast"
      (Bit_int32.of_int (Int.(-_) (1)))))
     \/
     ((Bit_int32.(=) result (#"strncmp.jc" 339 35 47# "expl:Integer cast"
      (Bit_int32.of_int_const 0)))
     \/
     (Bit_int32.(=) result (#"strncmp.jc" 340 34 46# "expl:Integer cast"
     (Bit_int32.of_int_const 1))))))) } diverges  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   (let mutable_count = ref count in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (check {
    (#"strncmp.jc" 384 10 1062# "expl:Behavior disjointness check"
    (not
    ((Uint64.(>) !mutable_count (#"strncmp.jc" 384 46 59# "expl:Integer cast"
     (Uint64.of_int (0))))
    /\
    ((forall i_17_0 : int.
      ((((<=) (0) i_17_0) /\
       ((<) i_17_0
       (Uint64.to_int (strnlen !mutable_cs !mutable_count charP_charM_cs_8))))
       ->
       (Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_17_0))
       (select charP_charM_ct_9 (shift !mutable_ct i_17_0)))))
    /\
    ((Uint64.(<>) (strnlen !mutable_cs !mutable_count charP_charM_cs_8)
     (strnlen !mutable_ct !mutable_count charP_charM_ct_9))
    /\
    ((Uint64.(>) !mutable_count (#"strncmp.jc" 393 47 60# "expl:Integer cast"
     (Uint64.of_int (0))))
    /\
    (exists i_15_0 : int.
     (((<=) (0) i_15_0) /\
     (((<) i_15_0
      (Uint64.to_int (strnlen !mutable_cs !mutable_count charP_charM_cs_8)))
     /\
     (Bit_int8.(<>) (select charP_charM_cs_8 (shift !mutable_cs i_15_0))
     (select charP_charM_ct_9 (shift !mutable_ct i_15_0)))))))))))) });
     (check {
     (#"strncmp.jc" 401 10 1293# "expl:Behavior disjointness check"
     (not
     (((Uint64.(=) !mutable_count (#"strncmp.jc" 401 47 60#
       "expl:Integer cast" (Uint64.of_int (0))))
      \/
      ((Uint64.(>) !mutable_count (#"strncmp.jc" 402 49 62#
       "expl:Integer cast" (Uint64.of_int (0))))
      /\
      ((forall i_18_0 : int.
        ((((<=) (0) i_18_0) /\
         ((<) i_18_0
         (Uint64.to_int
         (strnlen !mutable_cs !mutable_count charP_charM_cs_8)))) ->
         (Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_18_0))
         (select charP_charM_ct_9 (shift !mutable_ct i_18_0)))))
      /\
      (Uint64.(=) (strnlen !mutable_cs !mutable_count charP_charM_cs_8)
      (strnlen !mutable_ct !mutable_count charP_charM_ct_9)))))
     /\
     ((Uint64.(>) !mutable_count (#"strncmp.jc" 411 47 60#
      "expl:Integer cast" (Uint64.of_int (0))))
     /\
     ((forall i_17_1 : int.
       ((((<=) (0) i_17_1) /\
        ((<) i_17_1
        (Uint64.to_int (strnlen !mutable_cs !mutable_count charP_charM_cs_8))))
        ->
        (Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_17_1))
        (select charP_charM_ct_9 (shift !mutable_ct i_17_1)))))
     /\
     (Uint64.(<>) (strnlen !mutable_cs !mutable_count charP_charM_cs_8)
     (strnlen !mutable_ct !mutable_count charP_charM_ct_9))))))) });
     (check {
     (#"strncmp.jc" 421 10 1143# "expl:Behavior disjointness check"
     (not
     (((Uint64.(=) !mutable_count (#"strncmp.jc" 421 47 60#
       "expl:Integer cast" (Uint64.of_int (0))))
      \/
      ((Uint64.(>) !mutable_count (#"strncmp.jc" 422 49 62#
       "expl:Integer cast" (Uint64.of_int (0))))
      /\
      ((forall i_18_1 : int.
        ((((<=) (0) i_18_1) /\
         ((<) i_18_1
         (Uint64.to_int
         (strnlen !mutable_cs !mutable_count charP_charM_cs_8)))) ->
         (Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_18_1))
         (select charP_charM_ct_9 (shift !mutable_ct i_18_1)))))
      /\
      (Uint64.(=) (strnlen !mutable_cs !mutable_count charP_charM_cs_8)
      (strnlen !mutable_ct !mutable_count charP_charM_ct_9)))))
     /\
     ((Uint64.(>) !mutable_count (#"strncmp.jc" 431 47 60#
      "expl:Integer cast" (Uint64.of_int (0))))
     /\
     (exists i_15_1 : int.
      (((<=) (0) i_15_1) /\
      (((<) i_15_1
       (Uint64.to_int (strnlen !mutable_cs !mutable_count charP_charM_cs_8)))
      /\
      (Bit_int8.(<>) (select charP_charM_cs_8 (shift !mutable_cs i_15_1))
      (select charP_charM_ct_9 (shift !mutable_ct i_15_1)))))))))) });
     (check {
     (#"strncmp.jc" 439 10 1708# "expl:Behavior completeness check"
     (((Uint64.(>) !mutable_count (#"strncmp.jc" 439 43 56#
       "expl:Integer cast" (Uint64.of_int (0))))
      /\
      (exists i_15_2 : int.
       (((<=) (0) i_15_2) /\
       (((<) i_15_2
        (Uint64.to_int (strnlen !mutable_cs !mutable_count charP_charM_cs_8)))
       /\
       (Bit_int8.(<>) (select charP_charM_cs_8 (shift !mutable_cs i_15_2))
       (select charP_charM_ct_9 (shift !mutable_ct i_15_2)))))))
     \/
     (((Uint64.(>) !mutable_count (#"strncmp.jc" 446 45 58#
       "expl:Integer cast" (Uint64.of_int (0))))
      /\
      ((forall i_17_2 : int.
        ((((<=) (0) i_17_2) /\
         ((<) i_17_2
         (Uint64.to_int
         (strnlen !mutable_cs !mutable_count charP_charM_cs_8)))) ->
         (Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_17_2))
         (select charP_charM_ct_9 (shift !mutable_ct i_17_2)))))
      /\
      (Uint64.(<>) (strnlen !mutable_cs !mutable_count charP_charM_cs_8)
      (strnlen !mutable_ct !mutable_count charP_charM_ct_9))))
     \/
     ((Uint64.(=) !mutable_count (#"strncmp.jc" 455 47 60#
      "expl:Integer cast" (Uint64.of_int (0))))
     \/
     ((Uint64.(>) !mutable_count (#"strncmp.jc" 456 49 62#
      "expl:Integer cast" (Uint64.of_int (0))))
     /\
     ((forall i_18_2 : int.
       ((((<=) (0) i_18_2) /\
        ((<) i_18_2
        (Uint64.to_int (strnlen !mutable_cs !mutable_count charP_charM_cs_8))))
        ->
        (Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_18_2))
        (select charP_charM_ct_9 (shift !mutable_ct i_18_2)))))
     /\
     (Uint64.(=) (strnlen !mutable_cs !mutable_count charP_charM_cs_8)
     (strnlen !mutable_ct !mutable_count charP_charM_ct_9)))))))) });
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let ocs = ref (any_pointer  () : (pointer voidP)) in
     (let oct = ref (any_pointer  () : (pointer voidP)) in
     (let ocount = ref (Unsafe_uint64.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       (ocs := !mutable_cs);
        begin
        (oct := !mutable_ct);
         begin
         (ocount := !mutable_count);
          begin
          (assert {
          (#"/home/work/workdir/verker/strncmp.c" 36 12 123#
          "expl:Assertion in line 36"
          (forall i_19 : int.
           ((((<=) (0) i_19) /\
            ((<) i_19
            (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) ->
            ((Bit_int8.(=) (select charP_charM_cs_8 (shift !mutable_cs i_19))
             (select charP_charM_ct_9 (shift !mutable_ct i_19)))
            <->
            (Bit_uint8.(=) (#"strncmp.jc" 500 56 82# "expl:Integer cast"
            (Bit_uint8_of_Bit_int8.cast_modulo
            (select charP_charM_cs_8 (shift !mutable_cs i_19))))
            (#"strncmp.jc" 501 57 83# "expl:Integer cast"
            (Bit_uint8_of_Bit_int8.cast_modulo
            (select charP_charM_ct_9 (shift !mutable_ct i_19))))))))) }); ()
          end;
          'Loop_1:
          loop
          invariant
            { ((#"/home/work/workdir/verker/strncmp.c" 40 20 40#
               (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
               ((#"/home/work/workdir/verker/strncmp.c" 40 20 30#
                (Uint64.(<=) (#"strncmp.jc" 507 38 51# "expl:Integer cast"
                (Uint64.of_int (0))) !mutable_count))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 40 25 40#
               (Uint64.(<=) !mutable_count !ocount)))))
              &&
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 59#
               (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
               ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
                (same_block !ocs !mutable_cs))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
               ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
                ((<=) (sub_pointer !ocs !mutable_cs) (0)))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
               ((#"/home/work/workdir/verker/strncmp.c" 41 27 59#
                (same_block !mutable_cs
                (shift !ocs
                (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 41 27 59#
               ((<=)
               (sub_pointer !mutable_cs
               (shift !ocs
               (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) (0))))))))))
              &&
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 59#
               (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
               ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
                (same_block !oct !mutable_ct))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
               ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
                ((<=) (sub_pointer !oct !mutable_ct) (0)))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
               ((#"/home/work/workdir/verker/strncmp.c" 42 27 59#
                (same_block !mutable_ct
                (shift !oct
                (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 42 27 59#
               ((<=)
               (sub_pointer !mutable_ct
               (shift !oct
               (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))) (0))))))))))
              &&
              ((#"/home/work/workdir/verker/strncmp.c" 43 20 58#
               (#"/home/work/workdir/verker/strncmp.c" 43 20 58#
               ((#"/home/work/workdir/verker/strncmp.c" 43 20 40#
                ((=) (sub_pointer !mutable_cs !ocs)
                (sub_pointer !mutable_ct !oct)))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 43 32 58#
               ((=) (sub_pointer !mutable_ct !oct)
               (Int.(-) (Uint64.to_int !ocount)
               (Uint64.to_int !mutable_count)))))))
              &&
              ((#"/home/work/workdir/verker/strncmp.c" 44 20 66#
               (#"/home/work/workdir/verker/strncmp.c" 44 20 66#
               ((#"/home/work/workdir/verker/strncmp.c" 44 20 41#
                (valid_strn !mutable_cs !mutable_count voidP_cs_8_alloc_table
                charP_charM_cs_8))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 44 45 66#
               (valid_strn !mutable_ct !mutable_count voidP_ct_9_alloc_table
               charP_charM_ct_9)))))
              &&
              ((#"/home/work/workdir/verker/strncmp.c" 45 20 75#
               ((=)
               (Uint64.to_int
               (strnlen !mutable_cs !mutable_count charP_charM_cs_8))
               (Int.(-)
               (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
               (sub_pointer !mutable_cs !ocs))))
              &&
              ((#"/home/work/workdir/verker/strncmp.c" 46 20 75#
               ((=)
               (Uint64.to_int
               (strnlen !mutable_ct !mutable_count charP_charM_ct_9))
               (Int.(-)
               (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
               (sub_pointer !mutable_ct !oct))))
              &&
              (#"/home/work/workdir/verker/strncmp.c" 47 20 83#
              (forall i_20 : int.
               ((((<=) (0) i_20) /\
                ((<) i_20
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count)))) ->
                (Bit_int8.(=) (select charP_charM_cs_8 (shift !ocs i_20))
                (select charP_charM_ct_9 (shift !oct i_20))))))))))))) } 
            
           begin
           any unit requires { true } ensures { true } ;
            try
             begin
             begin
             (if
             (#"/home/work/workdir/verker/strncmp.c" 50 8 13#
             (Unsafe_uint64.(<>)  !mutable_count
              (#"strncmp.jc" 556 47 60# "expl:Integer cast"
              (Unsafe_uint64.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())));
              begin
              begin
              (tmp := !mutable_cs);
               begin
               (mutable_cs :=
                (shift_  !mutable_cs
                 (Unsafe_bit_int32.to_int 
                  (#"strncmp.jc" 561 48 60# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1)) ) ));
                (c1 :=
                 (#"/home/work/workdir/verker/strncmp.c" 51 23 51#
                 "expl:Integer cast"
                 (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                  (acc  charP_charM_cs_8 !tmp ) ))) end end;
               begin
               (tmp_0 := !mutable_ct);
                begin
                (mutable_ct :=
                 (shift_  !mutable_ct
                  (Unsafe_bit_int32.to_int 
                   (#"strncmp.jc" 566 48 60# "expl:Integer cast"
                   (Unsafe_bit_int32.of_int_const 1)) ) ));
                 (c2 :=
                  (#"/home/work/workdir/verker/strncmp.c" 52 23 51#
                  "expl:Integer cast"
                  (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                   (acc  charP_charM_ct_9 !tmp_0 ) ))) end end;
               begin
               (assert {
               (#"/home/work/workdir/verker/strncmp.c" 53 13 96#
               "expl:Assertion in line 53"
               ((Bit_uint8.(=) !c1 (#"strncmp.jc" 572 61 73#
                "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                ((valid_str !ocs voidP_cs_8_alloc_table charP_charM_cs_8) /\
                ((Uint64.(=) (strlen !ocs charP_charM_cs_8)
                 (strnlen !ocs !ocount charP_charM_cs_8))
                /\
                ((=) (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count))))))) }); () end;
               begin
               (assert {
               (#"/home/work/workdir/verker/strncmp.c" 54 13 96#
               "expl:Assertion in line 54"
               ((Bit_uint8.(=) !c2 (#"strncmp.jc" 588 61 73#
                "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                ((valid_str !oct voidP_ct_9_alloc_table charP_charM_ct_9) /\
                ((Uint64.(=) (strlen !oct charP_charM_ct_9)
                 (strnlen !oct !ocount charP_charM_ct_9))
                /\
                ((=) (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count))))))) }); () end;
               (if
               (#"/home/work/workdir/verker/strncmp.c" 55 6 14#
               (Unsafe_bit_int32.(<>) 
                (#"/home/work/workdir/verker/strncmp.c" 55 6 8#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                (#"/home/work/workdir/verker/strncmp.c" 55 12 14#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
               then
                begin
                (if
                (#"/home/work/workdir/verker/strncmp.c" 56 23 30#
                (Unsafe_bit_int32.(<) 
                 (#"/home/work/workdir/verker/strncmp.c" 56 23 25#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                 (#"/home/work/workdir/verker/strncmp.c" 56 28 30#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                then
                 (tmp_1 :=
                  (#"strncmp.jc" 604 82 95# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                else
                 (tmp_1 :=
                  (#"strncmp.jc" 605 36 48# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1))));
                 begin
                 (res := !tmp_1); begin (); () end;
                  (if
                  (#"/home/work/workdir/verker/strncmp.c" 64 10 17#
                  (Unsafe_bit_int32.(<) 
                   (#"/home/work/workdir/verker/strncmp.c" 64 10 12#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                   (#"/home/work/workdir/verker/strncmp.c" 64 15 17#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                  then
                   (tmp_2 :=
                    (#"strncmp.jc" 641 82 95# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                  else
                   (tmp_2 :=
                    (#"strncmp.jc" 642 36 48# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int_const 1))));
                  begin (__retres := !tmp_2); (raise (Return_label_exc ()))
                  end end end else ());
               (if
               (#"/home/work/workdir/verker/strncmp.c" 65 6 9#
               (Bool.notb 
                (Unsafe_bit_uint8.(<>)  !c1
                 (#"strncmp.jc" 649 50 62# "expl:Integer cast"
                 (Unsafe_bit_uint8.of_int_const 0)) ) ))
               then (raise (Goto_while_0_break_exc ())) else ());
               begin
               (mutable_count :=
                (Unsafe_uint64.(-)  !mutable_count
                 (#"strncmp.jc" 652 57 70# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) ));
                begin
                (assert {
                (#"/home/work/workdir/verker/strncmp.c" 68 13 51#
                "expl:Assertion in line 68"
                (Bit_int8.(=)
                (select charP_charM_cs_8
                (shift !ocs (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))
                (select charP_charM_ct_9
                (shift !oct (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))))
                }); () end end end end; (raise (Loop_continue_exc ())) end
             with Loop_continue_exc _jessie_4 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strncmp.jc" 667 28 40# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end)))))))))));
     absurd  end with Return -> !return end))))
  
  let strncmp_ensures_equal #"/home/work/workdir/verker/strncmp.c" 29 4 57#
  "expl:Function strncmp, behavior equal" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (count : Uint64.t)
   (voidP_cs_8_alloc_table : (alloc_table voidP)) (voidP_ct_9_alloc_table :
   (alloc_table voidP)) (voidP_ct_9_tag_table : (tag_table voidP))
   (voidP_cs_8_tag_table : (tag_table voidP)) (charP_charM_cs_8 : (memory
   voidP Int8.t)) (charP_charM_ct_9 : (memory voidP Int8.t)) 
   requires {
   (((Uint64.(=) count (#"strncmp.jc" 342 21 34# "expl:Integer cast"
     (Uint64.of_int (0))))
    \/
    ((Uint64.(>) count (#"strncmp.jc" 343 23 36# "expl:Integer cast"
     (Uint64.of_int (0))))
    /\
    ((forall i_18 : int.
      ((((<=) (0) i_18) /\
       ((<) i_18 (Uint64.to_int (strnlen cs count charP_charM_cs_8)))) ->
       (Bit_int8.(=) (select charP_charM_cs_8 (shift cs i_18))
       (select charP_charM_ct_9 (shift ct i_18)))))
    /\
    (Uint64.(=) (strnlen cs count charP_charM_cs_8)
    (strnlen ct count charP_charM_ct_9)))))
   /\
   (((allocated voidP_ct_9_alloc_table ct) ->
     (((=) (typeof voidP_ct_9_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_9_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_9_alloc_table ct))) ->
       ((=) (typeof voidP_ct_9_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_8_alloc_table cs) ->
     (((=) (typeof voidP_cs_8_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_8_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_8_alloc_table cs))) ->
       ((=) (typeof voidP_cs_8_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strncmp.jc" 334 12 105#
   ((#"/home/work/workdir/verker/strncmp.c" 3 13 34#
    (valid_strn cs count voidP_cs_8_alloc_table charP_charM_cs_8))
   /\
   (#"/home/work/workdir/verker/strncmp.c" 4 13 34#
   (valid_strn ct count voidP_ct_9_alloc_table charP_charM_ct_9))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workdir/verker/strncmp.c" 12 15 27# "expl:Ensures clause"
     (Bit_int32.(=) result (#"strncmp.jc" 349 32 44# "expl:Integer cast"
     (Bit_int32.of_int_const 0))))) } diverges  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   (let mutable_count = ref count in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let ocs = ref (any_pointer  () : (pointer voidP)) in
     (let oct = ref (any_pointer  () : (pointer voidP)) in
     (let ocount = ref (Unsafe_uint64.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       (ocs := !mutable_cs);
        begin
        (oct := !mutable_ct);
         begin
         (ocount := !mutable_count);
          begin
          any unit
          requires { true } reads { mutable_cs, mutable_ct }
          ensures {
            (#"/home/work/workdir/verker/strncmp.c" 36 12 123#
            (forall i_19 : int.
             ((((<=) (0) i_19) /\
              ((<) i_19
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) ->
              ((Bit_int8.(=)
               (select charP_charM_cs_8 (shift !mutable_cs i_19))
               (select charP_charM_ct_9 (shift !mutable_ct i_19)))
              <->
              (Bit_uint8.(=) (#"strncmp.jc" 500 56 82# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_cs_8 (shift !mutable_cs i_19))))
              (#"strncmp.jc" 501 57 83# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_ct_9 (shift !mutable_ct i_19))))))))) } ;
           () end;
          'Loop_2:
          loop
          invariant { (#"strncmp.jc" 505 6 9429# true) } 
           begin
           any unit
           requires { true } reads { mutable_count, mutable_cs, mutable_ct }
           ensures {
             ((#"/home/work/workdir/verker/strncmp.c" 47 20 83#
              (forall i_20 : int.
               ((((<=) (0) i_20) /\
                ((<) i_20
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count)))) ->
                (Bit_int8.(=) (select charP_charM_cs_8 (shift !ocs i_20))
                (select charP_charM_ct_9 (shift !oct i_20))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 46 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_ct !mutable_count charP_charM_ct_9))
              (Int.(-)
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
              (sub_pointer !mutable_ct !oct))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 45 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_cs !mutable_count charP_charM_cs_8))
              (Int.(-)
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
              (sub_pointer !mutable_cs !ocs))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              (#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              ((#"/home/work/workdir/verker/strncmp.c" 44 20 41#
               (valid_strn !mutable_cs !mutable_count voidP_cs_8_alloc_table
               charP_charM_cs_8))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 44 45 66#
              (valid_strn !mutable_ct !mutable_count voidP_ct_9_alloc_table
              charP_charM_ct_9)))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              (#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              ((#"/home/work/workdir/verker/strncmp.c" 43 20 40#
               ((=) (sub_pointer !mutable_cs !ocs)
               (sub_pointer !mutable_ct !oct)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 43 32 58#
              ((=) (sub_pointer !mutable_ct !oct)
              (Int.(-) (Uint64.to_int !ocount)
              (Uint64.to_int !mutable_count)))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               (same_block !oct !mutable_ct))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               ((<=) (sub_pointer !oct !mutable_ct) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 27 59#
               (same_block !mutable_ct
               (shift !oct
               (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 27 59#
              ((<=)
              (sub_pointer !mutable_ct
              (shift !oct
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))) (0))))))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               (same_block !ocs !mutable_cs))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               ((<=) (sub_pointer !ocs !mutable_cs) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 27 59#
               (same_block !mutable_cs
               (shift !ocs
               (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 27 59#
              ((<=)
              (sub_pointer !mutable_cs
              (shift !ocs
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) (0))))))))))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             ((#"/home/work/workdir/verker/strncmp.c" 40 20 30#
              (Uint64.(<=) (#"strncmp.jc" 507 38 51# "expl:Integer cast"
              (Uint64.of_int (0))) !mutable_count))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 25 40#
             (Uint64.(<=) !mutable_count !ocount)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workdir/verker/strncmp.c" 50 8 13#
             (Unsafe_uint64.(<>)  !mutable_count
              (#"strncmp.jc" 556 47 60# "expl:Integer cast"
              (Unsafe_uint64.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())));
              begin
              begin
              (tmp := !mutable_cs);
               begin
               (mutable_cs :=
                (shift_  !mutable_cs
                 (Unsafe_bit_int32.to_int 
                  (#"strncmp.jc" 561 48 60# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1)) ) ));
                (c1 :=
                 (#"/home/work/workdir/verker/strncmp.c" 51 23 51#
                 "expl:Integer cast"
                 (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                  (acc  charP_charM_cs_8 !tmp ) ))) end end;
               begin
               (tmp_0 := !mutable_ct);
                begin
                (mutable_ct :=
                 (shift_  !mutable_ct
                  (Unsafe_bit_int32.to_int 
                   (#"strncmp.jc" 566 48 60# "expl:Integer cast"
                   (Unsafe_bit_int32.of_int_const 1)) ) ));
                 (c2 :=
                  (#"/home/work/workdir/verker/strncmp.c" 52 23 51#
                  "expl:Integer cast"
                  (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                   (acc  charP_charM_ct_9 !tmp_0 ) ))) end end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 53 13 96#
                 ((Bit_uint8.(=) !c1 (#"strncmp.jc" 572 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !ocs voidP_cs_8_alloc_table charP_charM_cs_8)
                  /\
                  ((Uint64.(=) (strlen !ocs charP_charM_cs_8)
                   (strnlen !ocs !ocount charP_charM_cs_8))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 54 13 96#
                 ((Bit_uint8.(=) !c2 (#"strncmp.jc" 588 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !oct voidP_ct_9_alloc_table charP_charM_ct_9)
                  /\
                  ((Uint64.(=) (strlen !oct charP_charM_ct_9)
                   (strnlen !oct !ocount charP_charM_ct_9))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               (if
               (#"/home/work/workdir/verker/strncmp.c" 55 6 14#
               (Unsafe_bit_int32.(<>) 
                (#"/home/work/workdir/verker/strncmp.c" 55 6 8#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                (#"/home/work/workdir/verker/strncmp.c" 55 12 14#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
               then
                begin
                (if
                (#"/home/work/workdir/verker/strncmp.c" 56 23 30#
                (Unsafe_bit_int32.(<) 
                 (#"/home/work/workdir/verker/strncmp.c" 56 23 25#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                 (#"/home/work/workdir/verker/strncmp.c" 56 28 30#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                then
                 (tmp_1 :=
                  (#"strncmp.jc" 604 82 95# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                else
                 (tmp_1 :=
                  (#"strncmp.jc" 605 36 48# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1))));
                 begin
                 (res := !tmp_1); begin (); () end;
                  (if
                  (#"/home/work/workdir/verker/strncmp.c" 64 10 17#
                  (Unsafe_bit_int32.(<) 
                   (#"/home/work/workdir/verker/strncmp.c" 64 10 12#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                   (#"/home/work/workdir/verker/strncmp.c" 64 15 17#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                  then
                   (tmp_2 :=
                    (#"strncmp.jc" 641 82 95# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                  else
                   (tmp_2 :=
                    (#"strncmp.jc" 642 36 48# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int_const 1))));
                  begin (__retres := !tmp_2); (raise (Return_label_exc ()))
                  end end end else ());
               (if
               (#"/home/work/workdir/verker/strncmp.c" 65 6 9#
               (Bool.notb 
                (Unsafe_bit_uint8.(<>)  !c1
                 (#"strncmp.jc" 649 50 62# "expl:Integer cast"
                 (Unsafe_bit_uint8.of_int_const 0)) ) ))
               then (raise (Goto_while_0_break_exc ())) else ());
               begin
               (mutable_count :=
                (Unsafe_uint64.(-)  !mutable_count
                 (#"strncmp.jc" 652 57 70# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) ));
                begin
                any unit
                requires { true } reads { mutable_cs }
                ensures {
                  (#"/home/work/workdir/verker/strncmp.c" 68 13 51#
                  (Bit_int8.(=)
                  (select charP_charM_cs_8
                  (shift !ocs (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))
                  (select charP_charM_ct_9
                  (shift !oct (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))))
                  } ; () end end end end; (raise (Loop_continue_exc ())) end
             with Loop_continue_exc _jessie_4 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strncmp.jc" 667 28 40# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end)))))))))));
     absurd  end with Return -> !return end))))
  
  let strncmp_ensures_len_diff
  #"/home/work/workdir/verker/strncmp.c" 29 4 57#
  "expl:Function strncmp, behavior len_diff" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (count : Uint64.t)
   (voidP_cs_8_alloc_table : (alloc_table voidP)) (voidP_ct_9_alloc_table :
   (alloc_table voidP)) (voidP_ct_9_tag_table : (tag_table voidP))
   (voidP_cs_8_tag_table : (tag_table voidP)) (charP_charM_cs_8 : (memory
   voidP Int8.t)) (charP_charM_ct_9 : (memory voidP Int8.t)) 
   requires {
   (((Uint64.(>) count (#"strncmp.jc" 351 20 33# "expl:Integer cast"
     (Uint64.of_int (0))))
    /\
    ((forall i_17 : int.
      ((((<=) (0) i_17) /\
       ((<) i_17 (Uint64.to_int (strnlen cs count charP_charM_cs_8)))) ->
       (Bit_int8.(=) (select charP_charM_cs_8 (shift cs i_17))
       (select charP_charM_ct_9 (shift ct i_17)))))
    /\
    (Uint64.(<>) (strnlen cs count charP_charM_cs_8)
    (strnlen ct count charP_charM_ct_9))))
   /\
   (((allocated voidP_ct_9_alloc_table ct) ->
     (((=) (typeof voidP_ct_9_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_9_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_9_alloc_table ct))) ->
       ((=) (typeof voidP_ct_9_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_8_alloc_table cs) ->
     (((=) (typeof voidP_cs_8_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_8_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_8_alloc_table cs))) ->
       ((=) (typeof voidP_cs_8_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strncmp.jc" 334 12 105#
   ((#"/home/work/workdir/verker/strncmp.c" 3 13 34#
    (valid_strn cs count voidP_cs_8_alloc_table charP_charM_cs_8))
   /\
   (#"/home/work/workdir/verker/strncmp.c" 4 13 34#
   (valid_strn ct count voidP_ct_9_alloc_table charP_charM_ct_9))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workdir/verker/strncmp.c" 17 15 72# "expl:Ensures clause"
     (#"/home/work/workdir/verker/strncmp.c" 17 15 72# "expl:Ensures clause"
     ((#"/home/work/workdir/verker/strncmp.c" 17 15 72# "expl:Ensures clause"
      ((Uint64.(<) (strnlen cs count charP_charM_cs_8)
       (strnlen ct count charP_charM_ct_9)) ->
       (Bit_int32.(=) result (#"strncmp.jc" 359 45 61# "expl:Integer cast"
       (Bit_int32.of_int (Int.(-_) (1)))))))
     /\
     (#"/home/work/workdir/verker/strncmp.c" 18 15 71# "expl:Ensures clause"
     ((Uint64.(>) (strnlen cs count charP_charM_cs_8)
      (strnlen ct count charP_charM_ct_9)) ->
      (Bit_int32.(=) result (#"strncmp.jc" 362 46 58# "expl:Integer cast"
      (Bit_int32.of_int_const 1))))))))) } diverges  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   (let mutable_count = ref count in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let ocs = ref (any_pointer  () : (pointer voidP)) in
     (let oct = ref (any_pointer  () : (pointer voidP)) in
     (let ocount = ref (Unsafe_uint64.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       (ocs := !mutable_cs);
        begin
        (oct := !mutable_ct);
         begin
         (ocount := !mutable_count);
          begin
          any unit
          requires { true } reads { mutable_cs, mutable_ct }
          ensures {
            (#"/home/work/workdir/verker/strncmp.c" 36 12 123#
            (forall i_19 : int.
             ((((<=) (0) i_19) /\
              ((<) i_19
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) ->
              ((Bit_int8.(=)
               (select charP_charM_cs_8 (shift !mutable_cs i_19))
               (select charP_charM_ct_9 (shift !mutable_ct i_19)))
              <->
              (Bit_uint8.(=) (#"strncmp.jc" 500 56 82# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_cs_8 (shift !mutable_cs i_19))))
              (#"strncmp.jc" 501 57 83# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_ct_9 (shift !mutable_ct i_19))))))))) } ;
           () end;
          'Loop_3:
          loop
          invariant { (#"strncmp.jc" 505 6 9429# true) } 
           begin
           any unit
           requires { true } reads { mutable_count, mutable_cs, mutable_ct }
           ensures {
             ((#"/home/work/workdir/verker/strncmp.c" 47 20 83#
              (forall i_20 : int.
               ((((<=) (0) i_20) /\
                ((<) i_20
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count)))) ->
                (Bit_int8.(=) (select charP_charM_cs_8 (shift !ocs i_20))
                (select charP_charM_ct_9 (shift !oct i_20))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 46 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_ct !mutable_count charP_charM_ct_9))
              (Int.(-)
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
              (sub_pointer !mutable_ct !oct))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 45 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_cs !mutable_count charP_charM_cs_8))
              (Int.(-)
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
              (sub_pointer !mutable_cs !ocs))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              (#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              ((#"/home/work/workdir/verker/strncmp.c" 44 20 41#
               (valid_strn !mutable_cs !mutable_count voidP_cs_8_alloc_table
               charP_charM_cs_8))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 44 45 66#
              (valid_strn !mutable_ct !mutable_count voidP_ct_9_alloc_table
              charP_charM_ct_9)))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              (#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              ((#"/home/work/workdir/verker/strncmp.c" 43 20 40#
               ((=) (sub_pointer !mutable_cs !ocs)
               (sub_pointer !mutable_ct !oct)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 43 32 58#
              ((=) (sub_pointer !mutable_ct !oct)
              (Int.(-) (Uint64.to_int !ocount)
              (Uint64.to_int !mutable_count)))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               (same_block !oct !mutable_ct))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               ((<=) (sub_pointer !oct !mutable_ct) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 27 59#
               (same_block !mutable_ct
               (shift !oct
               (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 27 59#
              ((<=)
              (sub_pointer !mutable_ct
              (shift !oct
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))) (0))))))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               (same_block !ocs !mutable_cs))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               ((<=) (sub_pointer !ocs !mutable_cs) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 27 59#
               (same_block !mutable_cs
               (shift !ocs
               (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 27 59#
              ((<=)
              (sub_pointer !mutable_cs
              (shift !ocs
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) (0))))))))))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             ((#"/home/work/workdir/verker/strncmp.c" 40 20 30#
              (Uint64.(<=) (#"strncmp.jc" 507 38 51# "expl:Integer cast"
              (Uint64.of_int (0))) !mutable_count))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 25 40#
             (Uint64.(<=) !mutable_count !ocount)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workdir/verker/strncmp.c" 50 8 13#
             (Unsafe_uint64.(<>)  !mutable_count
              (#"strncmp.jc" 556 47 60# "expl:Integer cast"
              (Unsafe_uint64.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())));
              begin
              begin
              (tmp := !mutable_cs);
               begin
               (mutable_cs :=
                (shift_  !mutable_cs
                 (Unsafe_bit_int32.to_int 
                  (#"strncmp.jc" 561 48 60# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1)) ) ));
                (c1 :=
                 (#"/home/work/workdir/verker/strncmp.c" 51 23 51#
                 "expl:Integer cast"
                 (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                  (acc  charP_charM_cs_8 !tmp ) ))) end end;
               begin
               (tmp_0 := !mutable_ct);
                begin
                (mutable_ct :=
                 (shift_  !mutable_ct
                  (Unsafe_bit_int32.to_int 
                   (#"strncmp.jc" 566 48 60# "expl:Integer cast"
                   (Unsafe_bit_int32.of_int_const 1)) ) ));
                 (c2 :=
                  (#"/home/work/workdir/verker/strncmp.c" 52 23 51#
                  "expl:Integer cast"
                  (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                   (acc  charP_charM_ct_9 !tmp_0 ) ))) end end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 53 13 96#
                 ((Bit_uint8.(=) !c1 (#"strncmp.jc" 572 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !ocs voidP_cs_8_alloc_table charP_charM_cs_8)
                  /\
                  ((Uint64.(=) (strlen !ocs charP_charM_cs_8)
                   (strnlen !ocs !ocount charP_charM_cs_8))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 54 13 96#
                 ((Bit_uint8.(=) !c2 (#"strncmp.jc" 588 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !oct voidP_ct_9_alloc_table charP_charM_ct_9)
                  /\
                  ((Uint64.(=) (strlen !oct charP_charM_ct_9)
                   (strnlen !oct !ocount charP_charM_ct_9))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               (if
               (#"/home/work/workdir/verker/strncmp.c" 55 6 14#
               (Unsafe_bit_int32.(<>) 
                (#"/home/work/workdir/verker/strncmp.c" 55 6 8#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                (#"/home/work/workdir/verker/strncmp.c" 55 12 14#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
               then
                begin
                (if
                (#"/home/work/workdir/verker/strncmp.c" 56 23 30#
                (Unsafe_bit_int32.(<) 
                 (#"/home/work/workdir/verker/strncmp.c" 56 23 25#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                 (#"/home/work/workdir/verker/strncmp.c" 56 28 30#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                then
                 (tmp_1 :=
                  (#"strncmp.jc" 604 82 95# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                else
                 (tmp_1 :=
                  (#"strncmp.jc" 605 36 48# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1))));
                 begin
                 (res := !tmp_1); begin (); () end;
                  (if
                  (#"/home/work/workdir/verker/strncmp.c" 64 10 17#
                  (Unsafe_bit_int32.(<) 
                   (#"/home/work/workdir/verker/strncmp.c" 64 10 12#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                   (#"/home/work/workdir/verker/strncmp.c" 64 15 17#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                  then
                   (tmp_2 :=
                    (#"strncmp.jc" 641 82 95# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                  else
                   (tmp_2 :=
                    (#"strncmp.jc" 642 36 48# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int_const 1))));
                  begin (__retres := !tmp_2); (raise (Return_label_exc ()))
                  end end end else ());
               (if
               (#"/home/work/workdir/verker/strncmp.c" 65 6 9#
               (Bool.notb 
                (Unsafe_bit_uint8.(<>)  !c1
                 (#"strncmp.jc" 649 50 62# "expl:Integer cast"
                 (Unsafe_bit_uint8.of_int_const 0)) ) ))
               then (raise (Goto_while_0_break_exc ())) else ());
               begin
               (mutable_count :=
                (Unsafe_uint64.(-)  !mutable_count
                 (#"strncmp.jc" 652 57 70# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) ));
                begin
                any unit
                requires { true } reads { mutable_cs }
                ensures {
                  (#"/home/work/workdir/verker/strncmp.c" 68 13 51#
                  (Bit_int8.(=)
                  (select charP_charM_cs_8
                  (shift !ocs (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))
                  (select charP_charM_ct_9
                  (shift !oct (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))))
                  } ; () end end end end; (raise (Loop_continue_exc ())) end
             with Loop_continue_exc _jessie_4 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strncmp.jc" 667 28 40# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end)))))))))));
     absurd  end with Return -> !return end))))
  
  let strncmp_ensures_not_equal
  #"/home/work/workdir/verker/strncmp.c" 29 4 57#
  "expl:Function strncmp, behavior not_equal" =
  fun
   (cs : (pointer voidP)) (ct : (pointer voidP)) (count : Uint64.t)
   (voidP_cs_8_alloc_table : (alloc_table voidP)) (voidP_ct_9_alloc_table :
   (alloc_table voidP)) (voidP_ct_9_tag_table : (tag_table voidP))
   (voidP_cs_8_tag_table : (tag_table voidP)) (charP_charM_cs_8 : (memory
   voidP Int8.t)) (charP_charM_ct_9 : (memory voidP Int8.t)) 
   requires {
   (((Uint64.(>) count (#"strncmp.jc" 364 20 33# "expl:Integer cast"
     (Uint64.of_int (0))))
    /\
    (exists i_15 : int.
     (((<=) (0) i_15) /\
     (((<) i_15 (Uint64.to_int (strnlen cs count charP_charM_cs_8))) /\
     (Bit_int8.(<>) (select charP_charM_cs_8 (shift cs i_15))
     (select charP_charM_ct_9 (shift ct i_15)))))))
   /\
   (((allocated voidP_ct_9_alloc_table ct) ->
     (((=) (typeof voidP_ct_9_tag_table ct) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_ct_9_alloc_table ct) i) /\
       ((<) i (offset_max voidP_ct_9_alloc_table ct))) ->
       ((=) (typeof voidP_ct_9_tag_table (shift ct i)) charP_tag)))))
   /\
   (((allocated voidP_cs_8_alloc_table cs) ->
     (((=) (typeof voidP_cs_8_tag_table cs) charP_tag) /\
     (forall i : int.
      ((((<=) (offset_min voidP_cs_8_alloc_table cs) i) /\
       ((<) i (offset_max voidP_cs_8_alloc_table cs))) ->
       ((=) (typeof voidP_cs_8_tag_table (shift cs i)) charP_tag)))))
   /\
   (#"strncmp.jc" 334 12 105#
   ((#"/home/work/workdir/verker/strncmp.c" 3 13 34#
    (valid_strn cs count voidP_cs_8_alloc_table charP_charM_cs_8))
   /\
   (#"/home/work/workdir/verker/strncmp.c" 4 13 34#
   (valid_strn ct count voidP_ct_9_alloc_table charP_charM_ct_9))))))) }
   ensures {
     ("expl:Postcondition"
     (#"/home/work/workdir/verker/strncmp.c" 22 15 242# "expl:Ensures clause"
     (exists i_16 : int.
      (((<=) (0) i_16) /\
      (((<) i_16 (Uint64.to_int (strnlen cs count charP_charM_cs_8))) /\
      ((forall j : int.
        ((((<=) (0) j) /\ ((<) j i_16)) ->
         (Bit_int8.(=) (select charP_charM_cs_8 (shift cs j))
         (select charP_charM_ct_9 (shift ct j)))))
      /\
      ((Bit_int8.(<>) (select charP_charM_cs_8 (shift cs i_16))
       (select charP_charM_ct_9 (shift ct i_16)))
      /\
      (if
       (Bit_uint8.(<) (#"strncmp.jc" 379 29 67# "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_cs_8 (shift cs i_16)))) (#"strncmp.jc" 380 30 68#
       "expl:Integer cast"
       (Bit_uint8_of_Bit_int8.cast_modulo
       (select charP_charM_ct_9 (shift ct i_16))))) then
       (Bit_int32.(=) result (#"strncmp.jc" 382 26 42# "expl:Integer cast"
       (Bit_int32.of_int (Int.(-_) (1))))) else
       (Bit_int32.(=) result (#"strncmp.jc" 382 61 73# "expl:Integer cast"
       (Bit_int32.of_int_const 1))))))))))) } diverges  ->
   (let mutable_cs = ref cs in
   (let mutable_ct = ref ct in
   (let mutable_count = ref count in
   'Init:
   (let return = ref (Unsafe_bit_int32.any_  () ) in
   try
    begin
    (); (); (); ();
     (let c1 = ref (Unsafe_bit_uint8.any_  () ) in
     (let c2 = ref (Unsafe_bit_uint8.any_  () ) in
     (let ocs = ref (any_pointer  () : (pointer voidP)) in
     (let oct = ref (any_pointer  () : (pointer voidP)) in
     (let ocount = ref (Unsafe_uint64.any_  () ) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let tmp_0 = ref (any_pointer  () : (pointer voidP)) in
     (let res = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_1 = ref (Unsafe_bit_int32.any_  () ) in
     (let tmp_2 = ref (Unsafe_bit_int32.any_  () ) in
     (let __retres = ref (Unsafe_bit_int32.any_  () ) in
     try
      begin
      try
       begin
       (ocs := !mutable_cs);
        begin
        (oct := !mutable_ct);
         begin
         (ocount := !mutable_count);
          begin
          any unit
          requires { true } reads { mutable_cs, mutable_ct }
          ensures {
            (#"/home/work/workdir/verker/strncmp.c" 36 12 123#
            (forall i_19 : int.
             ((((<=) (0) i_19) /\
              ((<) i_19
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) ->
              ((Bit_int8.(=)
               (select charP_charM_cs_8 (shift !mutable_cs i_19))
               (select charP_charM_ct_9 (shift !mutable_ct i_19)))
              <->
              (Bit_uint8.(=) (#"strncmp.jc" 500 56 82# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_cs_8 (shift !mutable_cs i_19))))
              (#"strncmp.jc" 501 57 83# "expl:Integer cast"
              (Bit_uint8_of_Bit_int8.cast_modulo
              (select charP_charM_ct_9 (shift !mutable_ct i_19))))))))) } ;
           () end;
          'Loop_4:
          loop
          invariant { (#"strncmp.jc" 505 6 9429# true) } 
           begin
           any unit
           requires { true } reads { mutable_count, mutable_cs, mutable_ct }
           ensures {
             ((#"/home/work/workdir/verker/strncmp.c" 47 20 83#
              (forall i_20 : int.
               ((((<=) (0) i_20) /\
                ((<) i_20
                (Int.(-) (Uint64.to_int !ocount)
                (Uint64.to_int !mutable_count)))) ->
                (Bit_int8.(=) (select charP_charM_cs_8 (shift !ocs i_20))
                (select charP_charM_ct_9 (shift !oct i_20))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 46 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_ct !mutable_count charP_charM_ct_9))
              (Int.(-)
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
              (sub_pointer !mutable_ct !oct))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 45 20 75#
              ((=)
              (Uint64.to_int
              (strnlen !mutable_cs !mutable_count charP_charM_cs_8))
              (Int.(-)
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
              (sub_pointer !mutable_cs !ocs))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              (#"/home/work/workdir/verker/strncmp.c" 44 20 66#
              ((#"/home/work/workdir/verker/strncmp.c" 44 20 41#
               (valid_strn !mutable_cs !mutable_count voidP_cs_8_alloc_table
               charP_charM_cs_8))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 44 45 66#
              (valid_strn !mutable_ct !mutable_count voidP_ct_9_alloc_table
              charP_charM_ct_9)))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              (#"/home/work/workdir/verker/strncmp.c" 43 20 58#
              ((#"/home/work/workdir/verker/strncmp.c" 43 20 40#
               ((=) (sub_pointer !mutable_cs !ocs)
               (sub_pointer !mutable_ct !oct)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 43 32 58#
              ((=) (sub_pointer !mutable_ct !oct)
              (Int.(-) (Uint64.to_int !ocount)
              (Uint64.to_int !mutable_count)))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               (same_block !oct !mutable_ct))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 20 29#
               ((<=) (sub_pointer !oct !mutable_ct) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 42 27 59#
               (same_block !mutable_ct
               (shift !oct
               (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 42 27 59#
              ((<=)
              (sub_pointer !mutable_ct
              (shift !oct
              (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9)))) (0))))))))))
             /\
             ((#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               (same_block !ocs !mutable_cs))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 20 29#
               ((<=) (sub_pointer !ocs !mutable_cs) (0)))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 20 59#
              ((#"/home/work/workdir/verker/strncmp.c" 41 27 59#
               (same_block !mutable_cs
               (shift !ocs
               (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))))
              /\
              (#"/home/work/workdir/verker/strncmp.c" 41 27 59#
              ((<=)
              (sub_pointer !mutable_cs
              (shift !ocs
              (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))) (0))))))))))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             (#"/home/work/workdir/verker/strncmp.c" 40 20 40#
             ((#"/home/work/workdir/verker/strncmp.c" 40 20 30#
              (Uint64.(<=) (#"strncmp.jc" 507 38 51# "expl:Integer cast"
              (Uint64.of_int (0))) !mutable_count))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 40 25 40#
             (Uint64.(<=) !mutable_count !ocount)))))))))))) } ;
            try
             begin
             begin
             (if
             (#"/home/work/workdir/verker/strncmp.c" 50 8 13#
             (Unsafe_uint64.(<>)  !mutable_count
              (#"strncmp.jc" 556 47 60# "expl:Integer cast"
              (Unsafe_uint64.of_int (0))) )) then ()
             else (raise (Goto_while_0_break_exc ())));
              begin
              begin
              (tmp := !mutable_cs);
               begin
               (mutable_cs :=
                (shift_  !mutable_cs
                 (Unsafe_bit_int32.to_int 
                  (#"strncmp.jc" 561 48 60# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1)) ) ));
                (c1 :=
                 (#"/home/work/workdir/verker/strncmp.c" 51 23 51#
                 "expl:Integer cast"
                 (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                  (acc  charP_charM_cs_8 !tmp ) ))) end end;
               begin
               (tmp_0 := !mutable_ct);
                begin
                (mutable_ct :=
                 (shift_  !mutable_ct
                  (Unsafe_bit_int32.to_int 
                   (#"strncmp.jc" 566 48 60# "expl:Integer cast"
                   (Unsafe_bit_int32.of_int_const 1)) ) ));
                 (c2 :=
                  (#"/home/work/workdir/verker/strncmp.c" 52 23 51#
                  "expl:Integer cast"
                  (Unsafe_bit_uint8_of_Unsafe_bit_int8.cast_modulo 
                   (acc  charP_charM_ct_9 !tmp_0 ) ))) end end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 53 13 96#
                 ((Bit_uint8.(=) !c1 (#"strncmp.jc" 572 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !ocs voidP_cs_8_alloc_table charP_charM_cs_8)
                  /\
                  ((Uint64.(=) (strlen !ocs charP_charM_cs_8)
                   (strnlen !ocs !ocount charP_charM_cs_8))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               begin
               any unit
               requires { true } reads { mutable_count }
               ensures {
                 (#"/home/work/workdir/verker/strncmp.c" 54 13 96#
                 ((Bit_uint8.(=) !c2 (#"strncmp.jc" 588 61 73#
                  "expl:Integer cast" (Bit_uint8.of_int_const 0))) ->
                  ((valid_str !oct voidP_ct_9_alloc_table charP_charM_ct_9)
                  /\
                  ((Uint64.(=) (strlen !oct charP_charM_ct_9)
                   (strnlen !oct !ocount charP_charM_ct_9))
                  /\
                  ((=)
                  (Uint64.to_int (strnlen !oct !ocount charP_charM_ct_9))
                  (Int.(-) (Uint64.to_int !ocount)
                  (Uint64.to_int !mutable_count))))))) } ; () end;
               (if
               (#"/home/work/workdir/verker/strncmp.c" 55 6 14#
               (Unsafe_bit_int32.(<>) 
                (#"/home/work/workdir/verker/strncmp.c" 55 6 8#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                (#"/home/work/workdir/verker/strncmp.c" 55 12 14#
                "expl:Integer cast"
                (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
               then
                begin
                (if
                (#"/home/work/workdir/verker/strncmp.c" 56 23 30#
                (Unsafe_bit_int32.(<) 
                 (#"/home/work/workdir/verker/strncmp.c" 56 23 25#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                 (#"/home/work/workdir/verker/strncmp.c" 56 28 30#
                 "expl:Integer cast"
                 (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                then
                 (tmp_1 :=
                  (#"strncmp.jc" 604 82 95# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                else
                 (tmp_1 :=
                  (#"strncmp.jc" 605 36 48# "expl:Integer cast"
                  (Unsafe_bit_int32.of_int_const 1))));
                 begin
                 (res := !tmp_1);
                  begin
                  (assert {
                  (#"/home/work/workdir/verker/strncmp.c" 58 11 234#
                  "expl:Assertion in line 58"
                  (exists i_21 : int.
                   (((<=) (0) i_21) /\
                   (((<) i_21
                    (Uint64.to_int (strnlen !ocs !ocount charP_charM_cs_8)))
                   /\
                   ((forall j_0 : int.
                     ((((<=) (0) j_0) /\ ((<) j_0 i_21)) ->
                      (Bit_int8.(=)
                      (select charP_charM_cs_8 (shift !ocs j_0))
                      (select charP_charM_ct_9 (shift !oct j_0)))))
                   /\
                   ((Bit_int8.(<>)
                    (select charP_charM_cs_8 (shift !ocs i_21))
                    (select charP_charM_ct_9 (shift !oct i_21)))
                   /\
                   ((if
                     (Bit_uint8.(<) (#"strncmp.jc" 627 69 164#
                     "expl:Integer cast"
                     (Bit_uint8_of_Bit_int8.cast_modulo
                     (select charP_charM_cs_8 (shift !ocs i_21))))
                     (#"strncmp.jc" 629 68 163# "expl:Integer cast"
                     (Bit_uint8_of_Bit_int8.cast_modulo
                     (select charP_charM_ct_9 (shift !oct i_21))))) then
                     (Bit_int32.(=) !res (#"strncmp.jc" 632 68 84#
                     "expl:Integer cast" (Bit_int32.of_int (Int.(-_) (1)))))
                     else
                     (Bit_int32.(=) !res (#"strncmp.jc" 634 68 80#
                     "expl:Integer cast" (Bit_int32.of_int_const 1))))
                   /\
                   ((=) i_21
                   (Int.(-) (Uint64.to_int !ocount)
                   (Uint64.to_int !mutable_count)))))))))) }); () end;
                  (if
                  (#"/home/work/workdir/verker/strncmp.c" 64 10 17#
                  (Unsafe_bit_int32.(<) 
                   (#"/home/work/workdir/verker/strncmp.c" 64 10 12#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c1 ))
                   (#"/home/work/workdir/verker/strncmp.c" 64 15 17#
                   "expl:Integer cast"
                   (Unsafe_bit_int32_of_Unsafe_bit_uint8.cast  !c2 )) ))
                  then
                   (tmp_2 :=
                    (#"strncmp.jc" 641 82 95# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int  (Int.(-_)  (1) ) )))
                  else
                   (tmp_2 :=
                    (#"strncmp.jc" 642 36 48# "expl:Integer cast"
                    (Unsafe_bit_int32.of_int_const 1))));
                  begin (__retres := !tmp_2); (raise (Return_label_exc ()))
                  end end end else ());
               (if
               (#"/home/work/workdir/verker/strncmp.c" 65 6 9#
               (Bool.notb 
                (Unsafe_bit_uint8.(<>)  !c1
                 (#"strncmp.jc" 649 50 62# "expl:Integer cast"
                 (Unsafe_bit_uint8.of_int_const 0)) ) ))
               then (raise (Goto_while_0_break_exc ())) else ());
               begin
               (mutable_count :=
                (Unsafe_uint64.(-)  !mutable_count
                 (#"strncmp.jc" 652 57 70# "expl:Integer cast"
                 (Unsafe_uint64.of_int (1))) ));
                begin
                any unit
                requires { true } reads { mutable_cs }
                ensures {
                  (#"/home/work/workdir/verker/strncmp.c" 68 13 51#
                  (Bit_int8.(=)
                  (select charP_charM_cs_8
                  (shift !ocs (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))
                  (select charP_charM_ct_9
                  (shift !oct (Int.(-) (sub_pointer !mutable_cs !ocs) (1))))))
                  } ; () end end end end; (raise (Loop_continue_exc ())) end
             with Loop_continue_exc _jessie_4 -> () end end end;
          (raise (Goto_while_0_break_exc ())) end end end with
       Goto_while_0_break_exc _jessie_1 ->
       'While_0_break:
       'While_0_break:
       begin
       ();
        (__retres :=
         (#"strncmp.jc" 667 28 40# "expl:Integer cast"
         (Unsafe_bit_int32.of_int_const 0))) end end;
       (raise (Return_label_exc ())) end with Return_label_exc _jessie_2 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end)))))))))));
     absurd  end with Return -> !return end))))
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_strlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires { true }
     ensures {
       (#"/home/work/workdir/verker/strlen.h" 82 12 32# "expl:Ensures clause"
       (#"/home/work/workdir/verker/strlen.h" 82 12 32# "expl:Ensures clause"
       ((#"/home/work/workdir/verker/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workdir/verker/strlen.h" 82 12 32# "expl:Ensures clause"
       ((#"/home/work/workdir/verker/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strncmp.jc" 120 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workdir/verker/strlen.h" 84 12 64# "expl:Ensures clause"
       (forall i_5 : int.
        ((((<=) (0) i_5) /\ ((<) i_5 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_5))
         (#"strncmp.jc" 124 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires {
       ("expl:External"
       (#"/home/work/workdir/verker/strlen.h" 80 13 25#
       "expl:Requires clause"
       (valid_str s_0 voidP_s_4_alloc_table charP_charM_s_4))) }
     ensures {
       (#"/home/work/workdir/verker/strlen.h" 82 12 32# "expl:Ensures clause"
       (#"/home/work/workdir/verker/strlen.h" 82 12 32# "expl:Ensures clause"
       ((#"/home/work/workdir/verker/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workdir/verker/strlen.h" 82 12 32# "expl:Ensures clause"
       ((#"/home/work/workdir/verker/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strncmp.jc" 120 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workdir/verker/strlen.h" 84 12 64# "expl:Ensures clause"
       (forall i_5 : int.
        ((((<=) (0) i_5) /\ ((<) i_5 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_5))
         (#"strncmp.jc" 124 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strnlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strnlen 
  
  use why3.Bool.Bool 
  
  val strnlen_0
  (s_0_0 : (pointer voidP)) 
   (count_0 : Uint64.t) 
    (voidP_s_0_7_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_0_7 : (memory voidP Int8.t)) : Uint64.t
      requires { true }
      ensures {
        (((forall i_12 : int.
           ((((<=) (0) i_12) /\ ((<=) i_12 (Uint64.to_int count_0))) ->
            (Int8.(<>) (select charP_charM_s_0_7 (shift s_0_0 i_12))
            (#"strncmp.jc" 329 37 48# "expl:Integer cast" (Int8.of_int (0))))))
          ->
          (#"/home/work/workdir/verker/strnlen.h" 122 15 31#
          "expl:Ensures clause" (Uint64.(=) result count_0)))
        /\
        (((exists i_13 : int.
           (((<=) (0) i_13) /\
           (((<=) i_13 (Uint64.to_int count_0)) /\
           (Int8.(=) (select charP_charM_s_0_7 (shift s_0_0 i_13))
           (#"strncmp.jc" 318 37 48# "expl:Integer cast" (Int8.of_int (0)))))))
          ->
          (#"/home/work/workdir/verker/strnlen.h" 118 15 33#
          "expl:Ensures clause"
          (#"/home/work/workdir/verker/strnlen.h" 118 15 33#
          "expl:Ensures clause"
          ((#"/home/work/workdir/verker/strnlen.h" 118 15 33#
           "expl:Ensures clause"
           (Int8.(=)
           (select charP_charM_s_0_7 (shift s_0_0 (Uint64.to_int result)))
           (#"strncmp.jc" 320 31 42# "expl:Integer cast" (Int8.of_int (0)))))
          /\
          (#"/home/work/workdir/verker/strnlen.h" 119 15 67#
          "expl:Ensures clause"
          (forall i_14 : int.
           ((((<=) (0) i_14) /\ ((<) i_14 (Uint64.to_int result))) ->
            (Int8.(<>) (select charP_charM_s_0_7 (shift s_0_0 i_14))
            (#"strncmp.jc" 325 36 47# "expl:Integer cast" (Int8.of_int (0)))))))))))
        /\
        (#"/home/work/workdir/verker/strnlen.h" 115 12 40#
        "expl:Ensures clause"
        (Uint64.(=) result (strnlen s_0_0 count_0 charP_charM_s_0_7))))) }
  
end

module Function_strnlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strnlen 
  
  use why3.Bool.Bool 
  
  val strnlen_0
  (s_0_0 : (pointer voidP)) 
   (count_0 : Uint64.t) 
    (voidP_s_0_7_alloc_table : (alloc_table voidP)) 
     (charP_charM_s_0_7 : (memory voidP Int8.t)) : Uint64.t
      requires {
        ("expl:External"
        (#"/home/work/workdir/verker/strnlen.h" 113 13 33#
        "expl:Requires clause"
        (valid_strn s_0_0 count_0 voidP_s_0_7_alloc_table charP_charM_s_0_7)))
        }
      ensures {
        (((forall i_12 : int.
           ((((<=) (0) i_12) /\ ((<=) i_12 (Uint64.to_int count_0))) ->
            (Int8.(<>) (select charP_charM_s_0_7 (shift s_0_0 i_12))
            (#"strncmp.jc" 329 37 48# "expl:Integer cast" (Int8.of_int (0))))))
          ->
          (#"/home/work/workdir/verker/strnlen.h" 122 15 31#
          "expl:Ensures clause" (Uint64.(=) result count_0)))
        /\
        (((exists i_13 : int.
           (((<=) (0) i_13) /\
           (((<=) i_13 (Uint64.to_int count_0)) /\
           (Int8.(=) (select charP_charM_s_0_7 (shift s_0_0 i_13))
           (#"strncmp.jc" 318 37 48# "expl:Integer cast" (Int8.of_int (0)))))))
          ->
          (#"/home/work/workdir/verker/strnlen.h" 118 15 33#
          "expl:Ensures clause"
          (#"/home/work/workdir/verker/strnlen.h" 118 15 33#
          "expl:Ensures clause"
          ((#"/home/work/workdir/verker/strnlen.h" 118 15 33#
           "expl:Ensures clause"
           (Int8.(=)
           (select charP_charM_s_0_7 (shift s_0_0 (Uint64.to_int result)))
           (#"strncmp.jc" 320 31 42# "expl:Integer cast" (Int8.of_int (0)))))
          /\
          (#"/home/work/workdir/verker/strnlen.h" 119 15 67#
          "expl:Ensures clause"
          (forall i_14 : int.
           ((((<=) (0) i_14) /\ ((<) i_14 (Uint64.to_int result))) ->
            (Int8.(<>) (select charP_charM_s_0_7 (shift s_0_0 i_14))
            (#"strncmp.jc" 325 36 47# "expl:Integer cast" (Int8.of_int (0)))))))))))
        /\
        (#"/home/work/workdir/verker/strnlen.h" 115 12 40#
        "expl:Ensures clause"
        (Uint64.(=) result (strnlen s_0_0 count_0 charP_charM_s_0_7))))) }
  
end

module Function_strncmp

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use import Axiomatic_Strnlen 
  
  use why3.Bool.Bool 
  
  val strncmp
  (cs : (pointer voidP)) 
   (ct : (pointer voidP)) 
    (count : Uint64.t) 
     (voidP_ct_9_alloc_table : (alloc_table voidP)) 
      (voidP_cs_8_alloc_table : (alloc_table voidP)) 
       (voidP_ct_9_tag_table : (tag_table voidP)) 
        (voidP_cs_8_tag_table : (tag_table voidP)) 
         (charP_charM_ct_9 : (memory voidP Int8.t)) 
          (charP_charM_cs_8 : (memory voidP Int8.t)) : Int32.t
           requires { true }
           ensures {
             ((((Uint64.(>) count (#"strncmp.jc" 364 20 33#
                "expl:Integer cast" (Uint64.of_int (0))))
               /\
               (exists i_15 : int.
                (((<=) (0) i_15) /\
                (((<) i_15
                 (Uint64.to_int (strnlen cs count charP_charM_cs_8)))
                /\
                (Bit_int8.(<>) (select charP_charM_cs_8 (shift cs i_15))
                (select charP_charM_ct_9 (shift ct i_15))))))) ->
               (#"/home/work/workdir/verker/strncmp.c" 22 15 242#
               "expl:Ensures clause"
               (exists i_16 : int.
                (((<=) (0) i_16) /\
                (((<) i_16
                 (Uint64.to_int (strnlen cs count charP_charM_cs_8)))
                /\
                ((forall j : int.
                  ((((<=) (0) j) /\ ((<) j i_16)) ->
                   (Bit_int8.(=) (select charP_charM_cs_8 (shift cs j))
                   (select charP_charM_ct_9 (shift ct j)))))
                /\
                ((Bit_int8.(<>) (select charP_charM_cs_8 (shift cs i_16))
                 (select charP_charM_ct_9 (shift ct i_16)))
                /\
                (if
                 (Bit_uint8.(<) (#"strncmp.jc" 379 29 67# "expl:Integer cast"
                 (Bit_uint8_of_Bit_int8.cast_modulo
                 (select charP_charM_cs_8 (shift cs i_16))))
                 (#"strncmp.jc" 380 30 68# "expl:Integer cast"
                 (Bit_uint8_of_Bit_int8.cast_modulo
                 (select charP_charM_ct_9 (shift ct i_16))))) then
                 (Int32.(=) result (#"strncmp.jc" 382 26 42#
                 "expl:Integer cast" (Int32.of_int (Int.(-_) (1))))) else
                 (Int32.(=) result (#"strncmp.jc" 382 61 73#
                 "expl:Integer cast" (Int32.of_int (1))))))))))))
             /\
             ((((Uint64.(>) count (#"strncmp.jc" 351 20 33#
                "expl:Integer cast" (Uint64.of_int (0))))
               /\
               ((forall i_17 : int.
                 ((((<=) (0) i_17) /\
                  ((<) i_17
                  (Uint64.to_int (strnlen cs count charP_charM_cs_8)))) ->
                  (Bit_int8.(=) (select charP_charM_cs_8 (shift cs i_17))
                  (select charP_charM_ct_9 (shift ct i_17)))))
               /\
               (Uint64.(<>) (strnlen cs count charP_charM_cs_8)
               (strnlen ct count charP_charM_ct_9)))) ->
               (#"/home/work/workdir/verker/strncmp.c" 17 15 72#
               "expl:Ensures clause"
               (#"/home/work/workdir/verker/strncmp.c" 17 15 72#
               "expl:Ensures clause"
               ((#"/home/work/workdir/verker/strncmp.c" 17 15 72#
                "expl:Ensures clause"
                ((Uint64.(<) (strnlen cs count charP_charM_cs_8)
                 (strnlen ct count charP_charM_ct_9)) ->
                 (Int32.(=) result (#"strncmp.jc" 359 45 61#
                 "expl:Integer cast" (Int32.of_int (Int.(-_) (1)))))))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 18 15 71#
               "expl:Ensures clause"
               ((Uint64.(>) (strnlen cs count charP_charM_cs_8)
                (strnlen ct count charP_charM_ct_9)) ->
                (Int32.(=) result (#"strncmp.jc" 362 46 58#
                "expl:Integer cast" (Int32.of_int (1))))))))))
             /\
             ((((Uint64.(=) count (#"strncmp.jc" 342 21 34#
                "expl:Integer cast" (Uint64.of_int (0))))
               \/
               ((Uint64.(>) count (#"strncmp.jc" 343 23 36#
                "expl:Integer cast" (Uint64.of_int (0))))
               /\
               ((forall i_18 : int.
                 ((((<=) (0) i_18) /\
                  ((<) i_18
                  (Uint64.to_int (strnlen cs count charP_charM_cs_8)))) ->
                  (Bit_int8.(=) (select charP_charM_cs_8 (shift cs i_18))
                  (select charP_charM_ct_9 (shift ct i_18)))))
               /\
               (Uint64.(=) (strnlen cs count charP_charM_cs_8)
               (strnlen ct count charP_charM_ct_9))))) ->
               (#"/home/work/workdir/verker/strncmp.c" 12 15 27#
               "expl:Ensures clause"
               (Int32.(=) result (#"strncmp.jc" 349 32 44#
               "expl:Integer cast" (Int32.of_int (0))))))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 6 12 57#
             "expl:Ensures clause"
             ((Int32.(=) result (#"strncmp.jc" 338 34 50# "expl:Integer cast"
              (Int32.of_int (Int.(-_) (1)))))
             \/
             ((Int32.(=) result (#"strncmp.jc" 339 35 47# "expl:Integer cast"
              (Int32.of_int (0))))
             \/
             (Int32.(=) result (#"strncmp.jc" 340 34 46# "expl:Integer cast"
             (Int32.of_int (1)))))))))) }
  
end

module Function_strncmp_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use enum.Int32 
  
  use import int.Int 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use enum.Bit_int8 
  
  use import Axiomatic_Strnlen 
  
  use why3.Bool.Bool 
  
  val strncmp
  (cs : (pointer voidP)) 
   (ct : (pointer voidP)) 
    (count : Uint64.t) 
     (voidP_ct_9_alloc_table : (alloc_table voidP)) 
      (voidP_cs_8_alloc_table : (alloc_table voidP)) 
       (voidP_ct_9_tag_table : (tag_table voidP)) 
        (voidP_cs_8_tag_table : (tag_table voidP)) 
         (charP_charM_ct_9 : (memory voidP Int8.t)) 
          (charP_charM_cs_8 : (memory voidP Int8.t)) : Int32.t
           requires {
             ("expl:Internal"
             (#"strncmp.jc" 334 12 105# "expl:Requires clause"
             ((#"/home/work/workdir/verker/strncmp.c" 3 13 34#
              "expl:Requires clause"
              (valid_strn cs count voidP_cs_8_alloc_table charP_charM_cs_8))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 4 13 34#
             "expl:Requires clause"
             (valid_strn ct count voidP_ct_9_alloc_table charP_charM_ct_9)))))
             }
           ensures {
             ((((Uint64.(>) count (#"strncmp.jc" 364 20 33#
                "expl:Integer cast" (Uint64.of_int (0))))
               /\
               (exists i_15 : int.
                (((<=) (0) i_15) /\
                (((<) i_15
                 (Uint64.to_int (strnlen cs count charP_charM_cs_8)))
                /\
                (Bit_int8.(<>) (select charP_charM_cs_8 (shift cs i_15))
                (select charP_charM_ct_9 (shift ct i_15))))))) ->
               (#"/home/work/workdir/verker/strncmp.c" 22 15 242#
               "expl:Ensures clause"
               (exists i_16 : int.
                (((<=) (0) i_16) /\
                (((<) i_16
                 (Uint64.to_int (strnlen cs count charP_charM_cs_8)))
                /\
                ((forall j : int.
                  ((((<=) (0) j) /\ ((<) j i_16)) ->
                   (Bit_int8.(=) (select charP_charM_cs_8 (shift cs j))
                   (select charP_charM_ct_9 (shift ct j)))))
                /\
                ((Bit_int8.(<>) (select charP_charM_cs_8 (shift cs i_16))
                 (select charP_charM_ct_9 (shift ct i_16)))
                /\
                (if
                 (Bit_uint8.(<) (#"strncmp.jc" 379 29 67# "expl:Integer cast"
                 (Bit_uint8_of_Bit_int8.cast_modulo
                 (select charP_charM_cs_8 (shift cs i_16))))
                 (#"strncmp.jc" 380 30 68# "expl:Integer cast"
                 (Bit_uint8_of_Bit_int8.cast_modulo
                 (select charP_charM_ct_9 (shift ct i_16))))) then
                 (Int32.(=) result (#"strncmp.jc" 382 26 42#
                 "expl:Integer cast" (Int32.of_int (Int.(-_) (1))))) else
                 (Int32.(=) result (#"strncmp.jc" 382 61 73#
                 "expl:Integer cast" (Int32.of_int (1))))))))))))
             /\
             ((((Uint64.(>) count (#"strncmp.jc" 351 20 33#
                "expl:Integer cast" (Uint64.of_int (0))))
               /\
               ((forall i_17 : int.
                 ((((<=) (0) i_17) /\
                  ((<) i_17
                  (Uint64.to_int (strnlen cs count charP_charM_cs_8)))) ->
                  (Bit_int8.(=) (select charP_charM_cs_8 (shift cs i_17))
                  (select charP_charM_ct_9 (shift ct i_17)))))
               /\
               (Uint64.(<>) (strnlen cs count charP_charM_cs_8)
               (strnlen ct count charP_charM_ct_9)))) ->
               (#"/home/work/workdir/verker/strncmp.c" 17 15 72#
               "expl:Ensures clause"
               (#"/home/work/workdir/verker/strncmp.c" 17 15 72#
               "expl:Ensures clause"
               ((#"/home/work/workdir/verker/strncmp.c" 17 15 72#
                "expl:Ensures clause"
                ((Uint64.(<) (strnlen cs count charP_charM_cs_8)
                 (strnlen ct count charP_charM_ct_9)) ->
                 (Int32.(=) result (#"strncmp.jc" 359 45 61#
                 "expl:Integer cast" (Int32.of_int (Int.(-_) (1)))))))
               /\
               (#"/home/work/workdir/verker/strncmp.c" 18 15 71#
               "expl:Ensures clause"
               ((Uint64.(>) (strnlen cs count charP_charM_cs_8)
                (strnlen ct count charP_charM_ct_9)) ->
                (Int32.(=) result (#"strncmp.jc" 362 46 58#
                "expl:Integer cast" (Int32.of_int (1))))))))))
             /\
             ((((Uint64.(=) count (#"strncmp.jc" 342 21 34#
                "expl:Integer cast" (Uint64.of_int (0))))
               \/
               ((Uint64.(>) count (#"strncmp.jc" 343 23 36#
                "expl:Integer cast" (Uint64.of_int (0))))
               /\
               ((forall i_18 : int.
                 ((((<=) (0) i_18) /\
                  ((<) i_18
                  (Uint64.to_int (strnlen cs count charP_charM_cs_8)))) ->
                  (Bit_int8.(=) (select charP_charM_cs_8 (shift cs i_18))
                  (select charP_charM_ct_9 (shift ct i_18)))))
               /\
               (Uint64.(=) (strnlen cs count charP_charM_cs_8)
               (strnlen ct count charP_charM_ct_9))))) ->
               (#"/home/work/workdir/verker/strncmp.c" 12 15 27#
               "expl:Ensures clause"
               (Int32.(=) result (#"strncmp.jc" 349 32 44#
               "expl:Integer cast" (Int32.of_int (0))))))
             /\
             (#"/home/work/workdir/verker/strncmp.c" 6 12 57#
             "expl:Ensures clause"
             ((Int32.(=) result (#"strncmp.jc" 338 34 50# "expl:Integer cast"
              (Int32.of_int (Int.(-_) (1)))))
             \/
             ((Int32.(=) result (#"strncmp.jc" 339 35 47# "expl:Integer cast"
              (Int32.of_int (0))))
             \/
             (Int32.(=) result (#"strncmp.jc" 340 34 46# "expl:Integer cast"
             (Int32.of_int (1)))))))))) }
  
end
