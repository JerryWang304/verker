
theory Axiomatic_Padding 
                           use why3.Bool.Bool 
                           
end

theory Int32_of_Int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int32.t = (Int32.of_int (Int16.to_int n))
  
end

theory Bit_int32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int32_of_Int16
  
  use export enum.Bit_int32_of_bit_int16
  
end

theory Int64_of_Int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int64.t = (Int64.of_int (Int16.to_int n))
  
end

theory Bit_int64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int64_of_Int16
  
  use export enum.Bit_int64_of_bit_int16
  
end

theory Int64_of_Int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int64.t = (Int64.of_int (Int32.to_int n))
  
end

theory Bit_int64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int64_of_Int32
  
  use export enum.Bit_int64_of_bit_int32
  
end

theory Int8_of_Int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Int8.t = (Int8.of_int (Int16.to_int n))
  
end

theory Bit_int8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Int8_of_Int16
  
  use export enum.Bit_int8_of_bit_int16
  
end

theory Int8_of_Int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int8.t = (Int8.of_int (Int32.to_int n))
  
end

theory Bit_int8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int8_of_Int32
  
  use export enum.Bit_int8_of_bit_int32
  
end

theory Int8_of_Int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int8.t = (Int8.of_int (Int64.to_int n))
  
end

theory Bit_int8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int8_of_Int64
  
  use export enum.Bit_int8_of_bit_int64
  
end

theory Uint16_of_Int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint16.t = (Uint16.of_int (Int16.to_int n))
  
end

theory Bit_uint16_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint16_of_Int16
  
  use export enum.Bit_uint16_of_bit_int16
  
end

theory Uint16_of_Int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint16.t = (Uint16.of_int (Int32.to_int n))
  
end

theory Bit_uint16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint16_of_Int32
  
  use export enum.Bit_uint16_of_bit_int32
  
end

theory Uint16_of_Int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint16.t = (Uint16.of_int (Int64.to_int n))
  
end

theory Bit_uint16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint16_of_Int64
  
  use export enum.Bit_uint16_of_bit_int64
  
end

theory Uint16_of_Int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint16.t = (Uint16.of_int (Int8.to_int n))
  
end

theory Bit_uint16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint16_of_Int8
  
  use export enum.Bit_uint16_of_bit_int8
  
end

theory Uint32_of_Int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint32.t = (Uint32.of_int (Int16.to_int n))
  
end

theory Bit_uint32_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint32_of_Int16
  
  use export enum.Bit_uint32_of_bit_int16
  
end

theory Uint32_of_Int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint32.t = (Uint32.of_int (Int32.to_int n))
  
end

theory Bit_uint32_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint32_of_Int32
  
  use export enum.Bit_uint32_of_bit_int32
  
end

theory Uint32_of_Int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint32.t = (Uint32.of_int (Int64.to_int n))
  
end

theory Bit_uint32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint32_of_Int64
  
  use export enum.Bit_uint32_of_bit_int64
  
end

theory Uint32_of_Int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint32.t = (Uint32.of_int (Int8.to_int n))
  
end

theory Bit_uint32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint32_of_Int8
  
  use export enum.Bit_uint32_of_bit_int8
  
end

theory Uint32_of_Uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint32.t = (Uint32.of_int (Uint16.to_int n))
  
end

theory Bit_uint32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint16
  
  use export enum.Bit_uint32_of_bit_uint16
  
end

theory Uint64_of_Int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint64.t = (Uint64.of_int (Int16.to_int n))
  
end

theory Bit_uint64_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint64_of_Int16
  
  use export enum.Bit_uint64_of_bit_int16
  
end

theory Uint64_of_Int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint64.t = (Uint64.of_int (Int32.to_int n))
  
end

theory Bit_uint64_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint64_of_Int32
  
  use export enum.Bit_uint64_of_bit_int32
  
end

theory Uint64_of_Int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint64.t = (Uint64.of_int (Int64.to_int n))
  
end

theory Bit_uint64_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint64_of_Int64
  
  use export enum.Bit_uint64_of_bit_int64
  
end

theory Uint64_of_Int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint64.t = (Uint64.of_int (Int8.to_int n))
  
end

theory Bit_uint64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint64_of_Int8
  
  use export enum.Bit_uint64_of_bit_int8
  
end

theory Uint64_of_Uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint64.t = (Uint64.of_int (Uint16.to_int n))
  
end

theory Bit_uint64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint16
  
  use export enum.Bit_uint64_of_bit_uint16
  
end

theory Uint64_of_Uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint64.t = (Uint64.of_int (Uint32.to_int n))
  
end

theory Bit_uint64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint32
  
  use export enum.Bit_uint64_of_bit_uint32
  
end

theory Uint8_of_Int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int16.t) : Uint8.t = (Uint8.of_int (Int16.to_int n))
  
end

theory Bit_uint8_of_Bit_int16

  use why3.Bool.Bool 
  
  use export Uint8_of_Int16
  
  use export enum.Bit_uint8_of_bit_int16
  
end

theory Uint8_of_Int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Uint8.t = (Uint8.of_int (Int32.to_int n))
  
end

theory Bit_uint8_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Uint8_of_Int32
  
  use export enum.Bit_uint8_of_bit_int32
  
end

theory Uint8_of_Int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Uint8.t = (Uint8.of_int (Int64.to_int n))
  
end

theory Bit_uint8_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Uint8_of_Int64
  
  use export enum.Bit_uint8_of_bit_int64
  
end

theory Uint8_of_Int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Uint8.t = (Uint8.of_int (Int8.to_int n))
  
end

theory Bit_uint8_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Uint8_of_Int8
  
  use export enum.Bit_uint8_of_bit_int8
  
end

theory Uint8_of_Uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Uint8.t = (Uint8.of_int (Uint16.to_int n))
  
end

theory Bit_uint8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint16
  
  use export enum.Bit_uint8_of_bit_uint16
  
end

theory Uint8_of_Uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint8.t = (Uint8.of_int (Uint32.to_int n))
  
end

theory Bit_uint8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint32
  
  use export enum.Bit_uint8_of_bit_uint32
  
end

theory Uint8_of_Uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint8.t = (Uint8.of_int (Uint64.to_int n))
  
end

theory Bit_uint8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint8_of_Uint64
  
  use export enum.Bit_uint8_of_bit_uint64
  
end

theory Int16_of_Int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int32.t) : Int16.t = (Int16.of_int (Int32.to_int n))
  
end

theory Bit_int16_of_Bit_int32

  use why3.Bool.Bool 
  
  use export Int16_of_Int32
  
  use export enum.Bit_int16_of_bit_int32
  
end

theory Int16_of_Int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int16.t = (Int16.of_int (Int64.to_int n))
  
end

theory Bit_int16_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int16_of_Int64
  
  use export enum.Bit_int16_of_bit_int64
  
end

theory Int32_of_Int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int64.t) : Int32.t = (Int32.of_int (Int64.to_int n))
  
end

theory Bit_int32_of_Bit_int64

  use why3.Bool.Bool 
  
  use export Int32_of_Int64
  
  use export enum.Bit_int32_of_bit_int64
  
end

theory Int16_of_Int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int16.t = (Int16.of_int (Int8.to_int n))
  
end

theory Bit_int16_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int16_of_Int8
  
  use export enum.Bit_int16_of_bit_int8
  
end

theory Int32_of_Int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int32.t = (Int32.of_int (Int8.to_int n))
  
end

theory Bit_int32_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int32_of_Int8
  
  use export enum.Bit_int32_of_bit_int8
  
end

theory Int64_of_Int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Int8.t) : Int64.t = (Int64.of_int (Int8.to_int n))
  
end

theory Bit_int64_of_Bit_int8

  use why3.Bool.Bool 
  
  use export Int64_of_Int8
  
  use export enum.Bit_int64_of_bit_int8
  
end

theory Int16_of_Uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int16.t = (Int16.of_int (Uint16.to_int n))
  
end

theory Bit_int16_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int16_of_Uint16
  
  use export enum.Bit_int16_of_bit_uint16
  
end

theory Int32_of_Uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int32.t = (Int32.of_int (Uint16.to_int n))
  
end

theory Bit_int32_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int32_of_Uint16
  
  use export enum.Bit_int32_of_bit_uint16
  
end

theory Int64_of_Uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int64.t = (Int64.of_int (Uint16.to_int n))
  
end

theory Bit_int64_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int64_of_Uint16
  
  use export enum.Bit_int64_of_bit_uint16
  
end

theory Int8_of_Uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint16.t) : Int8.t = (Int8.of_int (Uint16.to_int n))
  
end

theory Bit_int8_of_Bit_uint16

  use why3.Bool.Bool 
  
  use export Int8_of_Uint16
  
  use export enum.Bit_int8_of_bit_uint16
  
end

theory Int16_of_Uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int16.t = (Int16.of_int (Uint32.to_int n))
  
end

theory Bit_int16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int16_of_Uint32
  
  use export enum.Bit_int16_of_bit_uint32
  
end

theory Int32_of_Uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int32.t = (Int32.of_int (Uint32.to_int n))
  
end

theory Bit_int32_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int32_of_Uint32
  
  use export enum.Bit_int32_of_bit_uint32
  
end

theory Int64_of_Uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int64.t = (Int64.of_int (Uint32.to_int n))
  
end

theory Bit_int64_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int64_of_Uint32
  
  use export enum.Bit_int64_of_bit_uint32
  
end

theory Int8_of_Uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Int8.t = (Int8.of_int (Uint32.to_int n))
  
end

theory Bit_int8_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Int8_of_Uint32
  
  use export enum.Bit_int8_of_bit_uint32
  
end

theory Uint16_of_Uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint32.t) : Uint16.t = (Uint16.of_int (Uint32.to_int n))
  
end

theory Bit_uint16_of_Bit_uint32

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint32
  
  use export enum.Bit_uint16_of_bit_uint32
  
end

theory Int16_of_Uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int16.t = (Int16.of_int (Uint64.to_int n))
  
end

theory Bit_int16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int16_of_Uint64
  
  use export enum.Bit_int16_of_bit_uint64
  
end

theory Int32_of_Uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int32.t = (Int32.of_int (Uint64.to_int n))
  
end

theory Bit_int32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int32_of_Uint64
  
  use export enum.Bit_int32_of_bit_uint64
  
end

theory Int64_of_Uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int64.t = (Int64.of_int (Uint64.to_int n))
  
end

theory Bit_int64_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int64_of_Uint64
  
  use export enum.Bit_int64_of_bit_uint64
  
end

theory Int8_of_Uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Int8.t = (Int8.of_int (Uint64.to_int n))
  
end

theory Bit_int8_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Int8_of_Uint64
  
  use export enum.Bit_int8_of_bit_uint64
  
end

theory Uint16_of_Uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint16.t = (Uint16.of_int (Uint64.to_int n))
  
end

theory Bit_uint16_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint64
  
  use export enum.Bit_uint16_of_bit_uint64
  
end

theory Uint32_of_Uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint64.t) : Uint32.t = (Uint32.of_int (Uint64.to_int n))
  
end

theory Bit_uint32_of_Bit_uint64

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint64
  
  use export enum.Bit_uint32_of_bit_uint64
  
end

theory Int16_of_Uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int16.t = (Int16.of_int (Uint8.to_int n))
  
end

theory Bit_int16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int16_of_Uint8
  
  use export enum.Bit_int16_of_bit_uint8
  
end

theory Int32_of_Uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int32.t = (Int32.of_int (Uint8.to_int n))
  
end

theory Bit_int32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int32_of_Uint8
  
  use export enum.Bit_int32_of_bit_uint8
  
end

theory Int64_of_Uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int64.t = (Int64.of_int (Uint8.to_int n))
  
end

theory Bit_int64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int64_of_Uint8
  
  use export enum.Bit_int64_of_bit_uint8
  
end

theory Int8_of_Uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Int8.t = (Int8.of_int (Uint8.to_int n))
  
end

theory Bit_int8_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Int8_of_Uint8
  
  use export enum.Bit_int8_of_bit_uint8
  
end

theory Uint16_of_Uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint16.t = (Uint16.of_int (Uint8.to_int n))
  
end

theory Bit_uint16_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint16_of_Uint8
  
  use export enum.Bit_uint16_of_bit_uint8
  
end

theory Uint32_of_Uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint32.t = (Uint32.of_int (Uint8.to_int n))
  
end

theory Bit_uint32_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint32_of_Uint8
  
  use export enum.Bit_uint32_of_bit_uint8
  
end

theory Uint64_of_Uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  function cast (n : Uint8.t) : Uint64.t = (Uint64.of_int (Uint8.to_int n))
  
end

theory Bit_uint64_of_Bit_uint8

  use why3.Bool.Bool 
  
  use export Uint64_of_Uint8
  
  use export enum.Bit_uint64_of_bit_uint8
  
end

module Unsafe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint8

  use why3.Bool.Bool 
  
  use import enum.Uint8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint8

  use why3.Bool.Bool 
  
  use import enum.Bit_uint8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint64

  use why3.Bool.Bool 
  
  use import enum.Uint64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint64

  use why3.Bool.Bool 
  
  use import enum.Bit_uint64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint32

  use why3.Bool.Bool 
  
  use import enum.Uint32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint32

  use why3.Bool.Bool 
  
  use import enum.Bit_uint32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_uint16

  use why3.Bool.Bool 
  
  use import enum.Uint16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_uint16

  use why3.Bool.Bool 
  
  use import enum.Bit_uint16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int8

  use why3.Bool.Bool 
  
  use import enum.Int8 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int8

  use why3.Bool.Bool 
  
  use import enum.Bit_int8 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int64

  use why3.Bool.Bool 
  
  use import enum.Int64 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int64

  use why3.Bool.Bool 
  
  use import enum.Bit_int64 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int32

  use why3.Bool.Bool 
  
  use import enum.Int32 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int32

  use why3.Bool.Bool 
  
  use import enum.Bit_int32 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Unsafe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Unsafe_enum with namespace . = .
  
end

module Safe_int16

  use why3.Bool.Bool 
  
  use import enum.Int16 
  
  clone export enum.Generic_enum with namespace . = .
  
  clone export enum.Safe_enum with namespace . = .
  
end

module Unsafe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Unsafe_bit_enum with namespace . = .
  
end

module Safe_bit_int16

  use why3.Bool.Bool 
  
  use import enum.Bit_int16 
  
  clone export enum.Generic_bit_enum with namespace . = .
  
  clone export enum.Safe_bit_enum with namespace . = .
  
end

module Globals_simple

  use why3.Bool.Bool 
  
end

theory Root_voidP

  use why3.Bool.Bool 
  
  use import core.Jessie_voidp 
  
end

module Root_voidP_safe

  use why3.Bool.Bool 
  
end

module Root_voidP_unsafe

  use why3.Bool.Bool 
  
end

module Root_char_xP_safe

  use why3.Bool.Bool 
  
end

module Root_char_xP_unsafe

  use why3.Bool.Bool 
  
end

theory Axiomatic_Strlen

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  predicate valid_str (s : (pointer voidP)) (voidP_s_2_alloc_table_at_L :
  (alloc_table voidP)) (charP_charM_s_2_at_L : (memory voidP Int8.t))
  =
     (exists n_1 : Uint64.t.
      ((Int8.(=) (select charP_charM_s_2_at_L (shift s (Uint64.to_int n_1)))
       (#"strsep.jc" 27 42 53# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (if ((<=) (0) (Uint64.to_int n_1)) then
       (((<=) (offset_min voidP_s_2_alloc_table_at_L s) (0)) /\
       (((>=) (offset_max voidP_s_2_alloc_table_at_L s) (Uint64.to_int n_1))
       /\
       (forall __framac_tmp1 : int.
        ((((<=) (0) __framac_tmp1) /\
         ((<=) __framac_tmp1 (Uint64.to_int n_1))) -> ((=) true true)))))
       else ((=) true true))))
  
  
  lemma Valid_str_shift1
  #"/home/work/workspace/self/verker-gh/strlen.h" 12 7 102#
  "expl:Lemma valid_str_shift1" :
  (forall voidP_s_0_19_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_0_19_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 12 7 102#
    (forall s_0_1 : (pointer voidP).
     (((Int8.(<>) (select charP_charM_s_0_19_at_L s_0_1)
       (#"strsep.jc" 41 28 39# "expl:Integer cast" (Int8.of_int (0))))
      /\
      (valid_str s_0_1 voidP_s_0_19_alloc_table_at_L charP_charM_s_0_19_at_L))
      ->
      (valid_str (shift s_0_1 (1)) voidP_s_0_19_alloc_table_at_L
      charP_charM_s_0_19_at_L))))))
  
  lemma Valid_str_strend
  #"/home/work/workspace/self/verker-gh/strlen.h" 18 7 87#
  "expl:Lemma valid_str_strend" :
  (forall voidP_s_1_20_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_1_20_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 18 7 87#
    (forall s_1_0 : (pointer voidP).
     (((((<=) (offset_min voidP_s_1_20_alloc_table_at_L s_1_0) (0)) /\
       (((>=) (offset_max voidP_s_1_20_alloc_table_at_L s_1_0) (0)) /\
       ((=) true true)))
      /\
      (Int8.(=) (select charP_charM_s_1_20_at_L s_1_0)
      (#"strsep.jc" 49 29 40# "expl:Integer cast" (Int8.of_int (0))))) ->
      (valid_str s_1_0 voidP_s_1_20_alloc_table_at_L charP_charM_s_1_20_at_L))))))
  
  function strlen (s_2 : (pointer voidP)) (charP_charM_s_2_3_at_L : (memory
  voidP Int8.t)) : Uint64.t
  =
     (if
      (Int8.(=) (select charP_charM_s_2_3_at_L (shift s_2 (0)))
      (#"strsep.jc" 53 30 41# "expl:Integer cast" (Int8.of_int (0)))) then
      (#"strsep.jc" 53 48 61# "expl:Integer cast" (Uint64.of_int (0))) else
      (#"strsep.jc" 53 67 255# "expl:Integer cast"
      (Uint64.of_int
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_2 (1)) charP_charM_s_2_3_at_L))))))
  
  
  lemma Strlen_before_null
  #"/home/work/workspace/self/verker-gh/strlen.h" 26 7 106#
  "expl:Lemma strlen_before_null" :
  (forall voidP_s_3_21_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_3_21_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 26 7 106#
    (forall s_3 : (pointer voidP).
     (forall i : int.
      (((valid_str s_3 voidP_s_3_21_alloc_table_at_L charP_charM_s_3_21_at_L)
       /\
       (((<=) (0) i) /\
       ((<) i (Uint64.to_int (strlen s_3 charP_charM_s_3_21_at_L))))) ->
       (Int8.(<>) (select charP_charM_s_3_21_at_L (shift s_3 i))
       (#"strsep.jc" 62 36 47# "expl:Integer cast" (Int8.of_int (0))))))))))
  
  lemma Strlen_at_null
  #"/home/work/workspace/self/verker-gh/strlen.h" 31 7 71#
  "expl:Lemma strlen_at_null" :
  (forall voidP_s_4_22_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_4_22_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 31 7 71#
    (forall s_4 : (pointer voidP).
     ((valid_str s_4 voidP_s_4_22_alloc_table_at_L charP_charM_s_4_22_at_L)
      ->
      (Int8.(=)
      (select charP_charM_s_4_22_at_L
      (shift s_4 (Uint64.to_int (strlen s_4 charP_charM_s_4_22_at_L))))
      (#"strsep.jc" 67 60 71# "expl:Integer cast" (Int8.of_int (0)))))))))
  
  lemma Strlen_shift
  #"/home/work/workspace/self/verker-gh/strlen.h" 35 7 125#
  "expl:Lemma strlen_shift" :
  (forall voidP_s_5_23_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_5_23_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 35 7 125#
    (forall s_5 : (pointer voidP).
     (forall i_0 : Uint64.t.
      (((valid_str s_5 voidP_s_5_23_alloc_table_at_L charP_charM_s_5_23_at_L)
       /\ (Uint64.(<=) i_0 (strlen s_5 charP_charM_s_5_23_at_L))) ->
       ((=)
       (Uint64.to_int
       (strlen (shift s_5 (Uint64.to_int i_0)) charP_charM_s_5_23_at_L))
       (Int.(-) (Uint64.to_int (strlen s_5 charP_charM_s_5_23_at_L))
       (Uint64.to_int i_0)))))))))
  
  lemma Strlen_shift_ex
  #"/home/work/workspace/self/verker-gh/strlen.h" 41 7 126#
  "expl:Lemma strlen_shift_ex" :
  (forall voidP_s_6_24_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_6_24_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 41 7 126#
    (forall s_6 : (pointer voidP).
     (forall i_1 : Uint64.t.
      (((valid_str s_6 voidP_s_6_24_alloc_table_at_L charP_charM_s_6_24_at_L)
       /\
       ((Uint64.(<) (#"strsep.jc" 79 39 52# "expl:Integer cast"
        (Uint64.of_int (0))) i_1)
       /\ (Uint64.(<=) i_1 (strlen s_6 charP_charM_s_6_24_at_L)))) ->
       (Uint64.(<)
       (strlen (shift s_6 (Uint64.to_int i_1)) charP_charM_s_6_24_at_L)
       (strlen s_6 charP_charM_s_6_24_at_L))))))))
  
  lemma Strlen_shift1
  #"/home/work/workspace/self/verker-gh/strlen.h" 47 7 103#
  "expl:Lemma strlen_shift1" :
  (forall voidP_s_7_25_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_7_25_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 47 7 103#
    (forall s_7 : (pointer voidP).
     (((valid_str s_7 voidP_s_7_25_alloc_table_at_L charP_charM_s_7_25_at_L)
      /\
      (Int8.(<>) (select charP_charM_s_7_25_at_L s_7) (#"strsep.jc" 85 49 60#
      "expl:Integer cast" (Int8.of_int (0))))) ->
      ((=) (Uint64.to_int (strlen s_7 charP_charM_s_7_25_at_L))
      (Int.(+) (1)
      (Uint64.to_int (strlen (shift s_7 (1)) charP_charM_s_7_25_at_L)))))))))
  
  lemma Strlen_pointers
  #"/home/work/workspace/self/verker-gh/strlen.h" 52 7 254#
  "expl:Lemma strlen_pointers" :
  (forall voidP_s_8_26_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_8_26_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 52 7 254#
    (forall s_8 : (pointer voidP).
     (forall sc : (pointer voidP).
      (((valid_str s_8 voidP_s_8_26_alloc_table_at_L charP_charM_s_8_26_at_L)
       /\
       ((valid_str sc voidP_s_8_26_alloc_table_at_L charP_charM_s_8_26_at_L)
       /\
       ((same_block s_8 sc) /\
       ((same_block s_8 sc) /\
       (((<=) (sub_pointer s_8 sc) (0)) /\
       (forall i_2 : int.
        ((((<=) (0) i_2) /\ ((<=) i_2 (sub_pointer sc s_8))) ->
         (Int8.(<>) (select charP_charM_s_8_26_at_L (shift s_8 i_2))
         (#"strsep.jc" 98 43 54# "expl:Integer cast" (Int8.of_int (0)))))))))))
       ->
       (Uint64.(<=) (strlen sc charP_charM_s_8_26_at_L)
       (strlen s_8 charP_charM_s_8_26_at_L))))))))
  
  lemma Strlen_main #"/home/work/workspace/self/verker-gh/strlen.h" 61 7 165#
  "expl:Lemma strlen_main" :
  (forall voidP_s_9_28_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_9_28_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 61 7 165#
    (forall s_9 : (pointer voidP).
     (forall n_2 : Uint64.t.
      (((valid_str s_9 voidP_s_9_28_alloc_table_at_L charP_charM_s_9_28_at_L)
       /\
       ((Int8.(=)
        (select charP_charM_s_9_28_at_L (shift s_9 (Uint64.to_int n_2)))
        (#"strsep.jc" 105 53 64# "expl:Integer cast" (Int8.of_int (0))))
       /\
       (forall i_3 : int.
        ((((<=) (0) i_3) /\ ((<) i_3 (Uint64.to_int n_2))) ->
         (Int8.(<>) (select charP_charM_s_9_28_at_L (shift s_9 i_3))
         (#"strsep.jc" 108 43 54# "expl:Integer cast" (Int8.of_int (0))))))))
       -> (Uint64.(=) (strlen s_9 charP_charM_s_9_28_at_L) n_2)))))))
  
  lemma Valid_str_shiftn
  #"/home/work/workspace/self/verker-gh/strlen.h" 68 7 123#
  "expl:Lemma valid_str_shiftn" :
  (forall voidP_s_10_29_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_10_29_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strlen.h" 68 7 123#
    (forall s_10 : (pointer voidP).
     (forall i_4 : int.
      (((valid_str s_10 voidP_s_10_29_alloc_table_at_L
        charP_charM_s_10_29_at_L)
       /\
       (((<=) (0) i_4) /\
       ((<) i_4 (Uint64.to_int (strlen s_10 charP_charM_s_10_29_at_L))))) ->
       (valid_str (shift s_10 i_4) voidP_s_10_29_alloc_table_at_L
       charP_charM_s_10_29_at_L)))))))
  
end

theory Axiomatic_StrSpn

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  predicate in_array (s_11 : (pointer voidP)) (c : Int8.t)
  (charP_charM_s_11_5_at_L : (memory voidP Int8.t))
  =
     (exists p : (pointer voidP).
      ((same_block s_11 p) /\
      (((<=) (sub_pointer s_11 p) (0)) /\
      ((same_block p
       (shift s_11 (Uint64.to_int (strlen s_11 charP_charM_s_11_5_at_L))))
      /\
      (((<)
       (sub_pointer p
       (shift s_11 (Uint64.to_int (strlen s_11 charP_charM_s_11_5_at_L))))
       (0))
      /\ (Int8.(=) (select charP_charM_s_11_5_at_L p) c))))))
  
  
  lemma In_array_shift1
  #"/home/work/workspace/self/verker-gh/strspn.h" 17 7 129#
  "expl:Lemma in_array_shift1" :
  (forall voidP_s_12_31_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_12_31_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strspn.h" 17 7 129#
    (forall s_12 : (pointer voidP).
     (forall c_0 : Int8.t.
      ((((valid_str s_12 voidP_s_12_31_alloc_table_at_L
         charP_charM_s_12_31_at_L)
        /\
        (((<>) s_12 null) /\
        (Int8.(<>) (select charP_charM_s_12_31_at_L s_12) c_0))) ->
        (in_array s_12 c_0 charP_charM_s_12_31_at_L))
      <-> (in_array (shift s_12 (1)) c_0 charP_charM_s_12_31_at_L)))))))
  
  lemma In_array_true
  #"/home/work/workspace/self/verker-gh/strspn.h" 21 7 105#
  "expl:Lemma in_array_true" :
  (forall voidP_s_13_33_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_13_33_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strspn.h" 21 7 105#
    (forall s_13 : (pointer voidP).
     (forall c_1 : Int8.t.
      (((valid_str s_13 voidP_s_13_33_alloc_table_at_L
        charP_charM_s_13_33_at_L)
       /\
       (((<>) s_13 null) /\
       (Int8.(=) (select charP_charM_s_13_33_at_L s_13) c_1))) ->
       (in_array s_13 c_1 charP_charM_s_13_33_at_L)))))))
  
  lemma In_array_false
  #"/home/work/workspace/self/verker-gh/strspn.h" 25 7 95#
  "expl:Lemma in_array_false" :
  (forall voidP_s_14_35_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_14_35_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strspn.h" 25 7 95#
    (forall s_14 : (pointer voidP).
     (forall c_2 : Int8.t.
      (((valid_str s_14 voidP_s_14_35_alloc_table_at_L
        charP_charM_s_14_35_at_L)
       /\ ((=) s_14 null)) ->
       (not (in_array s_14 c_2 charP_charM_s_14_35_at_L))))))))
  
  function strspn (pointer voidP) (pointer voidP) : int
  
  
  lemma Strspn_strend
  #"/home/work/workspace/self/verker-gh/strspn.h" 32 7 106#
  "expl:Lemma strspn_strend" :
  (forall voidP_s_15_6_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_s_15_6_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strspn.h" 32 7 106#
    (forall s_16 : (pointer voidP).
     (forall accept_0_0 : (pointer voidP).
      (((((<=) (offset_min voidP_s_15_6_alloc_table_at_L s_16) (0)) /\
        (((>=) (offset_max voidP_s_15_6_alloc_table_at_L s_16) (0)) /\
        ((=) true true)))
       /\
       (Int8.(=) (select charP_charM_s_15_6_at_L s_16)
       (#"strsep.jc" 172 33 44# "expl:Integer cast" (Int8.of_int (0))))) ->
       ((=) (strspn s_16 accept_0_0) (0))))))))
  
  lemma Strspn_empty_accept
  #"/home/work/workspace/self/verker-gh/strspn.h" 37 7 116#
  "expl:Lemma strspn_empty_accept" :
  (forall voidP_accept_7_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_accept_7_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strspn.h" 37 7 116#
    (forall s_17 : (pointer voidP).
     (forall accept_1 : (pointer voidP).
      (((((<=) (offset_min voidP_accept_7_alloc_table_at_L accept_1) (0)) /\
        (((>=) (offset_max voidP_accept_7_alloc_table_at_L accept_1) (0)) /\
        ((=) true true)))
       /\
       (Int8.(=) (select charP_charM_accept_7_at_L accept_1)
       (#"strsep.jc" 181 37 48# "expl:Integer cast" (Int8.of_int (0))))) ->
       ((=) (strspn s_17 accept_1) (0))))))))
  
  lemma Strspn_range
  #"/home/work/workspace/self/verker-gh/strspn.h" 42 7 129#
  "expl:Lemma strspn_range" :
  (forall voidP_accept_7_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_s_15_6_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_accept_7_at_L : (memory voidP Int8.t).
     (forall charP_charM_s_15_6_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strspn.h" 42 7 129#
      (forall s_18 : (pointer voidP).
       (forall accept_2 : (pointer voidP).
        (((valid_str s_18 voidP_s_15_6_alloc_table_at_L
          charP_charM_s_15_6_at_L)
         /\
         (valid_str accept_2 voidP_accept_7_alloc_table_at_L
         charP_charM_accept_7_at_L)) ->
         (((<=) (0) (strspn s_18 accept_2)) /\
         ((<=) (strspn s_18 accept_2)
         (Uint64.to_int (strlen s_18 charP_charM_s_15_6_at_L))))))))))))
  
  lemma Strspn_shift1
  #"/home/work/workspace/self/verker-gh/strspn.h" 47 7 188#
  "expl:Lemma strspn_shift1" :
  (forall voidP_accept_7_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_s_15_6_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_accept_7_at_L : (memory voidP Int8.t).
     (forall charP_charM_s_15_6_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strspn.h" 47 7 188#
      (forall s_19 : (pointer voidP).
       (forall accept_3 : (pointer voidP).
        (((valid_str s_19 voidP_s_15_6_alloc_table_at_L
          charP_charM_s_15_6_at_L)
         /\
         ((valid_str accept_3 voidP_accept_7_alloc_table_at_L
          charP_charM_accept_7_at_L)
         /\
         ((Int8.(<>) (select charP_charM_s_15_6_at_L s_19)
          (#"strsep.jc" 195 34 45# "expl:Integer cast" (Int8.of_int (0))))
         /\
         (in_array accept_3 (select charP_charM_s_15_6_at_L s_19)
         charP_charM_accept_7_at_L)))) ->
         ((=) (strspn s_19 accept_3)
         (Int.(+) (strspn (shift s_19 (1)) accept_3) (1)))))))))))
  
  lemma Strspn_stop_not_in_accept
  #"/home/work/workspace/self/verker-gh/strspn.h" 53 7 165#
  "expl:Lemma strspn_stop_not_in_accept" :
  (forall voidP_accept_7_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_s_15_6_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_accept_7_at_L : (memory voidP Int8.t).
     (forall charP_charM_s_15_6_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strspn.h" 53 7 165#
      (forall s_20 : (pointer voidP).
       (forall accept_4 : (pointer voidP).
        (((valid_str s_20 voidP_s_15_6_alloc_table_at_L
          charP_charM_s_15_6_at_L)
         /\
         ((valid_str accept_4 voidP_accept_7_alloc_table_at_L
          charP_charM_accept_7_at_L)
         /\
         ((Int8.(<>) (select charP_charM_s_15_6_at_L s_20)
          (#"strsep.jc" 204 34 45# "expl:Integer cast" (Int8.of_int (0))))
         /\
         (not
         (in_array accept_4 (select charP_charM_s_15_6_at_L s_20)
         charP_charM_accept_7_at_L))))) -> ((=) (strspn s_20 accept_4) (0))))))))))
  
end

theory Axiomatic_StrPBrk

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrSpn 
  
  use why3.Bool.Bool 
  
  function strpbrk (pointer voidP) (pointer voidP) : (pointer
  voidP)
  
  
  lemma Strpbrk_strend
  #"/home/work/workspace/self/verker-gh/strpbrk.h" 12 7 107#
  "expl:Lemma strpbrk_strend" :
  (forall voidP_cs_10_alloc_table_at_L : (alloc_table voidP).
   (forall charP_charM_cs_10_at_L : (memory voidP Int8.t).
    (#"/home/work/workspace/self/verker-gh/strpbrk.h" 12 7 107#
    (forall cs_0_0 : (pointer voidP).
     (forall ct_0_1 : (pointer voidP).
      (((((<=) (offset_min voidP_cs_10_alloc_table_at_L cs_0_0) (0)) /\
        (((>=) (offset_max voidP_cs_10_alloc_table_at_L cs_0_0) (0)) /\
        ((=) true true)))
       /\
       (Int8.(=) (select charP_charM_cs_10_at_L cs_0_0)
       (#"strsep.jc" 268 33 44# "expl:Integer cast" (Int8.of_int (0))))) ->
       ((=) (strpbrk cs_0_0 ct_0_1) null)))))))
  
  lemma Strpbrk_empty_ct
  #"/home/work/workspace/self/verker-gh/strpbrk.h" 17 7 127#
  "expl:Lemma strpbrk_empty_ct" :
  (forall voidP_ct_11_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_cs_10_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_ct_11_at_L : (memory voidP Int8.t).
     (forall charP_charM_cs_10_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strpbrk.h" 17 7 127#
      (forall cs_1 : (pointer voidP).
       (forall ct_1 : (pointer voidP).
        (((valid_str cs_1 voidP_cs_10_alloc_table_at_L
          charP_charM_cs_10_at_L)
         /\
         ((valid_str ct_1 voidP_ct_11_alloc_table_at_L
          charP_charM_ct_11_at_L)
         /\
         (Int8.(=) (select charP_charM_ct_11_at_L ct_1)
         (#"strsep.jc" 275 33 44# "expl:Integer cast" (Int8.of_int (0))))))
         -> ((=) (strpbrk cs_1 ct_1) null)))))))))
  
  lemma Strpbrk_range
  #"/home/work/workspace/self/verker-gh/strpbrk.h" 22 7 174#
  "expl:Lemma strpbrk_range" :
  (forall voidP_ct_11_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_cs_10_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_ct_11_at_L : (memory voidP Int8.t).
     (forall charP_charM_cs_10_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strpbrk.h" 22 7 174#
      (forall cs_2 : (pointer voidP).
       (forall ct_2 : (pointer voidP).
        (((valid_str cs_2 voidP_cs_10_alloc_table_at_L
          charP_charM_cs_10_at_L)
         /\
         (valid_str ct_2 voidP_ct_11_alloc_table_at_L charP_charM_ct_11_at_L))
         ->
         ((((=) (strpbrk cs_2 ct_2) null) /\
          (not
          ((same_block cs_2 (strpbrk cs_2 ct_2)) /\
          (((<=) (sub_pointer cs_2 (strpbrk cs_2 ct_2)) (0)) /\
          ((same_block (strpbrk cs_2 ct_2)
           (shift cs_2 (Uint64.to_int (strlen cs_2 charP_charM_cs_10_at_L))))
          /\
          ((<)
          (sub_pointer (strpbrk cs_2 ct_2)
          (shift cs_2 (Uint64.to_int (strlen cs_2 charP_charM_cs_10_at_L))))
          (0)))))))
         \/
         ((same_block cs_2 (strpbrk cs_2 ct_2)) /\
         (((<=) (sub_pointer cs_2 (strpbrk cs_2 ct_2)) (0)) /\
         ((same_block (strpbrk cs_2 ct_2)
          (shift cs_2 (Uint64.to_int (strlen cs_2 charP_charM_cs_10_at_L))))
         /\
         (((<)
          (sub_pointer (strpbrk cs_2 ct_2)
          (shift cs_2 (Uint64.to_int (strlen cs_2 charP_charM_cs_10_at_L))))
          (0))
         /\ (not ((=) (strpbrk cs_2 ct_2) null)))))))))))))))
  
  lemma Strpbrk_shift1
  #"/home/work/workspace/self/verker-gh/strpbrk.h" 28 7 173#
  "expl:Lemma strpbrk_shift1" :
  (forall voidP_ct_11_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_cs_10_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_ct_11_at_L : (memory voidP Int8.t).
     (forall charP_charM_cs_10_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strpbrk.h" 28 7 173#
      (forall cs_3 : (pointer voidP).
       (forall ct_3 : (pointer voidP).
        (((valid_str cs_3 voidP_cs_10_alloc_table_at_L
          charP_charM_cs_10_at_L)
         /\
         ((valid_str ct_3 voidP_ct_11_alloc_table_at_L
          charP_charM_ct_11_at_L)
         /\
         ((Int8.(<>) (select charP_charM_cs_10_at_L cs_3)
          (#"strsep.jc" 304 34 45# "expl:Integer cast" (Int8.of_int (0))))
         /\
         (not
         (in_array ct_3 (select charP_charM_cs_10_at_L cs_3)
         charP_charM_ct_11_at_L))))) ->
         ((=) (strpbrk cs_3 ct_3) (strpbrk (shift cs_3 (1)) ct_3))))))))))
  
  lemma Strpbrk_stop_in_ct
  #"/home/work/workspace/self/verker-gh/strpbrk.h" 34 7 155#
  "expl:Lemma strpbrk_stop_in_ct" :
  (forall voidP_ct_11_alloc_table_at_L : (alloc_table voidP).
   (forall voidP_cs_10_alloc_table_at_L : (alloc_table voidP).
    (forall charP_charM_ct_11_at_L : (memory voidP Int8.t).
     (forall charP_charM_cs_10_at_L : (memory voidP Int8.t).
      (#"/home/work/workspace/self/verker-gh/strpbrk.h" 34 7 155#
      (forall cs_4 : (pointer voidP).
       (forall ct_4 : (pointer voidP).
        (((valid_str cs_4 voidP_cs_10_alloc_table_at_L
          charP_charM_cs_10_at_L)
         /\
         ((valid_str ct_4 voidP_ct_11_alloc_table_at_L
          charP_charM_ct_11_at_L)
         /\
         ((Int8.(<>) (select charP_charM_cs_10_at_L cs_4)
          (#"strsep.jc" 312 34 45# "expl:Integer cast" (Int8.of_int (0))))
         /\
         (in_array ct_4 (select charP_charM_cs_10_at_L cs_4)
         charP_charM_ct_11_at_L)))) -> ((=) (strpbrk cs_4 ct_4) cs_4)))))))))
  
end

theory Root_char_xP

  use why3.Bool.Bool 
  
  type char_xP 
  
end

module Exceptions

  use why3.Bool.Bool 
  
  exception Loop_continue_exc unit
  
  exception Loop_exit_exc unit
  
  exception Return_label_exc unit
  
end

module Function_strpbrk_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrPBrk 
  
  use why3.Bool.Bool 
  
  val strpbrk_0
  (cs_0 : (pointer voidP)) 
   (ct_0 : (pointer voidP)) 
    (voidP_ct_14_alloc_table : (alloc_table voidP)) 
     (voidP_cs_13_alloc_table : (alloc_table voidP)) 
      (charP_charM_ct_14 : (memory voidP Int8.t)) 
       (charP_charM_cs_13 : (memory voidP Int8.t)) : (pointer voidP)
        requires {
          ("expl:External"
          (#"strsep.jc" 319 12 74# "expl:Requires clause"
          ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 47 13 26#
           "expl:Requires clause"
           (valid_str cs_0 voidP_cs_13_alloc_table charP_charM_cs_13))
          /\
          (#"/home/work/workspace/self/verker-gh/strpbrk.h" 48 13 26#
          "expl:Requires clause"
          (valid_str ct_0 voidP_ct_14_alloc_table charP_charM_ct_14))))) }
        ensures {
          (((forall p_1 : (pointer voidP).
             (forall t_1 : (pointer voidP).
              (((same_block cs_0 p_1) /\
               (((<=) (sub_pointer cs_0 p_1) (0)) /\
               ((same_block p_1
                (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
               /\
               (((<)
                (sub_pointer p_1
                (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
                (0))
               /\
               ((same_block ct_0 t_1) /\
               (((<=) (sub_pointer ct_0 t_1) (0)) /\
               ((same_block t_1
                (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               /\
               ((<)
               (sub_pointer t_1
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))))))))) ->
               (Int8.(<>) (select charP_charM_cs_13 p_1)
               (select charP_charM_ct_14 t_1))))) ->
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 67 15 31#
            "expl:Ensures clause" ((=) result null)))
          /\
          (((exists p_2 : (pointer voidP).
             (exists t_2 : (pointer voidP).
              ((same_block cs_0 p_2) /\
              (((<=) (sub_pointer cs_0 p_2) (0)) /\
              ((same_block p_2
               (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
              /\
              (((<)
               (sub_pointer p_2
               (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
               (0))
              /\
              ((same_block ct_0 t_2) /\
              (((<=) (sub_pointer ct_0 t_2) (0)) /\
              ((same_block t_2
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
              /\
              (((<)
               (sub_pointer t_2
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))
              /\
              (Int8.(=) (select charP_charM_cs_13 p_2)
              (select charP_charM_ct_14 t_2)))))))))))) ->
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 28#
             "expl:Ensures clause" (same_block cs_0 result))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 28#
             "expl:Ensures clause" ((<=) (sub_pointer cs_0 result) (0)))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 21 46#
             "expl:Ensures clause"
             (same_block result
             (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13)))))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 21 46#
             "expl:Ensures clause"
             ((<)
             (sub_pointer result
             (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
             (0)))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 57 15 76#
             "expl:Ensures clause"
             (exists t_3 : (pointer voidP).
              ((same_block ct_0 t_3) /\
              (((<=) (sub_pointer ct_0 t_3) (0)) /\
              ((same_block t_3
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
              /\
              (((<=)
               (sub_pointer t_3
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))
              /\
              (Int8.(=) (select charP_charM_cs_13 result)
              (select charP_charM_ct_14 t_3))))))))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 58 15 140#
            "expl:Ensures clause"
            (forall p_3 : (pointer voidP).
             (forall t_4 : (pointer voidP).
              (((same_block cs_0 p_3) /\
               (((<=) (sub_pointer cs_0 p_3) (0)) /\
               ((same_block p_3 result) /\
               (((<) (sub_pointer p_3 result) (0)) /\
               ((same_block ct_0 t_4) /\
               (((<=) (sub_pointer ct_0 t_4) (0)) /\
               ((same_block t_4
                (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               /\
               ((<)
               (sub_pointer t_4
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))))))))) ->
               (Int8.(<>) (select charP_charM_cs_13 p_3)
               (select charP_charM_ct_14 t_4))))))))))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strpbrk.h" 50 12 38#
          "expl:Ensures clause" ((=) result (strpbrk cs_0 ct_0))))) }
  
end

module Safe_int8_of_Safe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { (Int8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Function_strsep_safety
#"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38# "expl:strsep, safety"

  use Safe_int8_of_Safe_int32 
  
  use Safe_int32 
  
  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_safe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_safe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_eq_pointer_safe 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_safe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_strpbrk_0_safe 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrPBrk 
  
  use why3.Bool.Bool 
  
  let strsep #"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38#
  "expl:Function strsep, safety" =
  fun
   (s_0_0 : (pointer char_xP)) (ct_0_0 : (pointer voidP))
   (charP_charM_result_18 : ref (memory voidP Int8.t))
   (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP)))
   (char_xP_s_0_16_alloc_table : (alloc_table char_xP))
   (voidP_ct_0_17_alloc_table : (alloc_table voidP))
   (voidP_result_18_alloc_table : (alloc_table voidP))
   (voidP_result_18_tag_table : (tag_table voidP)) (charP_charM_ct_0_17 :
   (memory voidP Int8.t)) 
   requires {
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 19 13 26#
    (valid_str ct_0_0 voidP_ct_0_17_alloc_table charP_charM_ct_0_17))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 20 13 22#
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((<=) (offset_min char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((>=) (offset_max char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\ (#"strsep.jc" 397 12 477# ((=) true true)))))))
   /\
   (#"/home/work/workspace/self/verker-gh/strsep.h" 21 13 41#
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ (not ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))
   \/
   (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
   (not
   (valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
   voidP_result_18_alloc_table !charP_charM_result_18))))))))) }
   ensures { ("expl:Postcondition" true) }  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); (); (); ();
     (let sbegin = ref (any_pointer  () : (pointer voidP)) in
     (let end_0 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let __retres = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      (sbegin :=
       (let _jessie_94 =
       (#"/home/work/workspace/self/verker-gh/strsep.c" 5 16 18#
       "expl:Pointer dereference"
       (acc  char_xP_s_0_16_alloc_table !char_xP_char_xM_s_0_16 s_0_0 )) in
       begin
       (assert {
       (#"/home/work/workspace/self/verker-gh/strsep.c" 5 6 13#
       "expl:Pointer index bounds" true) }); _jessie_94 end));
       (if
       (#"/home/work/workspace/self/verker-gh/strsep.c" 8 5 26#
       (#"/home/work/workspace/self/verker-gh/strsep.c" 8 5 26#
       (eq_pointer  voidP_result_18_alloc_table voidP_result_18_alloc_table
        !sbegin (null  ) )))
       then
        begin
        (__retres :=
         (let _jessie_95 = (null  ) in
         begin
         (assert {
         (#"/home/work/workspace/self/verker-gh/strsep.c" 9 2 21#
         "expl:Pointer index bounds" true) }); _jessie_95 end));
         (raise (Return_label_exc ())) end else ());
       begin
       (end_0 :=
        (let _jessie_84 =
        (let _jessie_86 = !sbegin in
        (let _jessie_85 = ct_0_0 in
        (#"/home/work/workspace/self/verker-gh/strsep.c" 11 7 26#
        "expl:Precondition for strpbrk"
        (Function_strpbrk_0_safe.strpbrk_0  _jessie_86 _jessie_85
         voidP_ct_0_17_alloc_table voidP_result_18_alloc_table
         charP_charM_ct_0_17 !charP_charM_result_18 )))) in
        begin
        (assert {
        (#"/home/work/workspace/self/verker-gh/strsep.c" 11 7 26#
        "expl:Pointer index bounds" true) }); _jessie_84 end));
        begin
        any unit
        requires { true } reads { ct_0_0 }
        ensures {
          (#"/home/work/workspace/self/verker-gh/strsep.c" 12 12 38#
          ((=) (strpbrk !sbegin ct_0_0) !end_0)) } ; () end;
        (if
        (#"/home/work/workspace/self/verker-gh/strsep.c" 13 5 8#
        (#"/home/work/workspace/self/verker-gh/strsep.c" 13 5 8#
        (neq_pointer  voidP_result_18_alloc_table voidP_result_18_alloc_table
         !end_0 (null  ) )))
        then
         begin
         (tmp :=
          (let _jessie_87 = !end_0 in
          begin
          (assert {
          (#"/home/work/workspace/self/verker-gh/strsep.c" 14 3 8#
          "expl:Pointer index bounds" true) }); _jessie_87 end));
          begin
          (end_0 :=
           (let _jessie_88 =
           (shift_typesafe  !end_0
            (Safe_int32.to_int 
             (#"strsep.jc" 472 45 57# "expl:Integer cast"
             (Safe_int32.of_int (1))) ) ) in
           begin
           (assert {
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 3 8#
           "expl:Pointer index bounds" true) }); _jessie_88 end));
           (let _jessie_90 =
           (let _jessie_89 =
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 11 15#
           "expl:Integer cast"
           (Safe_int8_of_Safe_int32.cast 
            (#"strsep.jc" 473 51 63# "expl:Integer cast"
            (Safe_int32.of_int (0))) )) in
           begin
           (assert {
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 2 15#
           "expl:Pointer index bounds" true) }); _jessie_89 end) in
           (let _jessie_91 = !tmp in
           (let _jessie_92 = (0) in
           (let _jessie_93 = _jessie_91 in
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 2 15#
           "expl:Pointer dereference"
           (upd  voidP_result_18_alloc_table charP_charM_result_18 _jessie_91
            _jessie_90 )))))) end end else ());
        begin
        (let _jessie_80 =
        (let _jessie_79 = !end_0 in
        begin
        (assert {
        (#"/home/work/workspace/self/verker-gh/strsep.c" 16 1 9#
        "expl:Pointer index bounds" true) }); _jessie_79 end) in
        (let _jessie_81 = s_0_0 in
        (let _jessie_82 = (0) in
        (let _jessie_83 = _jessie_81 in
        (#"/home/work/workspace/self/verker-gh/strsep.c" 16 1 9#
        "expl:Pointer dereference"
        (upd  char_xP_s_0_16_alloc_table char_xP_char_xM_s_0_16 _jessie_81
         _jessie_80 ))))));
         begin
         (__retres :=
          (let _jessie_78 = !sbegin in
          begin
          (assert {
          (#"/home/work/workspace/self/verker-gh/strsep.c" 17 1 15#
          "expl:Pointer index bounds" true) }); _jessie_78 end));
          (raise (Return_label_exc ())) end end end end with Return_label_exc
      _jessie_1 ->
      'Return_label:
      'Return_label:
      begin
      (return :=
       (let _jessie_96 = !__retres in
       begin
       (assert { (#"strsep.jc" 478 7 22# "expl:Pointer index bounds" true) });
        _jessie_96 end)); (raise Return) end end)))); absurd  end with Return
    -> !return end)
  
end

module Function_strpbrk_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrPBrk 
  
  use why3.Bool.Bool 
  
  val strpbrk_0
  (cs_0 : (pointer voidP)) 
   (ct_0 : (pointer voidP)) 
    (voidP_ct_14_alloc_table : (alloc_table voidP)) 
     (voidP_cs_13_alloc_table : (alloc_table voidP)) 
      (charP_charM_ct_14 : (memory voidP Int8.t)) 
       (charP_charM_cs_13 : (memory voidP Int8.t)) : (pointer voidP)
        requires { true }
        ensures {
          (((forall p_1 : (pointer voidP).
             (forall t_1 : (pointer voidP).
              (((same_block cs_0 p_1) /\
               (((<=) (sub_pointer cs_0 p_1) (0)) /\
               ((same_block p_1
                (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
               /\
               (((<)
                (sub_pointer p_1
                (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
                (0))
               /\
               ((same_block ct_0 t_1) /\
               (((<=) (sub_pointer ct_0 t_1) (0)) /\
               ((same_block t_1
                (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               /\
               ((<)
               (sub_pointer t_1
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))))))))) ->
               (Int8.(<>) (select charP_charM_cs_13 p_1)
               (select charP_charM_ct_14 t_1))))) ->
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 67 15 31#
            "expl:Ensures clause" ((=) result null)))
          /\
          (((exists p_2 : (pointer voidP).
             (exists t_2 : (pointer voidP).
              ((same_block cs_0 p_2) /\
              (((<=) (sub_pointer cs_0 p_2) (0)) /\
              ((same_block p_2
               (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
              /\
              (((<)
               (sub_pointer p_2
               (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
               (0))
              /\
              ((same_block ct_0 t_2) /\
              (((<=) (sub_pointer ct_0 t_2) (0)) /\
              ((same_block t_2
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
              /\
              (((<)
               (sub_pointer t_2
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))
              /\
              (Int8.(=) (select charP_charM_cs_13 p_2)
              (select charP_charM_ct_14 t_2)))))))))))) ->
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 28#
             "expl:Ensures clause" (same_block cs_0 result))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 28#
             "expl:Ensures clause" ((<=) (sub_pointer cs_0 result) (0)))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 21 46#
             "expl:Ensures clause"
             (same_block result
             (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13)))))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 21 46#
             "expl:Ensures clause"
             ((<)
             (sub_pointer result
             (shift cs_0 (Uint64.to_int (strlen cs_0 charP_charM_cs_13))))
             (0)))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 56 15 46#
            "expl:Ensures clause"
            ((#"/home/work/workspace/self/verker-gh/strpbrk.h" 57 15 76#
             "expl:Ensures clause"
             (exists t_3 : (pointer voidP).
              ((same_block ct_0 t_3) /\
              (((<=) (sub_pointer ct_0 t_3) (0)) /\
              ((same_block t_3
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
              /\
              (((<=)
               (sub_pointer t_3
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))
              /\
              (Int8.(=) (select charP_charM_cs_13 result)
              (select charP_charM_ct_14 t_3))))))))
            /\
            (#"/home/work/workspace/self/verker-gh/strpbrk.h" 58 15 140#
            "expl:Ensures clause"
            (forall p_3 : (pointer voidP).
             (forall t_4 : (pointer voidP).
              (((same_block cs_0 p_3) /\
               (((<=) (sub_pointer cs_0 p_3) (0)) /\
               ((same_block p_3 result) /\
               (((<) (sub_pointer p_3 result) (0)) /\
               ((same_block ct_0 t_4) /\
               (((<=) (sub_pointer ct_0 t_4) (0)) /\
               ((same_block t_4
                (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               /\
               ((<)
               (sub_pointer t_4
               (shift ct_0 (Uint64.to_int (strlen ct_0 charP_charM_ct_14))))
               (0))))))))) ->
               (Int8.(<>) (select charP_charM_cs_13 p_3)
               (select charP_charM_ct_14 t_4))))))))))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strpbrk.h" 50 12 38#
          "expl:Ensures clause" ((=) result (strpbrk cs_0 ct_0))))) }
  
end

module Unsafe_int8_of_Unsafe_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int32.to_int n)) }
  
end

module Function_strsep_behaviors
#"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38#
"expl:strsep, behaviors"

  use Unsafe_int8_of_Unsafe_int32 
  
  use Unsafe_int32 
  
  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_upd_unsafe 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_shift_unsafe 
  
  use import core.Jessie_return 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_any_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_acc_unsafe 
  
  use enum.Int8 
  
  use import int.Int 
  
  use Function_strpbrk_0 
  
  use import Exceptions 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrPBrk 
  
  use why3.Bool.Bool 
  
  let strsep_ensures_default
  #"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38#
  "expl:Function strsep, default behavior" =
  fun
   (s_0_0 : (pointer char_xP)) (ct_0_0 : (pointer voidP))
   (charP_charM_result_18 : ref (memory voidP Int8.t))
   (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP)))
   (char_xP_s_0_16_alloc_table : (alloc_table char_xP))
   (voidP_ct_0_17_alloc_table : (alloc_table voidP))
   (voidP_result_18_alloc_table : (alloc_table voidP))
   (voidP_result_18_tag_table : (tag_table voidP)) (charP_charM_ct_0_17 :
   (memory voidP Int8.t)) 
   requires {
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 19 13 26#
    (valid_str ct_0_0 voidP_ct_0_17_alloc_table charP_charM_ct_0_17))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 20 13 22#
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((<=) (offset_min char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((>=) (offset_max char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\ (#"strsep.jc" 397 12 477# ((=) true true)))))))
   /\
   (#"/home/work/workspace/self/verker-gh/strsep.h" 21 13 41#
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ (not ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))
   \/
   (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
   (not
   (valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
   voidP_result_18_alloc_table !charP_charM_result_18))))))))) }
   ensures { ("expl:Postcondition" ("expl:Ensures clause" true)) }  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (check {
    (#"strsep.jc" 430 10 297# "expl:Behavior disjointness check"
    (not
    ((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\
    (((=) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null) /\
    ((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ ((<>) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null))))))
    });
     (check {
     (#"strsep.jc" 435 10 210# "expl:Behavior disjointness check"
     (not
     (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
     ((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
      voidP_result_18_alloc_table !charP_charM_result_18)
     /\ ((=) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null)))))
     });
     (check {
     (#"strsep.jc" 439 10 210# "expl:Behavior disjointness check"
     (not
     (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
     ((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
      voidP_result_18_alloc_table !charP_charM_result_18)
     /\ ((<>) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null)))))
     });
     (check {
     (#"strsep.jc" 443 10 348# "expl:Behavior completeness check"
     (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
       voidP_result_18_alloc_table !charP_charM_result_18)
      /\ ((<>) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null))
     \/
     (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
       voidP_result_18_alloc_table !charP_charM_result_18)
      /\ ((=) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null))
     \/ ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))) });
     (let sbegin = ref (any_pointer  () : (pointer voidP)) in
     (let end_0 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let __retres = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      (sbegin := (acc  !char_xP_char_xM_s_0_16 s_0_0 ));
       (if
       (#"/home/work/workspace/self/verker-gh/strsep.c" 8 5 26#
       ((=)  !sbegin (null  ) ))
       then begin (__retres := (null  )); (raise (Return_label_exc ())) end
       else ());
       begin
       (end_0 :=
        (let _jessie_10 = !sbegin in
        (let _jessie_9 = ct_0_0 in
        (#"/home/work/workspace/self/verker-gh/strsep.c" 11 7 26#
        "expl:Precondition for strpbrk"
        (Function_strpbrk_0.strpbrk_0  _jessie_10 _jessie_9
         voidP_ct_0_17_alloc_table voidP_result_18_alloc_table
         charP_charM_ct_0_17 !charP_charM_result_18 )))));
        begin
        (assert {
        (#"/home/work/workspace/self/verker-gh/strsep.c" 12 12 38#
        "expl:Assertion in line 12" ((=) (strpbrk !sbegin ct_0_0) !end_0)) });
         () end;
        (if
        (#"/home/work/workspace/self/verker-gh/strsep.c" 13 5 8#
        ((<>)  !end_0 (null  ) ))
        then
         begin
         (tmp := !end_0);
          begin
          (end_0 :=
           (shift_  !end_0
            (Unsafe_int32.to_int 
             (#"strsep.jc" 472 45 57# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) ) ));
           (let _jessie_14 =
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 11 15#
           "expl:Integer cast"
           (Unsafe_int8_of_Unsafe_int32.cast 
            (#"strsep.jc" 473 51 63# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) )) in
           (let _jessie_15 = !tmp in
           (let _jessie_16 = (0) in
           (let _jessie_17 = _jessie_15 in
           (upd  charP_charM_result_18 _jessie_17 _jessie_14 ))))) end end
        else ());
        begin
        (let _jessie_4 = !end_0 in
        (let _jessie_5 = s_0_0 in
        (let _jessie_6 = (0) in
        (let _jessie_7 = _jessie_5 in
        (upd  char_xP_char_xM_s_0_16 _jessie_7 _jessie_4 )))));
         begin (__retres := !sbegin); (raise (Return_label_exc ())) end end
       end end with Return_label_exc _jessie_1 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let strsep_ensures_input_null
  #"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38#
  "expl:Function strsep, behavior input_null" =
  fun
   (s_0_0 : (pointer char_xP)) (ct_0_0 : (pointer voidP))
   (charP_charM_result_18 : ref (memory voidP Int8.t))
   (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP)))
   (char_xP_s_0_16_alloc_table : (alloc_table char_xP))
   (voidP_ct_0_17_alloc_table : (alloc_table voidP))
   (voidP_result_18_alloc_table : (alloc_table voidP))
   (voidP_result_18_tag_table : (tag_table voidP)) (charP_charM_ct_0_17 :
   (memory voidP Int8.t)) 
   requires {
   (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 19 13 26#
    (valid_str ct_0_0 voidP_ct_0_17_alloc_table charP_charM_ct_0_17))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 20 13 22#
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((<=) (offset_min char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((>=) (offset_max char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\ (#"strsep.jc" 397 12 477# ((=) true true)))))))
   /\
   (#"/home/work/workspace/self/verker-gh/strsep.h" 21 13 41#
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ (not ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))
   \/
   (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
   (not
   (valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
   voidP_result_18_alloc_table !charP_charM_result_18)))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"strsep.jc" 409 10 18# "expl:Assigns clause"
       (not_assigns voidP_result_18_alloc_table voidP_result_18_alloc_table
       (old !charP_charM_result_18) !charP_charM_result_18 pset_empty))
      /\
      (#"strsep.jc" 409 10 18# "expl:Assigns clause"
      (not_assigns char_xP_s_0_16_alloc_table char_xP_s_0_16_alloc_table (old
      !char_xP_char_xM_s_0_16) !char_xP_char_xM_s_0_16 pset_empty)))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 25 15 31#
     "expl:Ensures clause" ((=) result null)))) }  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); (); (); ();
     (let sbegin = ref (any_pointer  () : (pointer voidP)) in
     (let end_0 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let __retres = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      (sbegin := (acc  !char_xP_char_xM_s_0_16 s_0_0 ));
       (if
       (#"/home/work/workspace/self/verker-gh/strsep.c" 8 5 26#
       ((=)  !sbegin (null  ) ))
       then begin (__retres := (null  )); (raise (Return_label_exc ())) end
       else ());
       begin
       (end_0 :=
        (let _jessie_29 = !sbegin in
        (let _jessie_28 = ct_0_0 in
        (#"/home/work/workspace/self/verker-gh/strsep.c" 11 7 26#
        "expl:Precondition for strpbrk"
        (Function_strpbrk_0.strpbrk_0  _jessie_29 _jessie_28
         voidP_ct_0_17_alloc_table voidP_result_18_alloc_table
         charP_charM_ct_0_17 !charP_charM_result_18 )))));
        begin
        any unit
        requires { true } reads { ct_0_0 }
        ensures {
          (#"/home/work/workspace/self/verker-gh/strsep.c" 12 12 38#
          ((=) (strpbrk !sbegin ct_0_0) !end_0)) } ; () end;
        (if
        (#"/home/work/workspace/self/verker-gh/strsep.c" 13 5 8#
        ((<>)  !end_0 (null  ) ))
        then
         begin
         (tmp := !end_0);
          begin
          (end_0 :=
           (shift_  !end_0
            (Unsafe_int32.to_int 
             (#"strsep.jc" 472 45 57# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) ) ));
           (let _jessie_33 =
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 11 15#
           "expl:Integer cast"
           (Unsafe_int8_of_Unsafe_int32.cast 
            (#"strsep.jc" 473 51 63# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) )) in
           (let _jessie_34 = !tmp in
           (let _jessie_35 = (0) in
           (let _jessie_36 = _jessie_34 in
           (upd  charP_charM_result_18 _jessie_36 _jessie_33 ))))) end end
        else ());
        begin
        (let _jessie_23 = !end_0 in
        (let _jessie_24 = s_0_0 in
        (let _jessie_25 = (0) in
        (let _jessie_26 = _jessie_24 in
        (upd  char_xP_char_xM_s_0_16 _jessie_26 _jessie_23 )))));
         begin (__retres := !sbegin); (raise (Return_label_exc ())) end end
       end end with Return_label_exc _jessie_1 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let strsep_ensures_input_strpbrk_not_null
  #"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38#
  "expl:Function strsep, behavior input_strpbrk_not_null" =
  fun
   (s_0_0 : (pointer char_xP)) (ct_0_0 : (pointer voidP))
   (charP_charM_result_18 : ref (memory voidP Int8.t))
   (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP)))
   (char_xP_s_0_16_alloc_table : (alloc_table char_xP))
   (voidP_ct_0_17_alloc_table : (alloc_table voidP))
   (voidP_result_18_alloc_table : (alloc_table voidP))
   (voidP_result_18_tag_table : (tag_table voidP)) (charP_charM_ct_0_17 :
   (memory voidP Int8.t)) 
   requires {
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ ((<>) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 19 13 26#
    (valid_str ct_0_0 voidP_ct_0_17_alloc_table charP_charM_ct_0_17))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 20 13 22#
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((<=) (offset_min char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((>=) (offset_max char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\ (#"strsep.jc" 397 12 477# ((=) true true)))))))
   /\
   (#"/home/work/workspace/self/verker-gh/strsep.h" 21 13 41#
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ (not ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))
   \/
   (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
   (not
   (valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
   voidP_result_18_alloc_table !charP_charM_result_18)))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"strsep.jc" 420 10 66# "expl:Assigns clause"
       (not_assigns voidP_result_18_alloc_table voidP_result_18_alloc_table
       (old !charP_charM_result_18) !charP_charM_result_18
       (pset_singleton
       (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0))))
      /\
      (#"strsep.jc" 420 10 66# "expl:Assigns clause"
      (not_assigns char_xP_s_0_16_alloc_table char_xP_s_0_16_alloc_table (old
      !char_xP_char_xM_s_0_16) !char_xP_char_xM_s_0_16
      (pset_singleton s_0_0))))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
     "expl:Ensures clause"
     (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
      "expl:Ensures clause"
      ((=) result (select (old !char_xP_char_xM_s_0_16) s_0_0)))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker-gh/strsep.h" 38 15 46#
      "expl:Ensures clause"
      ((=) (select !char_xP_char_xM_s_0_16 s_0_0)
      (shift (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
      (1))))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker-gh/strsep.h" 39 15 45#
      "expl:Ensures clause"
      (Int8.(=)
      (select !charP_charM_result_18
      (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0))
      (#"strsep.jc" 427 35 46# "expl:Integer cast" (Int8.of_int (0)))))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 40 15 33#
     "expl:Ensures clause"
     (valid_str result voidP_result_18_alloc_table !charP_charM_result_18)))))))))))
     }  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); (); (); ();
     (let sbegin = ref (any_pointer  () : (pointer voidP)) in
     (let end_0 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let __retres = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      (sbegin := (acc  !char_xP_char_xM_s_0_16 s_0_0 ));
       (if
       (#"/home/work/workspace/self/verker-gh/strsep.c" 8 5 26#
       ((=)  !sbegin (null  ) ))
       then begin (__retres := (null  )); (raise (Return_label_exc ())) end
       else ());
       begin
       (end_0 :=
        (let _jessie_67 = !sbegin in
        (let _jessie_66 = ct_0_0 in
        (#"/home/work/workspace/self/verker-gh/strsep.c" 11 7 26#
        "expl:Precondition for strpbrk"
        (Function_strpbrk_0.strpbrk_0  _jessie_67 _jessie_66
         voidP_ct_0_17_alloc_table voidP_result_18_alloc_table
         charP_charM_ct_0_17 !charP_charM_result_18 )))));
        begin
        any unit
        requires { true } reads { ct_0_0 }
        ensures {
          (#"/home/work/workspace/self/verker-gh/strsep.c" 12 12 38#
          ((=) (strpbrk !sbegin ct_0_0) !end_0)) } ; () end;
        (if
        (#"/home/work/workspace/self/verker-gh/strsep.c" 13 5 8#
        ((<>)  !end_0 (null  ) ))
        then
         begin
         (tmp := !end_0);
          begin
          (end_0 :=
           (shift_  !end_0
            (Unsafe_int32.to_int 
             (#"strsep.jc" 472 45 57# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) ) ));
           (let _jessie_71 =
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 11 15#
           "expl:Integer cast"
           (Unsafe_int8_of_Unsafe_int32.cast 
            (#"strsep.jc" 473 51 63# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) )) in
           (let _jessie_72 = !tmp in
           (let _jessie_73 = (0) in
           (let _jessie_74 = _jessie_72 in
           (upd  charP_charM_result_18 _jessie_74 _jessie_71 ))))) end end
        else ());
        begin
        (let _jessie_61 = !end_0 in
        (let _jessie_62 = s_0_0 in
        (let _jessie_63 = (0) in
        (let _jessie_64 = _jessie_62 in
        (upd  char_xP_char_xM_s_0_16 _jessie_64 _jessie_61 )))));
         begin (__retres := !sbegin); (raise (Return_label_exc ())) end end
       end end with Return_label_exc _jessie_1 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
  let strsep_ensures_input_strpbrk_null
  #"/home/work/workspace/self/verker-gh/strsep.c" 3 5 38#
  "expl:Function strsep, behavior input_strpbrk_null" =
  fun
   (s_0_0 : (pointer char_xP)) (ct_0_0 : (pointer voidP))
   (charP_charM_result_18 : ref (memory voidP Int8.t))
   (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP)))
   (char_xP_s_0_16_alloc_table : (alloc_table char_xP))
   (voidP_ct_0_17_alloc_table : (alloc_table voidP))
   (voidP_result_18_alloc_table : (alloc_table voidP))
   (voidP_result_18_tag_table : (tag_table voidP)) (charP_charM_ct_0_17 :
   (memory voidP Int8.t)) 
   requires {
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ ((=) (strpbrk (select !char_xP_char_xM_s_0_16 s_0_0) ct_0_0) null))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 19 13 26#
    (valid_str ct_0_0 voidP_ct_0_17_alloc_table charP_charM_ct_0_17))
   /\
   (#"strsep.jc" 397 12 477#
   ((#"/home/work/workspace/self/verker-gh/strsep.h" 20 13 22#
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((<=) (offset_min char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\
    (#"strsep.jc" 397 12 477#
    ((#"strsep.jc" 397 12 477#
     ((>=) (offset_max char_xP_s_0_16_alloc_table s_0_0) (0)))
    /\ (#"strsep.jc" 397 12 477# ((=) true true)))))))
   /\
   (#"/home/work/workspace/self/verker-gh/strsep.h" 21 13 41#
   (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
     voidP_result_18_alloc_table !charP_charM_result_18)
    /\ (not ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))
   \/
   (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
   (not
   (valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
   voidP_result_18_alloc_table !charP_charM_result_18)))))))))) }
   ensures {
     ("expl:Postcondition"
     (((#"strsep.jc" 414 10 21# "expl:Assigns clause"
       (not_assigns voidP_result_18_alloc_table voidP_result_18_alloc_table
       (old !charP_charM_result_18) !charP_charM_result_18 pset_empty))
      /\
      (#"strsep.jc" 414 10 21# "expl:Assigns clause"
      (not_assigns char_xP_s_0_16_alloc_table char_xP_s_0_16_alloc_table (old
      !char_xP_char_xM_s_0_16) !char_xP_char_xM_s_0_16
      (pset_singleton s_0_0))))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
     "expl:Ensures clause"
     (#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
     "expl:Ensures clause"
     ((#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
      "expl:Ensures clause"
      ((=) result (select (old !char_xP_char_xM_s_0_16) s_0_0)))
     /\
     (#"/home/work/workspace/self/verker-gh/strsep.h" 31 15 26#
     "expl:Ensures clause" ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))))))
     }  ->
   'Init:
   (let return = ref (any_pointer  () : (pointer voidP)) in
   try
    begin
    (); (); (); ();
     (let sbegin = ref (any_pointer  () : (pointer voidP)) in
     (let end_0 = ref (any_pointer  () : (pointer voidP)) in
     (let tmp = ref (any_pointer  () : (pointer voidP)) in
     (let __retres = ref (any_pointer  () : (pointer voidP)) in
     try
      begin
      (sbegin := (acc  !char_xP_char_xM_s_0_16 s_0_0 ));
       (if
       (#"/home/work/workspace/self/verker-gh/strsep.c" 8 5 26#
       ((=)  !sbegin (null  ) ))
       then begin (__retres := (null  )); (raise (Return_label_exc ())) end
       else ());
       begin
       (end_0 :=
        (let _jessie_48 = !sbegin in
        (let _jessie_47 = ct_0_0 in
        (#"/home/work/workspace/self/verker-gh/strsep.c" 11 7 26#
        "expl:Precondition for strpbrk"
        (Function_strpbrk_0.strpbrk_0  _jessie_48 _jessie_47
         voidP_ct_0_17_alloc_table voidP_result_18_alloc_table
         charP_charM_ct_0_17 !charP_charM_result_18 )))));
        begin
        any unit
        requires { true } reads { ct_0_0 }
        ensures {
          (#"/home/work/workspace/self/verker-gh/strsep.c" 12 12 38#
          ((=) (strpbrk !sbegin ct_0_0) !end_0)) } ; () end;
        (if
        (#"/home/work/workspace/self/verker-gh/strsep.c" 13 5 8#
        ((<>)  !end_0 (null  ) ))
        then
         begin
         (tmp := !end_0);
          begin
          (end_0 :=
           (shift_  !end_0
            (Unsafe_int32.to_int 
             (#"strsep.jc" 472 45 57# "expl:Integer cast"
             (Unsafe_int32.of_int (1))) ) ));
           (let _jessie_52 =
           (#"/home/work/workspace/self/verker-gh/strsep.c" 14 11 15#
           "expl:Integer cast"
           (Unsafe_int8_of_Unsafe_int32.cast 
            (#"strsep.jc" 473 51 63# "expl:Integer cast"
            (Unsafe_int32.of_int (0))) )) in
           (let _jessie_53 = !tmp in
           (let _jessie_54 = (0) in
           (let _jessie_55 = _jessie_53 in
           (upd  charP_charM_result_18 _jessie_55 _jessie_52 ))))) end end
        else ());
        begin
        (let _jessie_42 = !end_0 in
        (let _jessie_43 = s_0_0 in
        (let _jessie_44 = (0) in
        (let _jessie_45 = _jessie_43 in
        (upd  char_xP_char_xM_s_0_16 _jessie_45 _jessie_42 )))));
         begin (__retres := !sbegin); (raise (Return_label_exc ())) end end
       end end with Return_label_exc _jessie_1 ->
      'Return_label:
      'Return_label: begin (return := !__retres); (raise Return) end end))));
     absurd  end with Return -> !return end)
  
end

theory Logic_type_padding

  use why3.Bool.Bool 
  
  type padding 
  
end

theory Struct_voidP

  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_voidp_tag_id 
  
  predicate frame_tag_struct_voidP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_voidP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_voidP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_voidP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (tag_fresh voidP_tag_table p)
  
  predicate fresh_alloc_struct_voidP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP)) = (alloc_fresh voidP_alloc_table p)
  
  predicate container_of_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_voidP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) voidP_tag)
  
  predicate typeof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) voidP_tag))))
  
  predicate instanceof_singleton_struct_voidP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p voidP_tag)
  
  predicate instanceof_struct_voidP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p voidP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) voidP_tag))))
  
  predicate right_valid_struct_voidP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((>=) (offset_max voidP_alloc_table p) b)
  
  predicate left_valid_struct_voidP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = ((<=) (offset_min voidP_alloc_table p) a)
  
  predicate valid_struct_voidP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  =
     (((<=) (offset_min voidP_alloc_table p) a) /\
     ((>=) (offset_max voidP_alloc_table p) b))
  
  predicate strict_valid_struct_voidP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  =
     (((=) (offset_min voidP_alloc_table p) a) /\
     ((=) (offset_max voidP_alloc_table p) b))
  
end

theory Struct_charP

  use import Struct_voidP 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  use import core.Jessie_charp_tag_id 
  
  predicate frame_tag_struct_charP (p : (pointer voidP)) (old_voidP_tag_table
  : (tag_table voidP)) (voidP_tag_table : (tag_table voidP))
  =
     ((tag_extends old_voidP_tag_table voidP_tag_table) /\
     (alloc_tag_block old_voidP_tag_table voidP_tag_table p))
  
  predicate frame_free_struct_charP (p : (pointer voidP))
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((free_extends old_voidP_alloc_table voidP_alloc_table) /\
     (free_block old_voidP_alloc_table voidP_alloc_table p))
  
  predicate frame_alloc_struct_charP (p : (pointer voidP)) (n : int)
  (old_voidP_alloc_table : (alloc_table voidP)) (voidP_alloc_table :
  (alloc_table voidP))
  =
     ((alloc_extends old_voidP_alloc_table voidP_alloc_table) /\
     (alloc_block old_voidP_alloc_table voidP_alloc_table p n))
  
  predicate fresh_tag_struct_charP (p : (pointer voidP)) (voidP_tag_table :
  (tag_table voidP)) = (fresh_tag_struct_voidP p voidP_tag_table)
  
  predicate fresh_alloc_struct_charP (p : (pointer voidP)) (voidP_alloc_table
  : (alloc_table voidP))
  = (fresh_alloc_struct_voidP p voidP_alloc_table)
  
  predicate container_of_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP)) = true
  
  predicate container_of_struct_charP (p : (pointer voidP)) (l : int) (r :
  int) (voidP_tag_table : (tag_table voidP)) = true
  
  predicate typeof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = ((=) (typeof voidP_tag_table p) charP_tag)
  
  predicate typeof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     (((=) (typeof voidP_tag_table p) charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof voidP_tag_table (shift p i)) charP_tag))))
  
  predicate instanceof_singleton_struct_charP (p : (pointer voidP))
  (voidP_tag_table : (tag_table voidP))
  = (instanceof voidP_tag_table p charP_tag)
  
  predicate instanceof_struct_charP (p : (pointer voidP)) (l : int) (r : int)
  (voidP_tag_table : (tag_table voidP))
  =
     ((instanceof voidP_tag_table p charP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof voidP_tag_table (shift p i) charP_tag))))
  
  predicate right_valid_struct_charP (p : (pointer voidP)) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (right_valid_struct_voidP p b voidP_alloc_table)
  
  predicate left_valid_struct_charP (p : (pointer voidP)) (a : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (left_valid_struct_voidP p a voidP_alloc_table)
  
  predicate valid_struct_charP (p : (pointer voidP)) (a : int) (b : int)
  (voidP_alloc_table : (alloc_table voidP))
  = (valid_struct_voidP p a b voidP_alloc_table)
  
  predicate strict_valid_struct_charP (p : (pointer voidP)) (a : int) (b :
  int) (voidP_alloc_table : (alloc_table voidP))
  = (strict_valid_struct_voidP p a b voidP_alloc_table)
  
end

module Struct_charP_unsafe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_charP_safe

  use import Struct_charP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_charP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_charP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_charP p !voidP_alloc_table))) }
  
  val allocate_struct_charP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_charP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_charP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_charP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
       ((typeof_struct_charP result (0) n !voidP_tag_table) /\
       (container_of_struct_charP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_charP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_charP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_charP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_charP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_charP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_charP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_charP result !voidP_tag_table) /\
      (container_of_singleton_struct_charP result !voidP_tag_table))))))) }
  
end

theory Struct_char_xP

  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_tag_table 
  
  use import core.Jessie_tag_id 
  
  use import core.Jessie_tag 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import core.Jessie_alloc 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  function char_xP_tag  : (tag_id char_xP)
  
  axiom Char_xP_parenttag_bottom :
  (parenttag char_xP_tag bottom_tag)
  
  axiom Char_xP_is_final :
  (forall char_xP_tag_table : (tag_table char_xP).
   (forall p : (pointer char_xP).
    ((instanceof char_xP_tag_table p char_xP_tag) ->
     ((=) (typeof char_xP_tag_table p) char_xP_tag))))
  
  predicate frame_tag_struct_char_xP (p : (pointer char_xP))
  (old_char_xP_tag_table : (tag_table char_xP)) (char_xP_tag_table :
  (tag_table char_xP))
  =
     ((tag_extends old_char_xP_tag_table char_xP_tag_table) /\
     (alloc_tag_block old_char_xP_tag_table char_xP_tag_table p))
  
  predicate frame_free_struct_char_xP (p : (pointer char_xP))
  (old_char_xP_alloc_table : (alloc_table char_xP)) (char_xP_alloc_table :
  (alloc_table char_xP))
  =
     ((free_extends old_char_xP_alloc_table char_xP_alloc_table) /\
     (free_block old_char_xP_alloc_table char_xP_alloc_table p))
  
  predicate frame_alloc_struct_char_xP (p : (pointer char_xP)) (n : int)
  (old_char_xP_alloc_table : (alloc_table char_xP)) (char_xP_alloc_table :
  (alloc_table char_xP))
  =
     ((alloc_extends old_char_xP_alloc_table char_xP_alloc_table) /\
     (alloc_block old_char_xP_alloc_table char_xP_alloc_table p n))
  
  predicate fresh_tag_struct_char_xP (p : (pointer char_xP))
  (char_xP_tag_table : (tag_table char_xP))
  = (tag_fresh char_xP_tag_table p)
  
  predicate fresh_alloc_struct_char_xP (p : (pointer char_xP))
  (char_xP_alloc_table : (alloc_table char_xP))
  = (alloc_fresh char_xP_alloc_table p)
  
  predicate container_of_singleton_struct_char_xP (p : (pointer char_xP))
  (char_xP_tag_table : (tag_table char_xP)) = true
  
  predicate container_of_struct_char_xP (p : (pointer char_xP)) (l : int) (r
  : int) (char_xP_tag_table : (tag_table char_xP)) = true
  
  predicate typeof_singleton_struct_char_xP (p : (pointer char_xP))
  (char_xP_tag_table : (tag_table char_xP))
  = ((=) (typeof char_xP_tag_table p) char_xP_tag)
  
  predicate typeof_struct_char_xP (p : (pointer char_xP)) (l : int) (r : int)
  (char_xP_tag_table : (tag_table char_xP))
  =
     (((=) (typeof char_xP_tag_table p) char_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       ((=) (typeof char_xP_tag_table (shift p i)) char_xP_tag))))
  
  predicate instanceof_singleton_struct_char_xP (p : (pointer char_xP))
  (char_xP_tag_table : (tag_table char_xP))
  = (instanceof char_xP_tag_table p char_xP_tag)
  
  predicate instanceof_struct_char_xP (p : (pointer char_xP)) (l : int) (r :
  int) (char_xP_tag_table : (tag_table char_xP))
  =
     ((instanceof char_xP_tag_table p char_xP_tag) /\
     (forall i : int.
      ((((<=) l i) /\ ((<) i r)) ->
       (instanceof char_xP_tag_table (shift p i) char_xP_tag))))
  
  predicate right_valid_struct_char_xP (p : (pointer char_xP)) (b : int)
  (char_xP_alloc_table : (alloc_table char_xP))
  = ((>=) (offset_max char_xP_alloc_table p) b)
  
  predicate left_valid_struct_char_xP (p : (pointer char_xP)) (a : int)
  (char_xP_alloc_table : (alloc_table char_xP))
  = ((<=) (offset_min char_xP_alloc_table p) a)
  
  predicate valid_struct_char_xP (p : (pointer char_xP)) (a : int) (b : int)
  (char_xP_alloc_table : (alloc_table char_xP))
  =
     (((<=) (offset_min char_xP_alloc_table p) a) /\
     ((>=) (offset_max char_xP_alloc_table p) b))
  
  predicate strict_valid_struct_char_xP (p : (pointer char_xP)) (a : int) (b
  : int) (char_xP_alloc_table : (alloc_table char_xP))
  =
     (((=) (offset_min char_xP_alloc_table p) a) /\
     ((=) (offset_max char_xP_alloc_table p) b))
  
  axiom Char_xP_int : ((=) (int_of_tag char_xP_tag) (4))
  
end

module Struct_char_xP_unsafe

  use import Struct_char_xP 
  
  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_char_xP
  (p : (pointer char_xP)) 
   (char_xP_alloc_table : ref (alloc_table char_xP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/
      (freeable !char_xP_alloc_table p)) }
    writes { char_xP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !char_xP_alloc_table (old !char_xP_alloc_table)))
      \/
      ((frame_free_struct_char_xP p (old !char_xP_alloc_table)
       !char_xP_alloc_table)
      /\ (fresh_alloc_struct_char_xP p !char_xP_alloc_table))) }
  
  val allocate_struct_char_xP_requires
  (n : int) 
   (char_xP_alloc_table : ref (alloc_table char_xP)) 
    (char_xP_tag_table : ref (tag_table char_xP)) : (pointer char_xP)
     requires { ((>=) n (0)) } writes { char_xP_alloc_table,
     char_xP_tag_table }
     ensures {
       ((strict_valid_struct_char_xP result (0) (Int.(-) n (1))
        !char_xP_alloc_table)
       /\
       ((frame_alloc_struct_char_xP result n (old !char_xP_alloc_table)
        !char_xP_alloc_table)
       /\
       ((frame_tag_struct_char_xP result (old !char_xP_tag_table)
        !char_xP_tag_table)
       /\
       ((fresh_alloc_struct_char_xP result (old !char_xP_alloc_table)) /\
       ((fresh_tag_struct_char_xP result (old !char_xP_tag_table)) /\
       ((typeof_struct_char_xP result (0) n !char_xP_tag_table) /\
       (container_of_struct_char_xP result (0) n !char_xP_tag_table))))))) }
  
end

module Struct_char_xP_safe

  use import Struct_char_xP 
  
  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_char_xP
  (p : (pointer char_xP)) 
   (char_xP_alloc_table : ref (alloc_table char_xP)) : unit
    requires { true } writes { char_xP_alloc_table }
    ensures {
      ((((=) p null) /\
       ((=) !char_xP_alloc_table (old !char_xP_alloc_table)))
      \/
      ((frame_free_struct_char_xP p (old !char_xP_alloc_table)
       !char_xP_alloc_table)
      /\ (fresh_alloc_struct_char_xP p !char_xP_alloc_table))) }
  
  val allocate_struct_char_xP
  (n : int) 
   (char_xP_alloc_table : ref (alloc_table char_xP)) 
    (char_xP_tag_table : ref (tag_table char_xP)) : (pointer char_xP)
     requires { true } writes { char_xP_alloc_table, char_xP_tag_table }
     ensures {
       ((strict_valid_struct_char_xP result (0) (Int.(-) n (1))
        !char_xP_alloc_table)
       /\
       ((frame_alloc_struct_char_xP result n (old !char_xP_alloc_table)
        !char_xP_alloc_table)
       /\
       ((frame_tag_struct_char_xP result (old !char_xP_tag_table)
        !char_xP_tag_table)
       /\
       ((fresh_alloc_struct_char_xP result (old !char_xP_alloc_table)) /\
       ((fresh_tag_struct_char_xP result (old !char_xP_tag_table)) /\
       ((typeof_struct_char_xP result (0) n !char_xP_tag_table) /\
       (container_of_struct_char_xP result (0) n !char_xP_tag_table))))))) }
  
  val allocate_singleton_struct_char_xP
  (char_xP_alloc_table : ref (alloc_table char_xP)) 
   (char_xP_tag_table : ref (tag_table char_xP)) : (pointer char_xP)
    requires { true } writes { char_xP_alloc_table, char_xP_tag_table }
    ensures {
      ((strict_valid_struct_char_xP result (0) (0) !char_xP_alloc_table) /\
      ((frame_alloc_struct_char_xP result (1) (old !char_xP_alloc_table)
       !char_xP_alloc_table)
      /\
      ((frame_tag_struct_char_xP result (old !char_xP_tag_table)
       !char_xP_tag_table)
      /\
      ((fresh_alloc_struct_char_xP result (old !char_xP_alloc_table)) /\
      ((fresh_tag_struct_char_xP result (old !char_xP_tag_table)) /\
      ((typeof_singleton_struct_char_xP result !char_xP_tag_table) /\
      (container_of_singleton_struct_char_xP result !char_xP_tag_table)))))))
      }
  
end

module Struct_voidP_unsafe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use import int.Int 
  
  use why3.Bool.Bool 
  
  val free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires {
      (("expl:Deallocation" ((=) p null)) \/ (freeable !voidP_alloc_table p))
      }
    writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP_requires
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { ((>=) n (0)) } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
end

module Struct_voidP_safe

  use import Struct_voidP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_alloc_table 
  
  use int.Int 
  
  use why3.Bool.Bool 
  
  val safe_free_struct_voidP
  (p : (pointer voidP)) 
   (voidP_alloc_table : ref (alloc_table voidP)) : unit
    requires { true } writes { voidP_alloc_table }
    ensures {
      ((((=) p null) /\ ((=) !voidP_alloc_table (old !voidP_alloc_table))) \/
      ((frame_free_struct_voidP p (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\ (fresh_alloc_struct_voidP p !voidP_alloc_table))) }
  
  val allocate_struct_voidP
  (n : int) 
   (voidP_alloc_table : ref (alloc_table voidP)) 
    (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
     requires { true } writes { voidP_alloc_table, voidP_tag_table }
     ensures {
       ((strict_valid_struct_voidP result (0) (Int.(-) n (1))
        !voidP_alloc_table)
       /\
       ((frame_alloc_struct_voidP result n (old !voidP_alloc_table)
        !voidP_alloc_table)
       /\
       ((frame_tag_struct_voidP result (old !voidP_tag_table)
        !voidP_tag_table)
       /\
       ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
       ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
       ((typeof_struct_voidP result (0) n !voidP_tag_table) /\
       (container_of_struct_voidP result (0) n !voidP_tag_table))))))) }
  
  val allocate_singleton_struct_voidP
  (voidP_alloc_table : ref (alloc_table voidP)) 
   (voidP_tag_table : ref (tag_table voidP)) : (pointer voidP)
    requires { true } writes { voidP_alloc_table, voidP_tag_table }
    ensures {
      ((strict_valid_struct_voidP result (0) (0) !voidP_alloc_table) /\
      ((frame_alloc_struct_voidP result (1) (old !voidP_alloc_table)
       !voidP_alloc_table)
      /\
      ((frame_tag_struct_voidP result (old !voidP_tag_table)
       !voidP_tag_table)
      /\
      ((fresh_alloc_struct_voidP result (old !voidP_alloc_table)) /\
      ((fresh_tag_struct_voidP result (old !voidP_tag_table)) /\
      ((typeof_singleton_struct_voidP result !voidP_tag_table) /\
      (container_of_singleton_struct_voidP result !voidP_tag_table))))))) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint64_of_Bit_uint8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint8.to_int n)) \/
     (Bit_int8_of_Bit_uint8.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint8 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { (Int8.in_bounds (Uint8.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint8

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Uint8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Uint64.to_int n)) \/
     (Bit_uint32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint32_of_Bit_uint64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { (Uint32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint64.to_int n)) \/
     (Bit_uint16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint64.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint64.to_int n)) \/
     (Bit_int8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { (Int8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires {
     ((Bit_int64.in_bounds (Uint64.to_int n)) \/
     (Bit_int64_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint64 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { (Int64.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint64.to_int n)) \/
     (Bit_int32_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { (Int32.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint64.to_int n)) \/
     (Bit_int16_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { (Int16.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint64

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Uint32.to_int n)) \/
     (Bit_uint16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint16_of_Bit_uint32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { (Uint16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint32.to_int n)) \/
     (Bit_int8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { (Int8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Uint32.to_int n)) \/
     (Bit_int32_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint32 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { (Int32.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint32.to_int n)) \/
     (Bit_int16_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { (Int16.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint32

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Uint16.to_int n)) \/
     (Bit_int8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_int8_of_Bit_uint16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { (Int8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_uint16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int64.t
   requires { true }
   ensures { ((=) (Int64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_uint16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int32.t
   requires { true }
   ensures { ((=) (Int32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Uint16.to_int n)) \/
     (Bit_int16_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_uint16 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { (Int16.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_uint16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Int16.t
   requires { true }
   ensures { ((=) (Int16.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int64_of_Bit_int8 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int8 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int8 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int8

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires {
     ((Bit_int32.in_bounds (Int64.to_int n)) \/
     (Bit_int32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int32_of_Bit_int64 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { (Int32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int64.to_int n)) \/
     (Bit_int16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int64 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { (Int16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int64

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int16_of_Safe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires {
     ((Bit_int16.in_bounds (Int32.to_int n)) \/
     (Bit_int16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int16_of_Unsafe_bit_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int16_of_Bit_int32 
  
  use enum.Bit_int16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Bit_int16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true }
   ensures {
     (((=) (Int16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int16_of_Safe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { (Int16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int16_of_Unsafe_int32

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int16.t
   requires { true } ensures { ((=) (Int16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint64.to_int n)) \/
     (Bit_uint8_of_Bit_uint64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use Bit_uint8_of_Bit_uint64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint64

  use enum.Uint8 
  
  use enum.Uint64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint64.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint32.to_int n)) \/
     (Bit_uint8_of_Bit_uint32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use Bit_uint8_of_Bit_uint32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint32

  use enum.Uint8 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Uint16.to_int n)) \/
     (Bit_uint8_of_Bit_uint16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use Bit_uint8_of_Bit_uint16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Uint16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { (Uint8.in_bounds (Uint16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_uint16

  use enum.Uint8 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint8.t
   requires { true }
   ensures { ((=) (Uint8.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int8.to_int n)) \/
     (Bit_uint8_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use Bit_uint8_of_Bit_int8 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { (Uint8.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int8

  use enum.Uint8 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int64.to_int n)) \/
     (Bit_uint8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use Bit_uint8_of_Bit_int64 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { (Uint8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int64

  use enum.Uint8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int32.to_int n)) \/
     (Bit_uint8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use Bit_uint8_of_Bit_int32 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { (Uint8.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int32

  use enum.Uint8 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint8_of_Safe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires {
     ((Bit_uint8.in_bounds (Int16.to_int n)) \/
     (Bit_uint8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint8_of_Unsafe_bit_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use Bit_uint8_of_Bit_int16 
  
  use enum.Bit_uint8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Bit_uint8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true }
   ensures {
     (((=) (Uint8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint8_of_Safe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { (Uint8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint8_of_Unsafe_int16

  use enum.Uint8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint8.t
   requires { true } ensures { ((=) (Uint8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use Bit_uint64_of_Bit_uint32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint32.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint32

  use enum.Uint64 
  
  use enum.Uint32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use Bit_uint64_of_Bit_uint16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_uint16

  use enum.Uint64 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int8.to_int n)) \/
     (Bit_uint64_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use Bit_uint64_of_Bit_int8 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { (Uint64.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int8

  use enum.Uint64 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint64.t
   requires { true } ensures { ((=) (Uint64.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int64.to_int n)) \/
     (Bit_uint64_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use Bit_uint64_of_Bit_int64 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { (Uint64.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int64

  use enum.Uint64 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int32.to_int n)) \/
     (Bit_uint64_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use Bit_uint64_of_Bit_int32 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { (Uint64.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int32

  use enum.Uint64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint64_of_Safe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires {
     ((Bit_uint64.in_bounds (Int16.to_int n)) \/
     (Bit_uint64_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint64_of_Unsafe_bit_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use Bit_uint64_of_Bit_int16 
  
  use enum.Bit_uint64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Bit_uint64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures {
     (((=) (Uint64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint64_of_Safe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { (Uint64.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint64_of_Unsafe_int16

  use enum.Uint64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint64.t
   requires { true }
   ensures { ((=) (Uint64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use Bit_uint32_of_Bit_uint16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Uint16.to_int n)))
     /\ ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Uint16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_uint16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_uint16

  use enum.Uint32 
  
  use enum.Uint16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Uint16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Uint16.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int8.to_int n)) \/
     (Bit_uint32_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use Bit_uint32_of_Bit_int8 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { (Uint32.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int8

  use enum.Uint32 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint32.t
   requires { true } ensures { ((=) (Uint32.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int64.to_int n)) \/
     (Bit_uint32_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use Bit_uint32_of_Bit_int64 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { (Uint32.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int64

  use enum.Uint32 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int32.to_int n)) \/
     (Bit_uint32_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use Bit_uint32_of_Bit_int32 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { (Uint32.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int32

  use enum.Uint32 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint32_of_Safe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires {
     ((Bit_uint32.in_bounds (Int16.to_int n)) \/
     (Bit_uint32_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint32_of_Unsafe_bit_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use Bit_uint32_of_Bit_int16 
  
  use enum.Bit_uint32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Bit_uint32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures {
     (((=) (Uint32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint32_of_Safe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { (Uint32.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint32_of_Unsafe_int16

  use enum.Uint32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint32.t
   requires { true }
   ensures { ((=) (Uint32.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int8.to_int n)) \/
     (Bit_uint16_of_Bit_int8.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use Bit_uint16_of_Bit_int8 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int8.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int8.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int8.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { (Uint16.in_bounds (Int8.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int8

  use enum.Uint16 
  
  use enum.Int8 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int8.t) : Uint16.t
   requires { true } ensures { ((=) (Uint16.to_int result) (Int8.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int64.to_int n)) \/
     (Bit_uint16_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use Bit_uint16_of_Bit_int64 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int64.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { (Uint16.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int64

  use enum.Uint16 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int32.to_int n)) \/
     (Bit_uint16_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use Bit_uint16_of_Bit_int32 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int32.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { (Uint16.in_bounds (Int32.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int32

  use enum.Uint16 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_uint16_of_Safe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires {
     ((Bit_uint16.in_bounds (Int16.to_int n)) \/
     (Bit_uint16_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_uint16_of_Unsafe_bit_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use Bit_uint16_of_Bit_int16 
  
  use enum.Bit_uint16 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Bit_uint16.normalize (Int16.to_int n))) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures {
     (((=) (Uint16.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_uint16_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_uint16_of_Safe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { (Uint16.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_uint16_of_Unsafe_int16

  use enum.Uint16 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Uint16.t
   requires { true }
   ensures { ((=) (Uint16.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int64.to_int n)) \/
     (Bit_int8_of_Bit_int64.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use Bit_int8_of_Bit_int64 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int64.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int64.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int64.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { (Int8.in_bounds (Int64.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int64

  use enum.Int8 
  
  use enum.Int64 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int64.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int64.to_int n)) }
  
end

module Safe_bit_int8_of_Safe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int32.to_int n)) \/
     (Bit_int8_of_Bit_int32.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int32

  use enum.Int8 
  
  use enum.Int32 
  
  use Bit_int8_of_Bit_int32 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_bit_int8_of_Safe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires {
     ((Bit_int8.in_bounds (Int16.to_int n)) \/
     (Bit_int8_of_Bit_int16.is_safe n)) }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int8_of_Unsafe_bit_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use Bit_int8_of_Bit_int16 
  
  use enum.Bit_int8 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Bit_int8.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true }
   ensures {
     (((=) (Int8.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int8_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int8_of_Safe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { (Int8.in_bounds (Int16.to_int n)) }
   ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int8_of_Unsafe_int16

  use enum.Int8 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int8.t
   requires { true } ensures { ((=) (Int8.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use Bit_int64_of_Bit_int32 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int32.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int32.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int32.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int32

  use enum.Int64 
  
  use enum.Int32 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int32.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int32.to_int n)) }
  
end

module Safe_bit_int64_of_Safe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int64_of_Unsafe_bit_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use Bit_int64_of_Bit_int16 
  
  use enum.Bit_int64 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Bit_int64.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true }
   ensures {
     (((=) (Int64.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int64_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int64_of_Safe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int64_of_Unsafe_int16

  use enum.Int64 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int64.t
   requires { true } ensures { ((=) (Int64.to_int result) (Int16.to_int n)) }
  
end

module Safe_bit_int32_of_Safe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Unsafe_bit_int32_of_Unsafe_bit_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use Bit_int32_of_Bit_int16 
  
  use enum.Bit_int32 
  
  use why3.Bool.Bool 
  
  val cast_modulo
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Bit_int32.normalize (Int16.to_int n))) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true }
   ensures {
     (((=) (Int32.to_int result) (Int16.to_int n)) /\
     ((=) result (Bit_int32_of_Bit_int16.cast_modulo n))) }
  
end

module Safe_int32_of_Safe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Unsafe_int32_of_Unsafe_int16

  use enum.Int32 
  
  use enum.Int16 
  
  use why3.Bool.Bool 
  
  val cast
  (n : Int16.t) : Int32.t
   requires { true } ensures { ((=) (Int32.to_int result) (Int16.to_int n)) }
  
end

module Function_strlen_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires { true }
     ensures {
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strsep.jc" 126 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 84 12 64#
       "expl:Ensures clause"
       (forall i_5 : int.
        ((((<=) (0) i_5) /\ ((<) i_5 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_5))
         (#"strsep.jc" 130 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strlen_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use why3.Bool.Bool 
  
  val strlen_0
  (s_0 : (pointer voidP)) 
   (voidP_s_4_alloc_table : (alloc_table voidP)) 
    (charP_charM_s_4 : (memory voidP Int8.t)) : Uint64.t
     requires {
       ("expl:External"
       (#"/home/work/workspace/self/verker-gh/strlen.h" 80 13 25#
       "expl:Requires clause"
       (valid_str s_0 voidP_s_4_alloc_table charP_charM_s_4))) }
     ensures {
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
        "expl:Ensures clause"
        (Uint64.(=) result (strlen s_0 charP_charM_s_4)))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 82 12 32#
       "expl:Ensures clause"
       ((#"/home/work/workspace/self/verker-gh/strlen.h" 83 12 30#
        "expl:Ensures clause"
        (Int8.(=) (select charP_charM_s_4 (shift s_0 (Uint64.to_int result)))
        (#"strsep.jc" 126 33 44# "expl:Integer cast" (Int8.of_int (0)))))
       /\
       (#"/home/work/workspace/self/verker-gh/strlen.h" 84 12 64#
       "expl:Ensures clause"
       (forall i_5 : int.
        ((((<=) (0) i_5) /\ ((<) i_5 (Uint64.to_int result))) ->
         (Int8.(<>) (select charP_charM_s_4 (shift s_0 i_5))
         (#"strsep.jc" 130 65 76# "expl:Integer cast" (Int8.of_int (0))))))))))))
       }
  
end

module Function_strspn_0

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrSpn 
  
  use why3.Bool.Bool 
  
  val strspn_0
  (s_1 : (pointer voidP)) 
   (accept_0 : (pointer voidP)) 
    (voidP_accept_9_alloc_table : (alloc_table voidP)) 
     (voidP_s_1_8_alloc_table : (alloc_table voidP)) 
      (charP_charM_accept_9 : (memory voidP Int8.t)) 
       (charP_charM_s_1_8 : (memory voidP Int8.t)) : Uint64.t
        requires { true }
        ensures {
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 24#
           "expl:Ensures clause"
           (Uint64.(<=) (#"strsep.jc" 215 31 44# "expl:Integer cast"
           (Uint64.of_int (0))) result))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 63 17 37#
           "expl:Ensures clause"
           (Uint64.(<=) result (strlen s_1 charP_charM_s_1_8)))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 64 12 87#
           "expl:Ensures clause"
           (forall t : (pointer voidP).
            (((same_block accept_0 t) /\
             (((<=) (sub_pointer accept_0 t) (0)) /\
             ((same_block t
              (shift accept_0
              (Uint64.to_int (strlen accept_0 charP_charM_accept_9))))
             /\
             ((<)
             (sub_pointer t
             (shift accept_0
             (Uint64.to_int (strlen accept_0 charP_charM_accept_9)))) (0)))))
             ->
             (Int8.(<>)
             (select charP_charM_s_1_8 (shift s_1 (Uint64.to_int result)))
             (select charP_charM_accept_9 t)))))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 65 12 134#
           "expl:Ensures clause"
           (forall p_0 : (pointer voidP).
            (((same_block s_1 p_0) /\
             (((<=) (sub_pointer s_1 p_0) (0)) /\
             ((same_block p_0 (shift s_1 (Uint64.to_int result))) /\
             ((<) (sub_pointer p_0 (shift s_1 (Uint64.to_int result))) (0)))))
             ->
             (exists t_0 : (pointer voidP).
              ((same_block accept_0 t_0) /\
              (((<=) (sub_pointer accept_0 t_0) (0)) /\
              ((same_block t_0
               (shift accept_0
               (Uint64.to_int (strlen accept_0 charP_charM_accept_9))))
              /\
              (((<)
               (sub_pointer t_0
               (shift accept_0
               (Uint64.to_int (strlen accept_0 charP_charM_accept_9)))) (0))
              /\
              (Int8.(=) (select charP_charM_s_1_8 p_0)
              (select charP_charM_accept_9 t_0))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 67 12 40#
          "expl:Ensures clause"
          ((=) (Uint64.to_int result) (strspn s_1 accept_0)))))))))))) }
  
end

module Function_strspn_0_safe

  use enum.Uint64 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrSpn 
  
  use why3.Bool.Bool 
  
  val strspn_0
  (s_1 : (pointer voidP)) 
   (accept_0 : (pointer voidP)) 
    (voidP_accept_9_alloc_table : (alloc_table voidP)) 
     (voidP_s_1_8_alloc_table : (alloc_table voidP)) 
      (charP_charM_accept_9 : (memory voidP Int8.t)) 
       (charP_charM_s_1_8 : (memory voidP Int8.t)) : Uint64.t
        requires {
          ("expl:External"
          (#"strsep.jc" 211 12 92# "expl:Requires clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 60 13 25#
           "expl:Requires clause"
           (valid_str s_1 voidP_s_1_8_alloc_table charP_charM_s_1_8))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 61 13 30#
          "expl:Requires clause"
          (valid_str accept_0 voidP_accept_9_alloc_table
          charP_charM_accept_9))))) }
        ensures {
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 24#
           "expl:Ensures clause"
           (Uint64.(<=) (#"strsep.jc" 215 31 44# "expl:Integer cast"
           (Uint64.of_int (0))) result))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 63 17 37#
           "expl:Ensures clause"
           (Uint64.(<=) result (strlen s_1 charP_charM_s_1_8)))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 64 12 87#
           "expl:Ensures clause"
           (forall t : (pointer voidP).
            (((same_block accept_0 t) /\
             (((<=) (sub_pointer accept_0 t) (0)) /\
             ((same_block t
              (shift accept_0
              (Uint64.to_int (strlen accept_0 charP_charM_accept_9))))
             /\
             ((<)
             (sub_pointer t
             (shift accept_0
             (Uint64.to_int (strlen accept_0 charP_charM_accept_9)))) (0)))))
             ->
             (Int8.(<>)
             (select charP_charM_s_1_8 (shift s_1 (Uint64.to_int result)))
             (select charP_charM_accept_9 t)))))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 63 12 37#
          "expl:Ensures clause"
          ((#"/home/work/workspace/self/verker-gh/strspn.h" 65 12 134#
           "expl:Ensures clause"
           (forall p_0 : (pointer voidP).
            (((same_block s_1 p_0) /\
             (((<=) (sub_pointer s_1 p_0) (0)) /\
             ((same_block p_0 (shift s_1 (Uint64.to_int result))) /\
             ((<) (sub_pointer p_0 (shift s_1 (Uint64.to_int result))) (0)))))
             ->
             (exists t_0 : (pointer voidP).
              ((same_block accept_0 t_0) /\
              (((<=) (sub_pointer accept_0 t_0) (0)) /\
              ((same_block t_0
               (shift accept_0
               (Uint64.to_int (strlen accept_0 charP_charM_accept_9))))
              /\
              (((<)
               (sub_pointer t_0
               (shift accept_0
               (Uint64.to_int (strlen accept_0 charP_charM_accept_9)))) (0))
              /\
              (Int8.(=) (select charP_charM_s_1_8 p_0)
              (select charP_charM_accept_9 t_0))))))))))
          /\
          (#"/home/work/workspace/self/verker-gh/strspn.h" 67 12 40#
          "expl:Ensures clause"
          ((=) (Uint64.to_int result) (strspn s_1 accept_0)))))))))))) }
  
end

module Function_strsep

  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrPBrk 
  
  use why3.Bool.Bool 
  
  val strsep
  (s_0_0 : (pointer char_xP)) 
   (ct_0_0 : (pointer voidP)) 
    (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP))) 
     (charP_charM_result_18 : ref (memory voidP Int8.t)) 
      (voidP_result_18_alloc_table : (alloc_table voidP)) 
       (voidP_ct_0_17_alloc_table : (alloc_table voidP)) 
        (char_xP_s_0_16_alloc_table : (alloc_table char_xP)) 
         (voidP_result_18_tag_table : (tag_table voidP)) 
          (charP_charM_ct_0_17 : (memory voidP Int8.t)) : (pointer voidP)
           requires { true } reads { charP_charM_result_18,
           char_xP_char_xM_s_0_16 } writes { charP_charM_result_18,
           char_xP_char_xM_s_0_16 }
           ensures {
             (((allocated voidP_result_18_alloc_table result) ->
               (((=) (typeof voidP_result_18_tag_table result) charP_tag) /\
               (forall i : int.
                ((((<=) (offset_min voidP_result_18_alloc_table result) i) /\
                 ((<) i (offset_max voidP_result_18_alloc_table result))) ->
                 ((=) (typeof voidP_result_18_tag_table (shift result i))
                 charP_tag)))))
             /\
             ((((valid_str (select (old !char_xP_char_xM_s_0_16) s_0_0)
                voidP_result_18_alloc_table (old !charP_charM_result_18))
               /\
               ((<>)
               (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
               null)) ->
               (((#"strsep.jc" 420 10 66# "expl:Assigns clause"
                 (not_assigns voidP_result_18_alloc_table
                 voidP_result_18_alloc_table (old !charP_charM_result_18)
                 !charP_charM_result_18
                 (pset_singleton
                 (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0)
                 ct_0_0))))
                /\
                (#"strsep.jc" 420 10 66# "expl:Assigns clause"
                (not_assigns char_xP_s_0_16_alloc_table
                char_xP_s_0_16_alloc_table (old !char_xP_char_xM_s_0_16)
                !char_xP_char_xM_s_0_16 (pset_singleton s_0_0))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
                "expl:Ensures clause"
                ((=) result (select (old !char_xP_char_xM_s_0_16) s_0_0)))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 38 15 46#
                "expl:Ensures clause"
                ((=) (select !char_xP_char_xM_s_0_16 s_0_0)
                (shift
                (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
                (1))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 39 15 45#
                "expl:Ensures clause"
                (Int8.(=)
                (select !charP_charM_result_18
                (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0))
                (#"strsep.jc" 427 35 46# "expl:Integer cast" (Int8.of_int
                (0)))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 40 15 33#
               "expl:Ensures clause"
               (valid_str result voidP_result_18_alloc_table
               !charP_charM_result_18)))))))))))
             /\
             ((((valid_str (select (old !char_xP_char_xM_s_0_16) s_0_0)
                voidP_result_18_alloc_table (old !charP_charM_result_18))
               /\
               ((=)
               (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
               null)) ->
               (((#"strsep.jc" 414 10 21# "expl:Assigns clause"
                 (not_assigns voidP_result_18_alloc_table
                 voidP_result_18_alloc_table (old !charP_charM_result_18)
                 !charP_charM_result_18 pset_empty))
                /\
                (#"strsep.jc" 414 10 21# "expl:Assigns clause"
                (not_assigns char_xP_s_0_16_alloc_table
                char_xP_s_0_16_alloc_table (old !char_xP_char_xM_s_0_16)
                !char_xP_char_xM_s_0_16 (pset_singleton s_0_0))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
               "expl:Ensures clause"
               (#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
                "expl:Ensures clause"
                ((=) result (select (old !char_xP_char_xM_s_0_16) s_0_0)))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 31 15 26#
               "expl:Ensures clause"
               ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))))))
             /\
             (((=) (select (old !char_xP_char_xM_s_0_16) s_0_0) null) ->
              (((#"strsep.jc" 409 10 18# "expl:Assigns clause"
                (not_assigns voidP_result_18_alloc_table
                voidP_result_18_alloc_table (old !charP_charM_result_18)
                !charP_charM_result_18 pset_empty))
               /\
               (#"strsep.jc" 409 10 18# "expl:Assigns clause"
               (not_assigns char_xP_s_0_16_alloc_table
               char_xP_s_0_16_alloc_table (old !char_xP_char_xM_s_0_16)
               !char_xP_char_xM_s_0_16 pset_empty)))
              /\
              (#"/home/work/workspace/self/verker-gh/strsep.h" 25 15 31#
              "expl:Ensures clause" ((=) result null))))))) }
  
end

module Function_strsep_safe

  use import Root_char_xP 
  
  use import ref.Ref 
  
  use import core.Jessie_voidp 
  
  use import core.Jessie_tag_table_type 
  
  use import core.Jessie_pset 
  
  use import core.Jessie_pointer 
  
  use import core.Jessie_memory 
  
  use import core.Jessie_charp_tag_id 
  
  use import core.Jessie_assigns 
  
  use import core.Jessie_allocable 
  
  use import core.Jessie_alloc_table 
  
  use enum.Int8 
  
  use import int.Int 
  
  use import Axiomatic_Strlen 
  
  use import Axiomatic_StrPBrk 
  
  use why3.Bool.Bool 
  
  val strsep
  (s_0_0 : (pointer char_xP)) 
   (ct_0_0 : (pointer voidP)) 
    (char_xP_char_xM_s_0_16 : ref (memory char_xP (pointer voidP))) 
     (charP_charM_result_18 : ref (memory voidP Int8.t)) 
      (voidP_result_18_alloc_table : (alloc_table voidP)) 
       (voidP_ct_0_17_alloc_table : (alloc_table voidP)) 
        (char_xP_s_0_16_alloc_table : (alloc_table char_xP)) 
         (voidP_result_18_tag_table : (tag_table voidP)) 
          (charP_charM_ct_0_17 : (memory voidP Int8.t)) : (pointer voidP)
           requires {
             ("expl:Internal"
             (#"strsep.jc" 397 12 477# "expl:Requires clause"
             ((#"/home/work/workspace/self/verker-gh/strsep.h" 19 13 26#
              "expl:Requires clause"
              (valid_str ct_0_0 voidP_ct_0_17_alloc_table
              charP_charM_ct_0_17))
             /\
             (#"strsep.jc" 397 12 477# "expl:Requires clause"
             ((#"/home/work/workspace/self/verker-gh/strsep.h" 20 13 22#
              "expl:Requires clause"
              (#"strsep.jc" 397 12 477# "expl:Requires clause"
              ((#"strsep.jc" 397 12 477# "expl:Requires clause"
               ((<=) (offset_min char_xP_s_0_16_alloc_table s_0_0) (0)))
              /\
              (#"strsep.jc" 397 12 477# "expl:Requires clause"
              ((#"strsep.jc" 397 12 477# "expl:Requires clause"
               ((>=) (offset_max char_xP_s_0_16_alloc_table s_0_0) (0)))
              /\
              (#"strsep.jc" 397 12 477# "expl:Requires clause"
              ((=) true true)))))))
             /\
             (#"/home/work/workspace/self/verker-gh/strsep.h" 21 13 41#
             "expl:Requires clause"
             (((valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
               voidP_result_18_alloc_table !charP_charM_result_18)
              /\ (not ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))
             \/
             (((=) (select !char_xP_char_xM_s_0_16 s_0_0) null) /\
             (not
             (valid_str (select !char_xP_char_xM_s_0_16 s_0_0)
             voidP_result_18_alloc_table !charP_charM_result_18)))))))))) }
           reads { charP_charM_result_18, char_xP_char_xM_s_0_16 } writes {
           charP_charM_result_18, char_xP_char_xM_s_0_16 }
           ensures {
             (((allocated voidP_result_18_alloc_table result) ->
               (((=) (typeof voidP_result_18_tag_table result) charP_tag) /\
               (forall i : int.
                ((((<=) (offset_min voidP_result_18_alloc_table result) i) /\
                 ((<) i (offset_max voidP_result_18_alloc_table result))) ->
                 ((=) (typeof voidP_result_18_tag_table (shift result i))
                 charP_tag)))))
             /\
             ((((valid_str (select (old !char_xP_char_xM_s_0_16) s_0_0)
                voidP_result_18_alloc_table (old !charP_charM_result_18))
               /\
               ((<>)
               (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
               null)) ->
               (((#"strsep.jc" 420 10 66# "expl:Assigns clause"
                 (not_assigns voidP_result_18_alloc_table
                 voidP_result_18_alloc_table (old !charP_charM_result_18)
                 !charP_charM_result_18
                 (pset_singleton
                 (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0)
                 ct_0_0))))
                /\
                (#"strsep.jc" 420 10 66# "expl:Assigns clause"
                (not_assigns char_xP_s_0_16_alloc_table
                char_xP_s_0_16_alloc_table (old !char_xP_char_xM_s_0_16)
                !char_xP_char_xM_s_0_16 (pset_singleton s_0_0))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
                "expl:Ensures clause"
                ((=) result (select (old !char_xP_char_xM_s_0_16) s_0_0)))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 38 15 46#
                "expl:Ensures clause"
                ((=) (select !char_xP_char_xM_s_0_16 s_0_0)
                (shift
                (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
                (1))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 37 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 39 15 45#
                "expl:Ensures clause"
                (Int8.(=)
                (select !charP_charM_result_18
                (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0))
                (#"strsep.jc" 427 35 46# "expl:Integer cast" (Int8.of_int
                (0)))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 40 15 33#
               "expl:Ensures clause"
               (valid_str result voidP_result_18_alloc_table
               !charP_charM_result_18)))))))))))
             /\
             ((((valid_str (select (old !char_xP_char_xM_s_0_16) s_0_0)
                voidP_result_18_alloc_table (old !charP_charM_result_18))
               /\
               ((=)
               (strpbrk (select (old !char_xP_char_xM_s_0_16) s_0_0) ct_0_0)
               null)) ->
               (((#"strsep.jc" 414 10 21# "expl:Assigns clause"
                 (not_assigns voidP_result_18_alloc_table
                 voidP_result_18_alloc_table (old !charP_charM_result_18)
                 !charP_charM_result_18 pset_empty))
                /\
                (#"strsep.jc" 414 10 21# "expl:Assigns clause"
                (not_assigns char_xP_s_0_16_alloc_table
                char_xP_s_0_16_alloc_table (old !char_xP_char_xM_s_0_16)
                !char_xP_char_xM_s_0_16 (pset_singleton s_0_0))))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
               "expl:Ensures clause"
               (#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
               "expl:Ensures clause"
               ((#"/home/work/workspace/self/verker-gh/strsep.h" 30 15 34#
                "expl:Ensures clause"
                ((=) result (select (old !char_xP_char_xM_s_0_16) s_0_0)))
               /\
               (#"/home/work/workspace/self/verker-gh/strsep.h" 31 15 26#
               "expl:Ensures clause"
               ((=) (select !char_xP_char_xM_s_0_16 s_0_0) null)))))))
             /\
             (((=) (select (old !char_xP_char_xM_s_0_16) s_0_0) null) ->
              (((#"strsep.jc" 409 10 18# "expl:Assigns clause"
                (not_assigns voidP_result_18_alloc_table
                voidP_result_18_alloc_table (old !charP_charM_result_18)
                !charP_charM_result_18 pset_empty))
               /\
               (#"strsep.jc" 409 10 18# "expl:Assigns clause"
               (not_assigns char_xP_s_0_16_alloc_table
               char_xP_s_0_16_alloc_table (old !char_xP_char_xM_s_0_16)
               !char_xP_char_xM_s_0_16 pset_empty)))
              /\
              (#"/home/work/workspace/self/verker-gh/strsep.h" 25 15 31#
              "expl:Ensures clause" ((=) result null))))))) }
  
end
