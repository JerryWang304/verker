(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require Enum_intf.
Require Enum.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require Int8.
Require Uint64.
Require Jessie_pointer.
Require Jessie_alloc_table.
Require Jessie_memory.
Require map.Map.
Require Jessie_tag_id.
Require Jessie_tag_table_type.
Require Jessie_voidp.

Parameter strlen: (Jessie_pointer.pointer Jessie_voidp.voidP) -> (map.Map.map
  (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t) -> Uint64.t.

Axiom strlen_def : forall (s_0:(Jessie_pointer.pointer Jessie_voidp.voidP))
  (charP_charM_s_0_3_at_L:(map.Map.map (Jessie_pointer.pointer
  Jessie_voidp.voidP) Int8.t)), (((map.Map.get charP_charM_s_0_3_at_L
  (Jessie_pointer.shift s_0 0%Z)) = (Int8.of_int 0%Z)) -> ((strlen s_0
  charP_charM_s_0_3_at_L) = (Uint64.of_int 0%Z))) /\
  ((~ ((map.Map.get charP_charM_s_0_3_at_L (Jessie_pointer.shift s_0
  0%Z)) = (Int8.of_int 0%Z))) -> ((strlen s_0
  charP_charM_s_0_3_at_L) = (Uint64.of_int (1%Z + (Uint64.to_int (strlen (Jessie_pointer.shift s_0
  1%Z) charP_charM_s_0_3_at_L)))%Z))).

(* Why3 assumption *)
Definition valid_str (s:(Jessie_pointer.pointer Jessie_voidp.voidP))
  (voidP_s_2_alloc_table_at_L:(Jessie_alloc_table.alloc_table
  Jessie_voidp.voidP)) (charP_charM_s_2_at_L:(map.Map.map
  (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t)): Prop :=
  exists n_1_0:Uint64.t, ((map.Map.get charP_charM_s_2_at_L
  (Jessie_pointer.shift s (Uint64.to_int n_1_0))) = (Int8.of_int 0%Z)) /\
  ((0%Z <= (Uint64.to_int n_1_0))%Z ->
  (((Jessie_alloc_table.offset_min voidP_s_2_alloc_table_at_L s) <= 0%Z)%Z /\
  ((Jessie_alloc_table.offset_max voidP_s_2_alloc_table_at_L
  s) >= (Uint64.to_int n_1_0))%Z)).

Parameter strchr: (Jessie_pointer.pointer Jessie_voidp.voidP) -> Int8.t ->
  (map.Map.map (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t) ->
  (Jessie_pointer.pointer Jessie_voidp.voidP).

Axiom strchr_def : forall (str:(Jessie_pointer.pointer Jessie_voidp.voidP))
  (c:Int8.t) (charP_charM_str_11_at_L:(map.Map.map (Jessie_pointer.pointer
  Jessie_voidp.voidP) Int8.t)), (((map.Map.get charP_charM_str_11_at_L
  str) = c) -> ((strchr str c charP_charM_str_11_at_L) = str)) /\
  ((~ ((map.Map.get charP_charM_str_11_at_L str) = c)) ->
  ((((map.Map.get charP_charM_str_11_at_L str) = (Int8.of_int 0%Z)) ->
  ((strchr str c
  charP_charM_str_11_at_L) = (Jessie_pointer.null : (Jessie_pointer.pointer
  Jessie_voidp.voidP)))) /\ ((~ ((map.Map.get charP_charM_str_11_at_L
  str) = (Int8.of_int 0%Z))) -> ((strchr str c
  charP_charM_str_11_at_L) = (strchr (Jessie_pointer.shift str 1%Z) c
  charP_charM_str_11_at_L))))).

Axiom Valid_str_shift : forall (voidP_s_3_81_alloc_table_at_L:(Jessie_alloc_table.alloc_table
  Jessie_voidp.voidP)), forall (charP_charM_s_3_81_at_L:(map.Map.map
  (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t)),
  forall (s_3_1:(Jessie_pointer.pointer Jessie_voidp.voidP)), ((valid_str
  s_3_1 voidP_s_3_81_alloc_table_at_L charP_charM_s_3_81_at_L) /\
  ~ ((map.Map.get charP_charM_s_3_81_at_L (Jessie_pointer.shift s_3_1
  0%Z)) = (Int8.of_int 0%Z))) -> ((valid_str (Jessie_pointer.shift s_3_1 1%Z)
  voidP_s_3_81_alloc_table_at_L charP_charM_s_3_81_at_L) /\
  ((Uint64.to_int (strlen (Jessie_pointer.shift s_3_1 1%Z)
  charP_charM_s_3_81_at_L)) = ((Uint64.to_int (strlen s_3_1
  charP_charM_s_3_81_at_L)) - 1%Z)%Z)).

Axiom Strchr_same_block : forall (charP_charM_s_4_82_at_L:(map.Map.map
  (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t)),
  forall (s_4_0:(Jessie_pointer.pointer Jessie_voidp.voidP)),
  forall (c_4_0:Int8.t), (~ ((strchr s_4_0 c_4_0
  charP_charM_s_4_82_at_L) = (Jessie_pointer.null : (Jessie_pointer.pointer
  Jessie_voidp.voidP)))) -> (Jessie_pointer.same_block (strchr s_4_0 c_4_0
  charP_charM_s_4_82_at_L) s_4_0).

(* Why3 goal *)
Theorem Strchr_skipped : forall (voidP_str_4_86_alloc_table_at_L:(Jessie_alloc_table.alloc_table
  Jessie_voidp.voidP)), forall (charP_charM_str_4_86_at_L:(map.Map.map
  (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t)),
  forall (str_4:(Jessie_pointer.pointer Jessie_voidp.voidP)),
  forall (c_5:Int8.t), forall (i_1:Uint64.t), ((valid_str str_4
  voidP_str_4_86_alloc_table_at_L charP_charM_str_4_86_at_L) /\
  ((~ ((strchr str_4 c_5
  charP_charM_str_4_86_at_L) = (Jessie_pointer.null : (Jessie_pointer.pointer
  Jessie_voidp.voidP)))) /\ ((Uint64.infix_lseq (Uint64.of_int 0%Z) i_1) /\
  (((Uint64.to_int i_1) < (Jessie_pointer.sub_pointer (strchr str_4 c_5
  charP_charM_str_4_86_at_L) str_4))%Z /\
  ((Jessie_pointer.sub_pointer (strchr str_4 c_5 charP_charM_str_4_86_at_L)
  str_4) <= (Uint64.to_int (strlen str_4
  charP_charM_str_4_86_at_L)))%Z)))) ->
  ~ ((map.Map.get charP_charM_str_4_86_at_L (Jessie_pointer.shift str_4
  (Uint64.to_int i_1))) = c_5).
(* Why3 intros voidP_str_4_86_alloc_table_at_L charP_charM_str_4_86_at_L
        str_4 c_5 i_1 (h1,(h2,(h3,(h4,h5)))). *)
intros voidP_str_4_82_alloc_table_at_L charP_charM_str_4_82_at_L str_4 c_4_0
i_1 (h1,(h2,(h3,(h4,h5)))).
Definition P (i : int) :=
  forall (a :(Jessie_alloc_table.alloc_table Jessie_voidp.voidP)),
  forall (m :(map.Map.map (Jessie_pointer.pointer Jessie_voidp.voidP) Int8.t)),
  forall (s :(Jessie_pointer.pointer Jessie_voidp.voidP)),
  forall (c :Int8.t),
    (valid_str s a m) /\
    ((~ ((strchr s c m) =
        (Jessie_pointer.null : (Jessie_pointer.pointer  Jessie_voidp.voidP)))) /\
    ((0 <= i)%Z /\
    (((i < (Jessie_pointer.sub_pointer (strchr s c m) s))%Z /\
    ((Jessie_pointer.sub_pointer (strchr s c m) s) <=
     (Uint64.to_int (strlen s m)))%Z)))) ->
    ~ ((map.Map.get m (Jessie_pointer.shift s i)) = c).
specialize Wf_Z.natlike_rec3 with (P := P) as Ind.
assert (P 0) as Base.
  unfold P.
  intros a m s c Valid.
  unfold not.
  specialize strchr_def with
    (str := s) (c := c) (charP_charM_str_11_at_L := m) as Def.
  intro Is_c.
  assert (strchr s c m = s) as First.
    apply Def.
    rewrite Jessie_pointer.Shift_def2 in Is_c.
    assumption.
  rewrite First in Valid.
  rewrite Jessie_pointer.Sub_pointer_self in Valid.
  omega.
assert (forall z : int, (0 < z)%Z -> P (Z.pred z) -> P z) as Step.
  intros z Gt0 Pred.
  unfold P.
  intros a m s c Valid.
  assert (Jessie_pointer.shift (Jessie_pointer.shift s 1%Z) (z - 1)%Z =
          Jessie_pointer.shift s z) as Same.
    rewrite Jessie_pointer.Shift_def1.
    assert (1 + (z - 1) = z)%Z as H. omega. rewrite H. trivial.
  rewrite <- Same.
  unfold P in Pred.
  specialize Pred with
   (a := a) (m := m).
  assert (z - 1 = Z.pred z)%Z as H. omega. rewrite H.
  apply Pred.
  assert (~ (map.Map.get m s) = c) as Neqc.
    unfold not.
    intro Eqc.
    specialize strchr_def with
      (str := s) (c := c) (charP_charM_str_11_at_L := m) as Def.
    rewrite Eqc in Def. destruct Def as [Eq Neq]. lapply Eq. intro Eq'.
   rewrite Eq' in Valid.
   rewrite Jessie_pointer.Sub_pointer_self in Valid. omega. trivial.
  assert (Map.get m s <> Int8.of_int 0) as Nonz.
    unfold not. intro Eq0.
    specialize strchr_def with
      (str := s) (c := c) (charP_charM_str_11_at_L := m) as Def.
    destruct Def as [Eqc' Neqc'].
    assert (strchr s c m = Jessie_pointer.null) as Contr.
      apply Neqc'. assumption. assumption.
    destruct Valid as [_ [Nonnull _]]. auto.
  split.
  apply Valid_str_shift.
    split. destruct Valid as [Valid Range]. assumption.
    rewrite Jessie_pointer.Shift_def2. assumption.
  assert (strchr s c m = strchr (Jessie_pointer.shift s 1) c m) as Next.
    specialize strchr_def with
      (str := s) (c := c) (charP_charM_str_11_at_L := m)  as Def.
    destruct Def as [Eqc' Neqc']. lapply Neqc'.
    intros [Z' Nonz']. lapply Nonz'. auto. assumption. assumption.
  rewrite* <- Next. split.
  tauto.
  split.
  omega.
  split.
  rewrite Jessie_pointer.Sub_pointer_shift_right. omega.
  apply Strchr_same_block. tauto.
  rewrite Jessie_pointer.Sub_pointer_shift_right.
  specialize Valid_str_shift with
   (voidP_s_3_81_alloc_table_at_L := a)
   (charP_charM_s_3_81_at_L := m)
   (s_3_1 := s) as Shift.
  lapply Shift. omega.
  split.
  tauto. rewrite Jessie_pointer.Shift_def2. tauto.
  apply Strchr_same_block. tauto.
assert (forall z : int, (0 <= z)%Z -> P z) as Lemma.
  apply Ind. tauto. tauto.
unfold P in Lemma.
apply Lemma with (a := voidP_str_4_82_alloc_table_at_L).
  unfold Uint64.infix_lseq in h3. rewrite Uint64.Of_int in h3. omega.
  unfold Uint64.in_bounds. omega.
  split.
  assumption.
  split. assumption.
  split. unfold Uint64.infix_lseq in h3. rewrite Uint64.Of_int in h3. omega.
  unfold Uint64.in_bounds. omega.
  tauto.
Qed.

